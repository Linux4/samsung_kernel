/*
 * Copyright (C) 2018 Samsung Electronics Co., Ltd. All rights reserved.
 *
 * This software is licensed under the terms of the GNU General Public
 * License, as published by the Free Software Foundation, and
 * may be copied, distributed, and modified under those terms.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

#define VENDOR				"AMS"

#define TSL2510_CHIP_NAME	"TSL2510"

#define VERSION				"2"
#define SUB_VERSION			"0"
#define VENDOR_VERSION		"a"

#define MODULE_NAME_ALS		"als_rear"

#define TSL2510_SLAVE_I2C_ADDR_REVID_V0 0x39
#define TSL2510_SLAVE_I2C_ADDR_REVID_V1 0x29

#define AMSDRIVER_I2C_RETRY_DELAY	10
#define AMSDRIVER_I2C_MAX_RETRIES	5

/* AWB/Flicker Definition */
#define FLICKER_SENSOR_ERR_ID_SATURATION  -3

#define USE_GET_FIFO_ALS
#define ALS_AUTOGAIN
#define BYTE				2
#define AWB_INTERVAL		20 /* 20 sample(from 17 to 28) */

#define FLICKER_FIFO_THR	16
#define FLICKER_DATA_CNT	200
#define FLICKER_FIFO_READ	-2

#define TSL2510_IOCTL_MAGIC		0xFD
#define TSL2510_IOCTL_READ_FLICKER	_IOR(TSL2510_IOCTL_MAGIC, 0x01, uint16_t *)

#include "tsl2510.h"
#include <linux/kfifo.h>

#if IS_ENABLED(CONFIG_SENSORS_FLICKER_SELF_TEST)
#include "flicker_test.h"

#define EOL_GAIN                1000

#define FREQ_SPEC_MARGIN        10
#define FREQ100_SPEC_IN(X)      (((X > (100 - FREQ_SPEC_MARGIN)) && (X < (100 + FREQ_SPEC_MARGIN)))?"PASS":"FAIL")
#define FREQ120_SPEC_IN(X)      (((X > (120 - FREQ_SPEC_MARGIN)) && (X < (120 + FREQ_SPEC_MARGIN)))?"PASS":"FAIL")

#define WIDE_CLEAR_SPEC_MIN     0
#define WIDE_CLEAR_SPEC_MAX     5000000
#define WIDE_SPEC_IN(X)         ((X >= WIDE_CLEAR_SPEC_MIN && X <= WIDE_CLEAR_SPEC_MAX)?"PASS":"FAIL")
#define CLEAR_SPEC_IN(X)        ((X >= WIDE_CLEAR_SPEC_MIN && X <= WIDE_CLEAR_SPEC_MAX)?"PASS":"FAIL")
#define ICRATIO_SPEC_IN(X)      "PASS"
#endif

static int als_debug = 1;
static int als_info = 0;
static u16 sample_time_reg; /* Need to data for s/w/ reset */


static DECLARE_KFIFO(ams_fifo, u8, 2 * PAGE_SIZE);

module_param(als_debug, int, S_IRUGO | S_IWUSR);
module_param(als_info, int, S_IRUGO | S_IWUSR);

static struct tsl2510_device_data *tsl2510_data;

#define AMS_ROUND_SHFT_VAL			4
#define AMS_ROUND_ADD_VAL			(1 << (AMS_ROUND_SHFT_VAL - 1))
#define AMS_ALS_GAIN_FACTOR			1000
#define CPU_FRIENDLY_FACTOR_1024		1
#define AMS_ALS_Cc				(118 * CPU_FRIENDLY_FACTOR_1024)
#define AMS_ALS_Rc				(112 * CPU_FRIENDLY_FACTOR_1024)
#define AMS_ALS_Gc				(172 * CPU_FRIENDLY_FACTOR_1024)
#define AMS_ALS_Bc				(180 * CPU_FRIENDLY_FACTOR_1024)
#define AMS_ALS_Wbc				(111 * CPU_FRIENDLY_FACTOR_1024)

#define AMS_ALS_FACTOR				1000

#define AMS_ALS_TIMEBASE			(2780) /* in uSec, see data sheet */
#define AMS_ALS_ADC_MAX_COUNT			(1024) /* see data sheet */
#define AMS_ALS_THRESHOLD_LOW			(5) /* in % */
#define AMS_ALS_THRESHOLD_HIGH			(5) /* in % */

#define AMS_ALS_ATIME				(50000)

#define AMS_AGC_MAX_GAIN                        (4096000)

#define AMS_AGC_NUM_SAMPLES                     (20)

#define WIDEBAND_CONST    (1.6)
#define CLEAR_CONST       (2)



static int ams_getWord(AMS_PORT_portHndl *portHndl, ams_deviceRegister_t reg, uint16_t *readData);
static int ams_setWord(AMS_PORT_portHndl *portHndl, ams_deviceRegister_t reg, uint16_t setData);




/* REENABLE only enables those that were on record as being enabled */
#define AMS_REENABLE(ret)				{ret = ams_setByte(ctx->portHndl, DEVREG_ENABLE, ctx->shadowEnableReg); }
/* DISABLE_ALS disables ALS w/o recording that as its new state */
#define AMS_DISABLE_ALS(ret)			{ret = ams_setField(ctx->portHndl, DEVREG_ENABLE, LOW, (MASK_AEN)); }
#define AMS_REENABLE_ALS(ret)			{ret = ams_setField(ctx->portHndl, DEVREG_ENABLE, HIGH, (MASK_AEN)); }

#define AMS_DISABLE_FD(ret)			{ret = ams_setField(ctx->portHndl, DEVREG_ENABLE, LOW, (MASK_FDEN)); }
#define AMS_REENABLE_FD(ret)			{ret = ams_setField(ctx->portHndl, DEVREG_ENABLE, HIGH, (MASK_FDEN)); }
#define AMS_REENABLE_FD_PON(ret)	{ret = ams_setField(ctx->portHndl, DEVREG_ENABLE, HIGH, (MASK_FDEN | PON)); }

#define AMS_ENABLE_PON(ret)			{ret = ams_setByte(ctx->portHndl, DEVREG_ENABLE, PON); }
#define AMS_DISABLE_FDINT(ret)			{ret = ams_setField(ctx->portHndl, DEVREG_INTENAB, LOW, MASK_FIEN); }
#define AMS_REENABLE_FDINT(ret)			{ret = ams_setField(ctx->portHndl, DEVREG_INTENAB, HIGH, MASK_FIEN); }


#define AMS_SET_SAMPLE_TIME(uSec, ret); {ret = ams_setByte(ctx->portHndl, DEVREG_SAMPLE_TIME0,   (0xFF) & ((alsSampleTimeUsToReg(uSec))<<0));\
					ret = ams_setByte(ctx->portHndl, DEVREG_SAMPLE_TIME1,   (0x07) & ((alsSampleTimeUsToReg(uSec))>>8));}


#define AMS_SET_ALS_TIME(uSec, ret)		{ret = ams_setByte(ctx->portHndl, DEVREG_ALS_NR_SAMPLES0,   (0xFF) & ((alsTimeUsToReg(uSec, ctx->portHndl))<<0));\
						ret = ams_setByte(ctx->portHndl, DEVREG_ALS_NR_SAMPLES1,   (0xFF) & ((alsTimeUsToReg(uSec, ctx->portHndl))>>8));}


// Flicker Measurement time = SAMPLE_TIME * FLICKER_NUM_SAMPLES
#define AMS_SET_FLICKER_NUM_SAMPLES(Num, ret)		{ret = ams_setByte(ctx->portHndl, DEVREG_FD_NR_SAMPLES0,   (0xFF) & ((Num-1)<<0));\
							ret = ams_setField(ctx->portHndl, DEVREG_FD_NR_SAMPLES1,   ((0x07) & ((Num-1)>>8)), 0x07);}

//#define AMS_GET_ALS_TIME(uSec, ret)		{ret = ams_getByte(ctx->portHndl, DEVREG_ATIME,   alsTimeUsToReg(uSec)); }

#define AMS_GET_ALS_GAIN(scaledGain, scaledGain1, gain, ret)	{ret = ams_getByte(ctx->portHndl, DEVREG_ALS_STATUS2, &(gain)); \
								scaledGain = alsGain_conversion[(gain) & 0x0F]; \
								scaledGain1 = alsGain_conversion[(((gain) & 0xF0) >> 4)]; }

#define AMS_GET_MOD_GAIN(scaledGain, scaledGain1, gain, ret)	{ret = ams_getByte(ctx->portHndl, DEVREG_MEAS_SEQR_STEP0_MOD_GAINX_L, &(gain)); \
								scaledGain = alsGain_conversion[(gain) & 0x0F]; \
								scaledGain1 = alsGain_conversion[(((gain) & 0xF0) >> 4)]; }


//#define AMS_SET_ALS_STEP_TIME(uSec, ret)		{ret = ams_setWord(ctx->portHndl, DEVREG_ASTEPL, alsTimeUsToReg(uSec * 1000)); }

#define AMS_SET_ALS_GAIN0(mGain, ret)	{ret = ams_setField(ctx->portHndl, DEVREG_MEAS_SEQR_STEP0_MOD_GAINX_L, alsGainToReg(mGain), MASK_AGAIN0); }
#define AMS_SET_ALS_GAIN1(mGain, ret)	{ret = ams_setField(ctx->portHndl, DEVREG_MEAS_SEQR_STEP0_MOD_GAINX_L, (((alsGainToReg(mGain))<<4) & 0xF0), MASK_AGAIN1); }

#define AMS_SET_ALS_PERS(persCode, ret)	{ret = ams_setField(ctx->portHndl, DEVREG_CFG5, (persCode), MASK_APERS); }

#define AMS_SET_ALS_AINT_DIRECT(x, ret)	{ret = ams_setField(ctx->portHndl, DEVREG_CFG2, x, MASK_AINT_DIRECT); }

#define AMS_SET_ALS_THRS_LOW(x, ret)	{ret = ams_setByte(ctx->portHndl, DEVREG_AILT0, (uint8_t)(((0x000000ff)&(x))>>0) );\
					ret = ams_setByte(ctx->portHndl, DEVREG_AILT1, (uint8_t)(((0x0000ff00)&(x))>>8));\
					ret = ams_setByte(ctx->portHndl, DEVREG_AILT2, (uint8_t)(((0x00ff0000)&(x))>>16));}

#define AMS_SET_ALS_THRS_HIGH(x, ret)	{ret = ams_setByte(ctx->portHndl, DEVREG_AIHT0, (uint8_t)(((0x000000ff)&(x))>>0) );\
					ret = ams_setByte(ctx->portHndl, DEVREG_AIHT1, (uint8_t)(((0x0000ff00)&(x))>>8));\
					ret = ams_setByte(ctx->portHndl, DEVREG_AIHT2, (uint8_t)(((0x00ff0000)&(x))>>16));}

/* Get CRGB and whatever Wideband it may have */
#define AMS_ALS_GET_ALS_DATA(x, ret)		{ret = ams_getBuf(ctx->portHndl, DEVREG_ALS_DATAL0, (uint8_t *) (x), 4); }
#define AMS_AGC_ASAT_MODE(x,ret)     {ret = ams_setField(ctx->portHndl, DEVREG_MEAS_SEQR_STEP1_MOD_PHDX_SMUX_H, x, (MASK_AGC_ASAT)); }
#define AMS_AGC_PREDICT_MODE(x,ret)  {ret = ams_setField(ctx->portHndl, DEVREG_MEAS_SEQR_STEP2_MOD_PHDX_SMUX_H, x, (MASK_AGC_PREDICT)); }

#define AMS_AGC_ENABLE(ret)		{ret = ams_setByte(ctx->portHndl, DEVREG_MOD_CALIB_CFG0,   0x01);\
					ret = ams_setField(ctx->portHndl, DEVREG_MOD_CALIB_CFG2,   HIGH, (MASK_MOD_CALIB_NTH_ITERATION_AGC_ENABLE));}

#define AMS_AGC_DISABLE(ret)	{ret = ams_setByte(ctx->portHndl, DEVREG_MOD_CALIB_CFG0,   0xFF);\
				ret = ams_setField(ctx->portHndl, DEVREG_MOD_CALIB_CFG2,   LOW, (MASK_MOD_CALIB_NTH_ITERATION_AGC_ENABLE));}


// SET AGC MAX GAIN
#define AMS_SET_AGC_MAX_GAIN(mGain, ret)	{ret = ams_setField(ctx->portHndl, DEVREG_CFG8, (((alsGainToReg(mGain))<<4) & 0xF0), MASK_MAX_MOD_GAIN);}

// AGC Number of sample
#define AMS_SET_AGC_NR_SAMPLES(Num, ret)		{ret = ams_setByte(ctx->portHndl, DEVREG_AGC_NR_SAMPLES_LO,   ((0xFF) & ((Num - 1)>>0)));\
							ret = ams_setByte(ctx->portHndl, DEVREG_AGC_NR_SAMPLES_HI,   ((0xFF) & ((Num - 1)>>8)));}

#define AMS_FIFO_CLEAR(ret)            {ret = ams_setField(ctx->portHndl, DEVREG_CONTROL, HIGH, MASK_FIFO_CLR);} //FIFO Buffer , FINT, FIFO_OV, FIFO_LVL all clear

#define AMS_DO_ALS_FINALPROCESS_AFTER_FLICKER(ret)            {ret = ams_setField(ctx->portHndl, DEVREG_CFG1, HIGH, MASK_MEASUREMENT_SEQUENCER_FILL_GAPS); }

// AGC Number of sample  0 ~ 511
#define AMS_SET_FIFO_THR(Num, ret)		{ret = ams_setByte(ctx->portHndl, DEVREG_FIFO_THR,   ((0x01FF & Num) >>1) & (0xFF));\
						ret = ams_setByte(ctx->portHndl, DEVREG_CFG2,   ((0x0001 & Num) & 0xFF));}


// MEAS_SEQR_RESIDUAL_0,//0xD2
#define AMS_RESIDUAL_MODE(x,ret)  {ret = ams_setField(ctx->portHndl, DEVREG_MEAS_SEQR_RESIDUAL_0, x, 0xFF); }


// Enable writing of FD_GAIN to FIFO after each complete flicker measurment
#define AMS_FD_GAIN_TO_FIFO(ret)  {ret = ams_setField(ctx->portHndl, DEVREG_MEAS_MODE1, HIGH, MASK_MOD_FIFO_FD_GAIN_WRITE_ENABLE); }

// Enable writing of FD_END_MARKER to FIFO after each complete flicker measurment
#define AMS_FD_END_MARKER_TO_FIFO(ret)  {ret = ams_setField(ctx->portHndl, DEVREG_MEAS_MODE1, HIGH, MASK_MOD_FIFO_FD_END_MARKER_WRITE_ENABLE); }


#define AMS_ALS_SENSOR_2PD_TURNON(ret)  {ret = ams_setByte(ctx->portHndl, DEVREG_MEAS_SEQR_STEP0_MOD_PHDX_SMUX_L, 0x06); \
					ret = ams_setByte(ctx->portHndl, DEVREG_MEAS_SEQR_STEP0_MOD_PHDX_SMUX_H, 0x00);}

#define AMS_ALS_SENSOR_6PD_TURNON(ret)  {ret = ams_setByte(ctx->portHndl, DEVREG_MEAS_SEQR_STEP0_MOD_PHDX_SMUX_L, 0x66); \
					ret = ams_setByte(ctx->portHndl, DEVREG_MEAS_SEQR_STEP0_MOD_PHDX_SMUX_H, 0x06);}


#define AMS_MOD_FREQ_HALF_FREQ(ret)  {ret = ams_setByte(ctx->portHndl, DEVREG_CFG7, 0x00 ); } //MASK_MOD_DIVIDER_SELECT 0 , 6 clock half of freq
#define AMS_MOD_FREQ_FULL_FREQ(ret)  {ret = ams_setByte(ctx->portHndl, DEVREG_CFG7, 0x01); } //MASK_MOD_DIVIDER_SELECT 1 , 12 clock default


#define TSL2510_MEASUREMENT_SEQUENCER_MOD0_FD_PATTERN_SHIFT 0
#define TSL2510_MASK_MEASUREMENT_SEQUENCER_MOD0_FD_PATTERN (0x0F << TSL2510_MEASUREMENT_SEQUENCER_MOD0_FD_PATTERN_SHIFT)

#define TSL2510_MEASUREMENT_SEQUENCER_MOD1_FD_PATTERN_SHIFT 4
#define TSL2510_MASK_MEASUREMENT_SEQUENCER_MOD1_FD_PATTERN (0x0F << TSL2510_MEASUREMENT_SEQUENCER_MOD1_FD_PATTERN_SHIFT)

#define TSL2510_MEASUREMENT_SEQUENCER_MOD2_FD_PATTERN_SHIFT 4
#define TSL2510_MASK_MEASUREMENT_SEQUENCER_MOD2_FD_PATTERN (0x0F << TSL2510_MEASUREMENT_SEQUENCER_MOD2_FD_PATTERN_SHIFT)

#define TSL2510_MEASUREMENT_SEQUENCER_ALS_PATTERN_SHIFT 0
#define TSL2510_MASK_MEASUREMENT_SEQUENCER_ALS_PATTERN (0x0F << TSL2510_MEASUREMENT_SEQUENCER_ALS_PATTERN_SHIFT)

#define TSL2510_MOD_FIFO_FD_GAIN_WRITE_ENABLE_SHIFT 5
#define TSL2510_MASK_MOD_FIFO_FD_GAIN_WRITE_ENABLE (0x01 << TSL2510_MOD_FIFO_FD_GAIN_WRITE_ENABLE_SHIFT)

#define TSL2510_MOD_FIFO_FD_END_MARKER_WRITE_ENABLE_SHIFT 7
#define TSL2510_MASK_MOD_FIFO_FD_END_MARKER_WRITE_ENABLE (0x01 << TSL2510_MOD_FIFO_FD_END_MARKER_WRITE_ENABLE_SHIFT)

typedef struct {
	uint8_t deviceId;
	uint8_t deviceIdMask;
	uint8_t deviceRef;
	uint8_t deviceRefMask;
	ams_deviceIdentifier_e device;
} ams_deviceIdentifier_t;

typedef struct _fifo {
	uint32_t AdcClear;
	uint32_t AdcWb;
} adcDataSet_t;

#define AMS_PORT_LOG_CRGB_W(dataset) \
	ALS_info("%s - C = %u, WB = %u\n", __func__ \
			, dataset.AdcClear \
			, dataset.AdcWb	\
			)

static ams_deviceIdentifier_t deviceIdentifier[] = {
	{ AMS_DEVICE_ID, AMS_DEVICE_ID_MASK, AMS_REV_ID, AMS_REV_ID_MASK, AMS_TSL2510 },
	{ AMS_DEVICE_ID, AMS_DEVICE_ID_MASK, AMS_REV_ID_UNTRIM, AMS_REV_ID_MASK, AMS_TSL2510_UNTRIM },
	{ 0, 0, 0, 0, AMS_LAST_DEVICE }
};
#define coef_a 61ULL //  0.06061 * 1000 , scaled
#define coef_b 45ULL //  0.04537 * 1000 , scaled

deviceRegisterTable_t deviceRegisterDefinition[DEVREG_REG_MAX] = {
	{	0x40	,	0x00	},		/*	DEVREG_MOD_CHANNEL_CTRL	*/
	{	0x80	,	0x00	},		/*	DEVREG_ENABLE	*/
	{	0x81	,	0x04	},		/*	DEVREG_MEAS_MODE0	*/
	{	0x82	,	0x0C	},		/*	DEVREG_MEAS_MODE1	*/
	{	0x83	,	0xB3	},		/*	DEVREG_SAMPLE_TIME0	*/
	{	0x84	,	0x00	},		/*	DEVREG_SAMPLE_TIME1	*/
	{	0x85	,	0x00	},		/*	DEVREG_ALS_NR_SAMPLES0	*/
	{	0x86	,	0x00	},		/*	DEVREG_ALS_NR_SAMPLES1	*/
	{	0x87	,	0x00	},		/*	DEVREG_FD_NR_SAMPLES0	*/
	{	0x88	,	0x00	},		/*	DEVREG_FD_NR_SAMPLES1	*/
	{	0x89	,	0x00	},		/*	DEVREG_WTIME	*/
	{	0x8A	,	0x00	},		/*	DEVREG_AILT0	*/
	{	0x8B	,	0x00	},		/*	DEVREG_AILT1	*/
	{	0x8C	,	0x00	},		/*	DEVREG_AILT2	*/
	{	0x8D	,	0x00	},		/*	DEVREG_AIHT0	*/
	{	0x8E	,	0x00	},		/*	DEVREG_AIHT1	*/
	{	0x8F	,	0x00	},		/*	DEVREG_AIHT2	*/
	{	0x90	,	0x00	},		/*	DEVREG_AUXID	*/
	{	0x91	,	AMS_REV_ID },		/*	DEVREG_REVID	*/
	{	0x92	,	AMS_DEVICE_ID },	/*	DEVREG_ID	*/
	{	0x93	,	0x00	},		/*	DEVREG_STATUS	*/
	{	0x94	,	0x00	},		/*	DEVREG_ALS_STATUS	*/
	{	0x95	,	0x00	},		/*	DEVREG_DATAL0	*/
	{	0x96	,	0x00	},		/*	DEVREG_DATAH0	*/
	{	0x97	,	0x00	},		/*	DEVREG_DATAL1	*/
	{	0x98	,	0x00	},		/*	DEVREG_DATAH1	*/
	{	0x99	,	0x00	},		/*	DEVREG_DATAL2	*/
	{	0x9A	,	0x00	},		/*	DEVREG_DATAH2	*/
	{	0x9B	,	0x00	},		/*	DEVREG_ALS_STATUS2	*/
	{	0x9C	,	0x00	},		/*	DEVREG_ALS_STATUS3	*/
	{	0x9D	,	0x00	},		/*	DEVREG_STATUS2	*/
	{	0x9E	,	0x08	},		/*	DEVREG_STATUS3	*/
	{	0x9F	,	0x00	},		/*	DEVREG_STATUS4	*/
	{	0xA0	,	0x00	},		/*	DEVREG_STATUS5	*/
	{	0xA1	,	0x08	},		/*	DEVREG_CFG0	*/
	{	0xA2	,	0x00	},		/*	DEVREG_CFG1	*/
	{	0xA3	,	0x01	},		/*	DEVREG_CFG2	*/
	{	0xA4	,	0x00	},		/*	DEVREG_CFG3	*/
	{	0xA5	,	0x00	},		/*	DEVREG_CFG4	*/
	{	0xA6	,	0x00	},		/*	DEVREG_CFG5	*/
	{	0xA7	,	0x03	},		/*	DEVREG_CFG6	*/
	{	0xA8	,	0x01	},		/*	DEVREG_CFG7	*/
	{	0xA9	,	0xC4	},		/*	DEVREG_CFG8	*/
	{	0xAA	,	0x00	},		/*	DEVREG_CFG9	*/
	{	0xAC	,	0x00	},		/*	DEVREG_AGC_NR_SAMPLES_LO	*/
	{	0xAD	,	0x00	},		/*	DEVREG_AGC_NR_SAMPLES_HI	*/
	{	0xAE	,	0x00	},		/*	DEVREG_TRIGGER_MODE	*/
	{	0xB1	,	0x00	},		/*	DEVREG_CONTROL	*/
	{	0xBA	,	0x00	},		/*	DEVREG_INTENAB	*/
	{	0xBB	,	0x00	},		/*	DEVREG_SIEN	*/
	{	0xCE	,	0x80	},		/*	DEVREG_MOD_COMP_CFG1	*/
	{	0xCF	,	0x01	},		/*	DEVREG_MEAS_SEQR_FD_0	*/
	{	0xD0	,	0x01	},		/*	DEVREG_MEAS_SEQR_ALS_FD_1	*/
	{	0xD1	,	0x01	},		/*	DEVREG_MEAS_SEQR_APERS_AND_VSYNC_WAIT	*/
	{	0xD2	,	0xFF	},		/*	DEVREG_MEAS_SEQR_RESIDUAL_0	*/
	{	0xD3	,	0x1F	},		/*	DEVREG_MEAS_SEQR_RESIDUAL_1_AND_WAIT	*/
	{	0xD4	,	0x88	},		/*	DEVREG_MEAS_SEQR_STEP0_MOD_GAINX_L	*/
	{	0xD5	,	0x80	},		/*	DEVREG_MEAS_SEQR_STEP0_MOD_GAINX_H	*/
	{	0xD6	,	0x88	},		/*	DEVREG_MEAS_SEQR_STEP1_MOD_GAINX_L	*/
	{	0xD8	,	0x88	},		/*	DEVREG_MEAS_SEQR_STEP2_MOD_GAINX_L	*/
	{	0xDA	,	0x88	},		/*	DEVREG_MEAS_SEQR_STEP3_MOD_GAINX_L	*/
	{	0xDC	,	0x66	},		/*	DEVREG_MEAS_SEQR_STEP0_MOD_PHDX_SMUX_L	*/
	{	0xDD	,	0x06	},		/*	DEVREG_MEAS_SEQR_STEP0_MOD_PHDX_SMUX_H	*/
	{	0xDE	,	0x84	},		/*	DEVREG_MEAS_SEQR_STEP1_MOD_PHDX_SMUX_L	*/
	{	0xDF	,	0xF3	},		/*	DEVREG_MEAS_SEQR_STEP1_MOD_PHDX_SMUX_H	*/
	{	0xE0	,	0x07	},		/*	DEVREG_MEAS_SEQR_STEP2_MOD_PHDX_SMUX_L	*/
	{	0xE1	,	0xF8	},		/*	DEVREG_MEAS_SEQR_STEP2_MOD_PHDX_SMUX_H	*/
	{	0xE2	,	0x24	},		/*	DEVREG_MEAS_SEQR_STEP3_MOD_PHDX_SMUX_L	*/
	{	0xE3	,	0x03	},		/*	DEVREG_MEAS_SEQR_STEP3_MOD_PHDX_SMUX_H	*/
	{	0xE4	,	0xFF	},		/*	DEVREG_MOD_CALIB_CFG0	*/
	{	0xE6	,	0xD3	},		/*	DEVREG_MOD_CALIB_CFG2	*/
	{	0xF2	,	0x00	},		/*	DEVREG_VSYNC_PERIOD_L	*/
	{	0xF3	,	0x00	},		/*	DEVREG_VSYNC_PERIOD_H	*/
	{	0xF4	,	0x00	},		/*	DEVREG_VSYNC_PERIOD_TARGET_L	*/
	{	0xF5	,	0x00	},		/*	DEVREG_VSYNC_PERIOD_TARGET_H	*/
	{	0xF6	,	0x00	},		/*	DEVREG_VSYNC_CONTROL	*/
	{	0xF7	,	0x00	},		/*	DEVREG_VSYNC_CFG	*/
	{	0xF8	,	0x02	},		/*	DEVREG_VSYNC_GPIO_INT	*/
	{	0xF9	,	0x8F	},		/*	DEVREG_MOD_FIFO_DATA_CFG0	*/
	{	0xFA	,	0x8F	},		/*	DEVREG_MOD_FIFO_DATA_CFG1	*/
	{	0xFB	,	0x8F	},		/*	DEVREG_MOD_FIFO_DATA_CFG2	*/
	{	0xFC	,	0x7F	},		/*	DEVREG_FIFO_THR	*/
	{	0xFD	,	0x00	},		/*	DEVREG_FIFO_LEVEL	*/
	{	0xFE	,	0x00	},		/*	DEVREG_FIFO_STATUS0	*/
	{	0xFF	,	0x00	},		/*	DEVREG_FIFO_DATA	*/
};

/* Gain x2 */
uint32_t alsGain_conversion[] = {
	1 * 500,
	1 * 1000,
	2 * 1000,
	4 * 1000,
	8 * 1000,
	16 * 1000,
	32 * 1000,
	64 * 1000,
	128 * 1000,
	256 * 1000,
	512 * 1000,
	1024 * 1000,
	2048 * 1000,
	4096 * 1000,
	//8192 * 1000,
};

uint16_t tsl2510_gain_conversion[] = {
	1, /* == 0.5 */
	2,
	4,
	8,
	16,
	32,
	64,
	128,
	256,
	512,
	1024,
	2048,
	4096,
	8192,
};

uint16_t fdGain_conversion[] = {
	1,
	2,
	4,
	8,
	16,
	32,
	64,
	128,
	256,
	512,
	1024,
	2048,
	4096,
	8192,
};

// sec_hamming : 0~65535, Q16
static const int32_t hamming[2048] = {
	5243,  5243,  5243,  5244,  5245,  5246,  5248,  5250,  5252,  5254,  5257,  5260,  5263,  5267,  5271,  5275,  5279,  5284,  5289,  5294,  5300,  5305, 5312,  5318,  5325,  5332,  5339,  5346,  5354,  5362,  5370,  5379,  5388,  5397,  5407,  5417,  5427,  5437,  5448,  5458,  5470,  5481,  5493,  5505, 5517,  5530,  5543,  5556,  5569,  5583,  5597,  5611,  5626,  5641,  5656,  5671,  5687,  5703,  5719,  5735,  5752,  5769,  5787,  5804,  5822,  5840, 5859,  5878,  5897,  5916,  5935,  5955,  5975,  5996,  6016,  6037,  6059,  6080,  6102,  6124,  6146,  6169,  6192,  6215,  6238,  6262,  6286,  6310,
	6335,  6360,  6385,  6410,  6436,  6462,  6488,  6514,  6541,  6568,  6595,  6623,  6651,  6679,  6707,  6736,  6764,  6794,  6823,  6853,  6883,  6913, 6943,  6974,  7005,  7036,  7068,  7100,  7132,  7164,  7197,  7230,  7263,  7296,  7330,  7364,  7398,  7433,  7467,  7502,  7538,  7573,  7609,  7645, 7681,  7718,  7755,  7792,  7829,  7867,  7905,  7943,  7981,  8020,  8059,  8098,  8137,  8177,  8217,  8257,  8297,  8338,  8379,  8420,  8462,  8504, 8545,  8588,  8630,  8673,  8716,  8759,  8803,  8846,  8890,  8934,  8979,  9024,  9069,  9114,  9159,  9205,  9251,  9297,  9344,  9390,  9437,  9484,
	9532,  9580,  9627,  9676,  9724,  9773,  9822,  9871,  9920,  9970,  10019, 10070, 10120, 10170, 10221, 10272, 10323, 10375, 10427, 10479, 10531, 10583, 10636, 10689, 10742, 10795, 10849, 10903, 10957, 11011, 11066, 11121, 11175, 11231, 11286, 11342, 11398, 11454, 11510, 11567, 11624, 11681, 11738, 11795, 11853, 11911, 11969, 12027, 12086, 12145, 12204, 12263, 12322, 12382, 12442, 12502, 12562, 12623, 12683, 12744, 12806, 12867, 12929, 12990, 13052, 13115, 13177, 13240, 13302, 13365, 13429, 13492, 13556, 13620, 13684, 13748, 13813, 13877, 13942, 14007, 14073, 14138, 14204, 14270, 14336, 14402, 14469, 14535,
	14602, 14669, 14737, 14804, 14872, 14940, 15008, 15076, 15144, 15213, 15282, 15351, 15420, 15489, 15559, 15629, 15699, 15769, 15839, 15909, 15980, 16051, 16122, 16193, 16265, 16336, 16408, 16480, 16552, 16624, 16697, 16769, 16842, 16915, 16988, 17062, 17135, 17209, 17283, 17357, 17431, 17506, 17580, 17655, 17730, 17805, 17880, 17955, 18031, 18107, 18182, 18258, 18335, 18411, 18487, 18564, 18641, 18718, 18795, 18872, 18950, 19027, 19105, 19183, 19261, 19339, 19418, 19496, 19575, 19654, 19733, 19812, 19891, 19970, 20050, 20130, 20209, 20289, 20370, 20450, 20530, 20611, 20691, 20772, 20853, 20934, 21016, 21097,
	21178, 21260, 21342, 21424, 21506, 21588, 21670, 21753, 21835, 21918, 22001, 22084, 22167, 22250, 22333, 22417, 22500, 22584, 22668, 22751, 22836, 22920, 23004, 23088, 23173, 23257, 23342, 23427, 23512, 23597, 23682, 23767, 23853, 23938, 24024, 24110, 24196, 24281, 24367, 24454, 24540, 24626, 24713, 24799, 24886, 24973, 25059, 25146, 25233, 25320, 25408, 25495, 25582, 25670, 25758, 25845, 25933, 26021, 26109, 26197, 26285, 26373, 26462, 26550, 26638, 26727, 26816, 26904, 26993, 27082, 27171, 27260, 27349, 27438, 27527, 27617, 27706, 27796, 27885, 27975, 28064, 28154, 28244, 28334, 28424, 28514, 28604, 28694,
	28784, 28875, 28965, 29055, 29146, 29236, 29327, 29417, 29508, 29599, 29690, 29781, 29871, 29962, 30053, 30144, 30236, 30327, 30418, 30509, 30600, 30692, 30783, 30875, 30966, 31058, 31149, 31241, 31332, 31424, 31516, 31607, 31699, 31791, 31883, 31975, 32067, 32159, 32251, 32343, 32435, 32527, 32619, 32711, 32803, 32895, 32987, 33079, 33172, 33264, 33356, 33449, 33541, 33633, 33725, 33818, 33910, 34003, 34095, 34187, 34280, 34372, 34465, 34557, 34650, 34742, 34835, 34927, 35019, 35112, 35204, 35297, 35389, 35482, 35574, 35667, 35759, 35852, 35944, 36037, 36129, 36222, 36314, 36407, 36499, 36591, 36684, 36776,
	36869, 36961, 37053, 37146, 37238, 37330, 37423, 37515, 37607, 37699, 37792, 37884, 37976, 38068, 38160, 38252, 38344, 38436, 38528, 38620, 38712, 38804, 38896, 38988, 39080, 39171, 39263, 39355, 39447, 39538, 39630, 39721, 39813, 39904, 39996, 40087, 40178, 40270, 40361, 40452, 40543, 40634, 40726, 40817, 40907, 40998, 41089, 41180, 41271, 41361, 41452, 41543, 41633, 41724, 41814, 41904, 41995, 42085, 42175, 42265, 42355, 42445, 42535, 42625, 42714, 42804, 42894, 42983, 43073, 43162, 43251, 43341, 43430, 43519, 43608, 43697, 43786, 43875, 43963, 44052, 44141, 44229, 44317, 44406, 44494, 44582, 44670, 44758,
	44846, 44934, 45021, 45109, 45196, 45284, 45371, 45458, 45546, 45633, 45719, 45806, 45893, 45980, 46066, 46153, 46239, 46325, 46411, 46497, 46583, 46669, 46755, 46841, 46926, 47011, 47097, 47182, 47267, 47352, 47437, 47521, 47606, 47691, 47775, 47859, 47943, 48027, 48111, 48195, 48279, 48362, 48446, 48529, 48612, 48695, 48778, 48861, 48944, 49026, 49109, 49191, 49273, 49355, 49437, 49519, 49600, 49682, 49763, 49845, 49926, 50007, 50087, 50168, 50249, 50329, 50409, 50489, 50569, 50649, 50729, 50808, 50888, 50967, 51046, 51125, 51204, 51283, 51361, 51440, 51518, 51596, 51674, 51752, 51829, 51907, 51984, 52061,
	52138, 52215, 52291, 52368, 52444, 52520, 52597, 52672, 52748, 52824, 52899, 52974, 53049, 53124, 53199, 53273, 53348, 53422, 53496, 53570, 53644, 53717, 53790, 53864, 53937, 54009, 54082, 54155, 54227, 54299, 54371, 54443, 54514, 54586, 54657, 54728, 54799, 54869, 54940, 55010, 55080, 55150, 55220, 55290, 55359, 55428, 55497, 55566, 55635, 55703, 55771, 55839, 55907, 55975, 56042, 56110, 56177, 56244, 56310, 56377, 56443, 56509, 56575, 56641, 56706, 56772, 56837, 56902, 56966, 57031, 57095, 57159, 57223, 57287, 57350, 57413, 57476, 57539, 57602, 57664, 57727, 57789, 57850, 57912, 57973, 58034, 58095, 58156,
	58217, 58277, 58337, 58397, 58457, 58516, 58575, 58634, 58693, 58752, 58810, 58868, 58926, 58984, 59041, 59098, 59155, 59212, 59269, 59325, 59381, 59437, 59493, 59548, 59603, 59658, 59713, 59768, 59822, 59876, 59930, 59983, 60037, 60090, 60143, 60196, 60248, 60300, 60352, 60404, 60455, 60507, 60558, 60608, 60659, 60709, 60759, 60809, 60859, 60908, 60957, 61006, 61055, 61103, 61151, 61199, 61247, 61294, 61342, 61389, 61435, 61482, 61528, 61574, 61620, 61665, 61710, 61755, 61800, 61844, 61889, 61933, 61976, 62020, 62063, 62106, 62149, 62191, 62233, 62275, 62317, 62359, 62400, 62441, 62481, 62522, 62562, 62602,
	62642, 62681, 62720, 62759, 62798, 62836, 62874, 62912, 62950, 62987, 63024, 63061, 63098, 63134, 63170, 63206, 63241, 63276, 63311, 63346, 63381, 63415, 63449, 63483, 63516, 63549, 63582, 63615, 63647, 63679, 63711, 63742, 63774, 63805, 63836, 63866, 63896, 63926, 63956, 63985, 64014, 64043, 64072, 64100, 64128, 64156, 64184, 64211, 64238, 64265, 64291, 64317, 64343, 64369, 64394, 64419, 64444, 64469, 64493, 64517, 64540, 64564, 64587, 64610, 64633, 64655, 64677, 64699, 64720, 64741, 64762, 64783, 64804, 64824, 64843, 64863, 64882, 64901, 64920, 64939, 64957, 64975, 64992, 65010, 65027, 65043, 65060, 65076,
	65092, 65108, 65123, 65138, 65153, 65168, 65182, 65196, 65210, 65223, 65236, 65249, 65262, 65274, 65286, 65298, 65309, 65320, 65331, 65342, 65352, 65362, 65372, 65382, 65391, 65400, 65408, 65417, 65425, 65433, 65440, 65447, 65454, 65461, 65467, 65473, 65479, 65485, 65490, 65495, 65500, 65504, 65508, 65512, 65516, 65519, 65522, 65525, 65527, 65529, 65531, 65532, 65534, 65535, 65535, 65536, 65536, 65536, 65535, 65535, 65534, 65532, 65531, 65529, 65527, 65525, 65522, 65519, 65516, 65512, 65508, 65504, 65500, 65495, 65490, 65485, 65479, 65473, 65467, 65461, 65454, 65447, 65440, 65433, 65425, 65417, 65408, 65400,
	65391, 65382, 65372, 65362, 65352, 65342, 65331, 65320, 65309, 65298, 65286, 65274, 65262, 65249, 65236, 65223, 65210, 65196, 65182, 65168, 65153, 65138, 65123, 65108, 65092, 65076, 65060, 65043, 65027, 65010, 64992, 64975, 64957, 64939, 64920, 64901, 64882, 64863, 64843, 64824, 64804, 64783, 64762, 64741, 64720, 64699, 64677, 64655, 64633, 64610, 64587, 64564, 64540, 64517, 64493, 64469, 64444, 64419, 64394, 64369, 64343, 64317, 64291, 64265, 64238, 64211, 64184, 64156, 64128, 64100, 64072, 64043, 64014, 63985, 63956, 63926, 63896, 63866, 63836, 63805, 63774, 63742, 63711, 63679, 63647, 63615, 63582, 63549,
	63516, 63483, 63449, 63415, 63381, 63346, 63311, 63276, 63241, 63206, 63170, 63134, 63098, 63061, 63024, 62987, 62950, 62912, 62874, 62836, 62798, 62759, 62720, 62681, 62642, 62602, 62562, 62522, 62481, 62441, 62400, 62359, 62317, 62275, 62233, 62191, 62149, 62106, 62063, 62020, 61976, 61933, 61889, 61844, 61800, 61755, 61710, 61665, 61620, 61574, 61528, 61482, 61435, 61389, 61342, 61294, 61247, 61199, 61151, 61103, 61055, 61006, 60957, 60908, 60859, 60809, 60759, 60709, 60659, 60608, 60558, 60507, 60455, 60404, 60352, 60300, 60248, 60196, 60143, 60090, 60037, 59983, 59930, 59876, 59822, 59768, 59713, 59658,
	59603, 59548, 59493, 59437, 59381, 59325, 59269, 59212, 59155, 59098, 59041, 58984, 58926, 58868, 58810, 58752, 58693, 58634, 58575, 58516, 58457, 58397, 58337, 58277, 58217, 58156, 58095, 58034, 57973, 57912, 57850, 57789, 57727, 57664, 57602, 57539, 57476, 57413, 57350, 57287, 57223, 57159, 57095, 57031, 56966, 56902, 56837, 56772, 56706, 56641, 56575, 56509, 56443, 56377, 56310, 56244, 56177, 56110, 56042, 55975, 55907, 55839, 55771, 55703, 55635, 55566, 55497, 55428, 55359, 55290, 55220, 55150, 55080, 55010, 54940, 54869, 54799, 54728, 54657, 54586, 54514, 54443, 54371, 54299, 54227, 54155, 54082, 54009,
	53937, 53864, 53790, 53717, 53644, 53570, 53496, 53422, 53348, 53273, 53199, 53124, 53049, 52974, 52899, 52824, 52748, 52672, 52597, 52520, 52444, 52368, 52291, 52215, 52138, 52061, 51984, 51907, 51829, 51752, 51674, 51596, 51518, 51440, 51361, 51283, 51204, 51125, 51046, 50967, 50888, 50808, 50729, 50649, 50569, 50489, 50409, 50329, 50249, 50168, 50087, 50007, 49926, 49845, 49763, 49682, 49600, 49519, 49437, 49355, 49273, 49191, 49109, 49026, 48944, 48861, 48778, 48695, 48612, 48529, 48446, 48362, 48279, 48195, 48111, 48027, 47943, 47859, 47775, 47691, 47606, 47521, 47437, 47352, 47267, 47182, 47097, 47011,
	46926, 46841, 46755, 46669, 46583, 46497, 46411, 46325, 46239, 46153, 46066, 45980, 45893, 45806, 45719, 45633, 45546, 45458, 45371, 45284, 45196, 45109, 45021, 44934, 44846, 44758, 44670, 44582, 44494, 44406, 44317, 44229, 44141, 44052, 43963, 43875, 43786, 43697, 43608, 43519, 43430, 43341, 43251, 43162, 43073, 42983, 42894, 42804, 42714, 42625, 42535, 42445, 42355, 42265, 42175, 42085, 41995, 41904, 41814, 41724, 41633, 41543, 41452, 41361, 41271, 41180, 41089, 40998, 40907, 40817, 40726, 40634, 40543, 40452, 40361, 40270, 40178, 40087, 39996, 39904, 39813, 39721, 39630, 39538, 39447, 39355, 39263, 39171,
	39080, 38988, 38896, 38804, 38712, 38620, 38528, 38436, 38344, 38252, 38160, 38068, 37976, 37884, 37792, 37699, 37607, 37515, 37423, 37330, 37238, 37146, 37053, 36961, 36869, 36776, 36684, 36591, 36499, 36407, 36314, 36222, 36129, 36037, 35944, 35852, 35759, 35667, 35574, 35482, 35389, 35297, 35204, 35112, 35019, 34927, 34835, 34742, 34650, 34557, 34465, 34372, 34280, 34187, 34095, 34003, 33910, 33818, 33725, 33633, 33541, 33449, 33356, 33264, 33172, 33079, 32987, 32895, 32803, 32711, 32619, 32527, 32435, 32343, 32251, 32159, 32067, 31975, 31883, 31791, 31699, 31607, 31516, 31424, 31332, 31241, 31149, 31058,
	30966, 30875, 30783, 30692, 30600, 30509, 30418, 30327, 30236, 30144, 30053, 29962, 29871, 29781, 29690, 29599, 29508, 29417, 29327, 29236, 29146, 29055, 28965, 28875, 28784, 28694, 28604, 28514, 28424, 28334, 28244, 28154, 28064, 27975, 27885, 27796, 27706, 27617, 27527, 27438, 27349, 27260, 27171, 27082, 26993, 26904, 26816, 26727, 26638, 26550, 26462, 26373, 26285, 26197, 26109, 26021, 25933, 25845, 25758, 25670, 25582, 25495, 25408, 25320, 25233, 25146, 25059, 24973, 24886, 24799, 24713, 24626, 24540, 24454, 24367, 24281, 24196, 24110, 24024, 23938, 23853, 23767, 23682, 23597, 23512, 23427, 23342, 23257,
	23173, 23088, 23004, 22920, 22836, 22751, 22668, 22584, 22500, 22417, 22333, 22250, 22167, 22084, 22001, 21918, 21835, 21753, 21670, 21588, 21506, 21424, 21342, 21260, 21178, 21097, 21016, 20934, 20853, 20772, 20691, 20611, 20530, 20450, 20370, 20289, 20209, 20130, 20050, 19970, 19891, 19812, 19733, 19654, 19575, 19496, 19418, 19339, 19261, 19183, 19105, 19027, 18950, 18872, 18795, 18718, 18641, 18564, 18487, 18411, 18335, 18258, 18182, 18107, 18031, 17955, 17880, 17805, 17730, 17655, 17580, 17506, 17431, 17357, 17283, 17209, 17135, 17062, 16988, 16915, 16842, 16769, 16697, 16624, 16552, 16480, 16408, 16336,
	16265, 16193, 16122, 16051, 15980, 15909, 15839, 15769, 15699, 15629, 15559, 15489, 15420, 15351, 15282, 15213, 15144, 15076, 15008, 14940, 14872, 14804, 14737, 14669, 14602, 14535, 14469, 14402, 14336, 14270, 14204, 14138, 14073, 14007, 13942, 13877, 13813, 13748, 13684, 13620, 13556, 13492, 13429, 13365, 13302, 13240, 13177, 13115, 13052, 12990, 12929, 12867, 12806, 12744, 12683, 12623, 12562, 12502, 12442, 12382, 12322, 12263, 12204, 12145, 12086, 12027, 11969, 11911, 11853, 11795, 11738, 11681, 11624, 11567, 11510, 11454, 11398, 11342, 11286, 11231, 11175, 11121, 11066, 11011, 10957, 10903, 10849, 10795,
	10742, 10689, 10636, 10583, 10531, 10479, 10427, 10375, 10323, 10272, 10221, 10170, 10120, 10070, 10019, 9970,  9920,  9871,  9822,  9773,  9724,  9676, 9627,  9580,  9532,  9484,  9437,  9390,  9344,  9297,  9251,  9205,  9159, 9114,  9069,  9024,  8979,  8934,  8890,  8846,  8803,  8759,  8716,  8673, 8630,  8588,  8545,  8504,  8462,  8420,  8379,  8338,  8297,  8257,  8217, 8177,  8137,  8098,  8059,  8020,  7981,  7943,  7905,  7867,  7829,  7792, 7755,  7718,  7681,  7645,  7609,  7573,  7538,  7502,  7467,  7433,  7398, 7364,  7330,  7296,  7263,  7230,  7197,  7164,  7132,  7100,  7068,  7036,
	7005,  6974,  6943,  6913,  6883,  6853,  6823,  6794,  6764,  6736,  6707, 6679,  6651,  6623,  6595,  6568,  6541,  6514,  6488,  6462,  6436,  6410, 6385,  6360,  6335,  6310,  6286,  6262,  6238,  6215,  6192,  6169,  6146, 6124,  6102,  6080,  6059,  6037,  6016,  5996,  5975,  5955,  5935,  5916, 5897,  5878,  5859,  5840,  5822,  5804,  5787,  5769,  5752,  5735,  5719, 5703,  5687,  5671,  5656,  5641,  5626,  5611,  5597,  5583,  5569,  5556, 5543,  5530,  5517,  5505,  5493,  5481,  5470,  5458,  5448,  5437,  5427, 5417,  5407,  5397,  5388,  5379,  5370,  5362,  5354,  5346,  5339,  5332,
	5325,  5318,  5312,  5305,  5300,  5294,  5289,  5284,  5279,  5275,  5271, 5267,  5263,  5260,  5257,  5254,  5252,  5250,  5248,  5246,  5245,  5244, 5243,  5243,
};

// sec_sin, sec_cos : -65536~65536
static const int32_t sin[1024] = {
		 0,    402,    804,   1206,   1608,   2010,   2412,   2814,   3215,   3617,   4018,   4420,   4821,   5222,   5622,   6023,   6423,   6823,   7223,   7623,
	  8022,   8421,   8819,   9218,   9616,  10013,  10410,  10807,  11204,  11600,  11995,  12390,  12785,  13179,  13573,  13966,  14359,  14751,  15142,  15533,
	 15923,  16313,  16702,  17091,  17479,  17866,  18253,  18638,  19024,  19408,  19792,  20175,  20557,  20938,  21319,  21699,  22078,  22456,  22833,  23210,
	 23586,  23960,  24334,  24707,  25079,  25450,  25820,  26189,  26557,  26925,  27291,  27656,  28020,  28383,  28745,  29105,  29465,  29824,  30181,  30538,
	 30893,  31247,  31600,  31952,  32302,  32651,  32999,  33346,  33692,  34036,  34379,  34721,  35061,  35400,  35738,  36074,  36409,  36743,  37075,  37406,
	 37736,  38064,  38390,  38716,  39039,  39362,  39682,  40002,  40319,  40636,  40950,  41263,  41575,  41885,  42194,  42501,  42806,  43110,  43412,  43712,
	 44011,  44308,  44603,  44897,  45189,  45480,  45768,  46055,  46340,  46624,  46906,  47186,  47464,  47740,  48015,  48288,  48558,  48828,  49095,  49360,
	 49624,  49886,  50146,  50403,  50660,  50914,  51166,  51416,  51665,  51911,  52155,  52398,  52639,  52877,  53114,  53348,  53581,  53811,  54040,  54266,
	 54491,  54713,  54933,  55152,  55368,  55582,  55794,  56004,  56212,  56417,  56621,  56822,  57022,  57219,  57414,  57606,  57797,  57986,  58172,  58356,
	 58538,  58718,  58895,  59070,  59243,  59414,  59583,  59749,  59913,  60075,  60235,  60392,  60547,  60700,  60850,  60998,  61144,  61288,  61429,  61568,
	 61705,  61839,  61971,  62100,  62228,  62353,  62475,  62596,  62714,  62829,  62942,  63053,  63162,  63268,  63371,  63473,  63571,  63668,  63762,  63854,
	 63943,  64030,  64115,  64197,  64276,  64353,  64428,  64501,  64571,  64638,  64703,  64766,  64826,  64884,  64939,  64992,  65043,  65091,  65136,  65179,
	 65220,  65258,  65294,  65327,  65358,  65386,  65412,  65436,  65457,  65475,  65491,  65505,  65516,  65524,  65531,  65534,  65536,  65534,  65531,  65524,
	 65516,  65505,  65491,  65475,  65457,  65436,  65412,  65386,  65358,  65327,  65294,  65258,  65220,  65179,  65136,  65091,  65043,  64992,  64939,  64884,
	 64826,  64766,  64703,  64638,  64571,  64501,  64428,  64353,  64276,  64197,  64115,  64030,  63943,  63854,  63762,  63668,  63571,  63473,  63371,  63268,
	 63162,  63053,  62942,  62829,  62714,  62596,  62475,  62353,  62228,  62100,  61971,  61839,  61705,  61568,  61429,  61288,  61144,  60998,  60850,  60700,
	 60547,  60392,  60235,  60075,  59913,  59749,  59583,  59414,  59243,  59070,  58895,  58718,  58538,  58356,  58172,  57986,  57797,  57606,  57414,  57219,
	 57022,  56822,  56621,  56417,  56212,  56004,  55794,  55582,  55368,  55152,  54933,  54713,  54491,  54266,  54040,  53811,  53581,  53348,  53114,  52877,
	 52639,  52398,  52155,  51911,  51665,  51416,  51166,  50914,  50660,  50403,  50146,  49886,  49624,  49360,  49095,  48828,  48558,  48288,  48015,  47740,
	 47464,  47186,  46906,  46624,  46340,  46055,  45768,  45480,  45189,  44897,  44603,  44308,  44011,  43712,  43412,  43110,  42806,  42501,  42194,  41885,
	 41575,  41263,  40950,  40636,  40319,  40002,  39682,  39362,  39039,  38716,  38390,  38064,  37736,  37406,  37075,  36743,  36409,  36074,  35738,  35400,
	 35061,  34721,  34379,  34036,  33692,  33346,  32999,  32651,  32302,  31952,  31600,  31247,  30893,  30538,  30181,  29824,  29465,  29105,  28745,  28383,
	 28020,  27656,  27291,  26925,  26557,  26189,  25820,  25450,  25079,  24707,  24334,  23960,  23586,  23210,  22833,  22456,  22078,  21699,  21319,  20938,
	 20557,  20175,  19792,  19408,  19024,  18638,  18253,  17866,  17479,  17091,  16702,  16313,  15923,  15533,  15142,  14751,  14359,  13966,  13573,  13179,
	 12785,  12390,  11995,  11600,  11204,  10807,  10410,  10013,   9616,   9218,   8819,   8421,   8022,   7623,   7223,   6823,   6423,   6023,   5622,   5222,
	  4821,   4420,   4018,   3617,   3215,   2814,   2412,   2010,   1608,   1206,    804,    402, 	 0,   -403,   -805,  -1207,  -1609,  -2011,  -2413,  -2815,
	 -3216,  -3618,  -4019,  -4421,  -4822,  -5223,  -5623,  -6024,  -6424,  -6824,  -7224,  -7624,  -8023,  -8422,  -8820,  -9219,  -9617, -10014, -10411, -10808,
	-11205, -11601, -11996, -12391, -12786, -13180, -13574, -13967, -14360, -14752, -15143, -15534, -15924, -16314, -16703, -17092, -17480, -17867, -18254, -18639,
	-19025, -19409, -19793, -20176, -20558, -20939, -21320, -21700, -22079, -22457, -22834, -23211, -23587, -23961, -24335, -24708, -25080, -25451, -25821, -26190,
	-26558, -26926, -27292, -27657, -28021, -28384, -28746, -29106, -29466, -29825, -30182, -30539, -30894, -31248, -31601, -31953, -32303, -32652, -33000, -33347,
	-33693, -34037, -34380, -34722, -35062, -35401, -35739, -36075, -36410, -36744, -37076, -37407, -37737, -38065, -38391, -38717, -39040, -39363, -39683, -40003,
	-40320, -40637, -40951, -41264, -41576, -41886, -42195, -42502, -42807, -43111, -43413, -43713, -44012, -44309, -44604, -44898, -45190, -45481, -45769, -46056,
	-46341, -46625, -46907, -47187, -47465, -47741, -48016, -48289, -48559, -48829, -49096, -49361, -49625, -49887, -50147, -50404, -50661, -50915, -51167, -51417,
	-51666, -51912, -52156, -52399, -52640, -52878, -53115, -53349, -53582, -53812, -54041, -54267, -54492, -54714, -54934, -55153, -55369, -55583, -55795, -56005,
	-56213, -56418, -56622, -56823, -57023, -57220, -57415, -57607, -57798, -57987, -58173, -58357, -58539, -58719, -58896, -59071, -59244, -59415, -59584, -59750,
	-59914, -60076, -60236, -60393, -60548, -60701, -60851, -60999, -61145, -61289, -61430, -61569, -61706, -61840, -61972, -62101, -62229, -62354, -62476, -62597,
	-62715, -62830, -62943, -63054, -63163, -63269, -63372, -63474, -63572, -63669, -63763, -63855, -63944, -64031, -64116, -64198, -64277, -64354, -64429, -64502,
	-64572, -64639, -64704, -64767, -64827, -64885, -64940, -64993, -65044, -65092, -65137, -65180, -65221, -65259, -65295, -65328, -65359, -65387, -65413, -65437,
	-65458, -65476, -65492, -65506, -65517, -65525, -65532, -65535, -65536, -65535, -65532, -65525, -65517, -65506, -65492, -65476, -65458, -65437, -65413, -65387,
	-65359, -65328, -65295, -65259, -65221, -65180, -65137, -65092, -65044, -64993, -64940, -64885, -64827, -64767, -64704, -64639, -64572, -64502, -64429, -64354,
	-64277, -64198, -64116, -64031, -63944, -63855, -63763, -63669, -63572, -63474, -63372, -63269, -63163, -63054, -62943, -62830, -62715, -62597, -62476, -62354,
	-62229, -62101, -61972, -61840, -61706, -61569, -61430, -61289, -61145, -60999, -60851, -60701, -60548, -60393, -60236, -60076, -59914, -59750, -59584, -59415,
	-59244, -59071, -58896, -58719, -58539, -58357, -58173, -57987, -57798, -57607, -57415, -57220, -57023, -56823, -56622, -56418, -56213, -56005, -55795, -55583,
	-55369, -55153, -54934, -54714, -54492, -54267, -54041, -53812, -53582, -53349, -53115, -52878, -52640, -52399, -52156, -51912, -51666, -51417, -51167, -50915,
	-50661, -50404, -50147, -49887, -49625, -49361, -49096, -48829, -48559, -48289, -48016, -47741, -47465, -47187, -46907, -46625, -46341, -46056, -45769, -45481,
	-45190, -44898, -44604, -44309, -44012, -43713, -43413, -43111, -42807, -42502, -42195, -41886, -41576, -41264, -40951, -40637, -40320, -40003, -39683, -39363,
	-39040, -38717, -38391, -38065, -37737, -37407, -37076, -36744, -36410, -36075, -35739, -35401, -35062, -34722, -34380, -34037, -33693, -33347, -33000, -32652,
	-32303, -31953, -31601, -31248, -30894, -30539, -30182, -29825, -29466, -29106, -28746, -28384, -28021, -27657, -27292, -26926, -26558, -26190, -25821, -25451,
	-25080, -24708, -24335, -23961, -23587, -23211, -22834, -22457, -22079, -21700, -21320, -20939, -20558, -20176, -19793, -19409, -19025, -18639, -18254, -17867,
	-17480, -17092, -16703, -16314, -15924, -15534, -15143, -14752, -14360, -13967, -13574, -13180, -12786, -12391, -11996, -11601, -11205, -10808, -10411, -10014,
	 -9617,  -9219,  -8820,  -8422,  -8023,  -7624,  -7224,  -6824,  -6424,  -6024,  -5623,  -5223,  -4822,  -4421,  -4019,  -3618,  -3216,  -2815,  -2413,  -2011,
	 -1609,  -1207,   -805,   -403
};

static const int32_t cos[1024] = {
	 65536,  65534,  65531,  65524,  65516,  65505,  65491,  65475,  65457,  65436,  65412,  65386,  65358,  65327,  65294,  65258,  65220,  65179,  65136,  65091,
	 65043,  64992,  64939,  64884,  64826,  64766,  64703,  64638,  64571,  64501,  64428,  64353,  64276,  64197,  64115,  64030,  63943,  63854,  63762,  63668,
	 63571,  63473,  63371,  63268,  63162,  63053,  62942,  62829,  62714,  62596,  62475,  62353,  62228,  62100,  61971,  61839,  61705,  61568,  61429,  61288,
	 61144,  60998,  60850,  60700,  60547,  60392,  60235,  60075,  59913,  59749,  59583,  59414,  59243,  59070,  58895,  58718,  58538,  58356,  58172,  57986,
	 57797,  57606,  57414,  57219,  57022,  56822,  56621,  56417,  56212,  56004,  55794,  55582,  55368,  55152,  54933,  54713,  54491,  54266,  54040,  53811,
	 53581,  53348,  53114,  52877,  52639,  52398,  52155,  51911,  51665,  51416,  51166,  50914,  50660,  50403,  50146,  49886,  49624,  49360,  49095,  48828,
	 48558,  48288,  48015,  47740,  47464,  47186,  46906,  46624,  46340,  46055,  45768,  45480,  45189,  44897,  44603,  44308,  44011,  43712,  43412,  43110,
	 42806,  42501,  42194,  41885,  41575,  41263,  40950,  40636,  40319,  40002,  39682,  39362,  39039,  38716,  38390,  38064,  37736,  37406,  37075,  36743,
	 36409,  36074,  35738,  35400,  35061,  34721,  34379,  34036,  33692,  33346,  32999,  32651,  32302,  31952,  31600,  31247,  30893,  30538,  30181,  29824,
	 29465,  29105,  28745,  28383,  28020,  27656,  27291,  26925,  26557,  26189,  25820,  25450,  25079,  24707,  24334,  23960,  23586,  23210,  22833,  22456,
	 22078,  21699,  21319,  20938,  20557,  20175,  19792,  19408,  19024,  18638,  18253,  17866,  17479,  17091,  16702,  16313,  15923,  15533,  15142,  14751,
	 14359,  13966,  13573,  13179,  12785,  12390,  11995,  11600,  11204,  10807,  10410,  10013,   9616,   9218,   8819,   8421,   8022,   7623,   7223,   6823,
	  6423,   6023,   5622,   5222,   4821,   4420,   4018,   3617,   3215,   2814,   2412,   2010,   1608,   1206,    804,    402, 	 0,   -403,   -805,  -1207,
	 -1609,  -2011,  -2413,  -2815,  -3216,  -3618,  -4019,  -4421,  -4822,  -5223,  -5623,  -6024,  -6424,  -6824,  -7224,  -7624,  -8023,  -8422,  -8820,  -9219,
	 -9617, -10014, -10411, -10808, -11205, -11601, -11996, -12391, -12786, -13180, -13574, -13967, -14360, -14752, -15143, -15534, -15924, -16314, -16703, -17092,
	-17480, -17867, -18254, -18639, -19025, -19409, -19793, -20176, -20558, -20939, -21320, -21700, -22079, -22457, -22834, -23211, -23587, -23961, -24335, -24708,
	-25080, -25451, -25821, -26190, -26558, -26926, -27292, -27657, -28021, -28384, -28746, -29106, -29466, -29825, -30182, -30539, -30894, -31248, -31601, -31953,
	-32303, -32652, -33000, -33347, -33693, -34037, -34380, -34722, -35062, -35401, -35739, -36075, -36410, -36744, -37076, -37407, -37737, -38065, -38391, -38717,
	-39040, -39363, -39683, -40003, -40320, -40637, -40951, -41264, -41576, -41886, -42195, -42502, -42807, -43111, -43413, -43713, -44012, -44309, -44604, -44898,
	-45190, -45481, -45769, -46056, -46341, -46625, -46907, -47187, -47465, -47741, -48016, -48289, -48559, -48829, -49096, -49361, -49625, -49887, -50147, -50404,
	-50661, -50915, -51167, -51417, -51666, -51912, -52156, -52399, -52640, -52878, -53115, -53349, -53582, -53812, -54041, -54267, -54492, -54714, -54934, -55153,
	-55369, -55583, -55795, -56005, -56213, -56418, -56622, -56823, -57023, -57220, -57415, -57607, -57798, -57987, -58173, -58357, -58539, -58719, -58896, -59071,
	-59244, -59415, -59584, -59750, -59914, -60076, -60236, -60393, -60548, -60701, -60851, -60999, -61145, -61289, -61430, -61569, -61706, -61840, -61972, -62101,
	-62229, -62354, -62476, -62597, -62715, -62830, -62943, -63054, -63163, -63269, -63372, -63474, -63572, -63669, -63763, -63855, -63944, -64031, -64116, -64198,
	-64277, -64354, -64429, -64502, -64572, -64639, -64704, -64767, -64827, -64885, -64940, -64993, -65044, -65092, -65137, -65180, -65221, -65259, -65295, -65328,
	-65359, -65387, -65413, -65437, -65458, -65476, -65492, -65506, -65517, -65525, -65532, -65535, -65536, -65535, -65532, -65525, -65517, -65506, -65492, -65476,
	-65458, -65437, -65413, -65387, -65359, -65328, -65295, -65259, -65221, -65180, -65137, -65092, -65044, -64993, -64940, -64885, -64827, -64767, -64704, -64639,
	-64572, -64502, -64429, -64354, -64277, -64198, -64116, -64031, -63944, -63855, -63763, -63669, -63572, -63474, -63372, -63269, -63163, -63054, -62943, -62830,
	-62715, -62597, -62476, -62354, -62229, -62101, -61972, -61840, -61706, -61569, -61430, -61289, -61145, -60999, -60851, -60701, -60548, -60393, -60236, -60076,
	-59914, -59750, -59584, -59415, -59244, -59071, -58896, -58719, -58539, -58357, -58173, -57987, -57798, -57607, -57415, -57220, -57023, -56823, -56622, -56418,
	-56213, -56005, -55795, -55583, -55369, -55153, -54934, -54714, -54492, -54267, -54041, -53812, -53582, -53349, -53115, -52878, -52640, -52399, -52156, -51912,
	-51666, -51417, -51167, -50915, -50661, -50404, -50147, -49887, -49625, -49361, -49096, -48829, -48559, -48289, -48016, -47741, -47465, -47187, -46907, -46625,
	-46341, -46056, -45769, -45481, -45190, -44898, -44604, -44309, -44012, -43713, -43413, -43111, -42807, -42502, -42195, -41886, -41576, -41264, -40951, -40637,
	-40320, -40003, -39683, -39363, -39040, -38717, -38391, -38065, -37737, -37407, -37076, -36744, -36410, -36075, -35739, -35401, -35062, -34722, -34380, -34037,
	-33693, -33347, -33000, -32652, -32303, -31953, -31601, -31248, -30894, -30539, -30182, -29825, -29466, -29106, -28746, -28384, -28021, -27657, -27292, -26926,
	-26558, -26190, -25821, -25451, -25080, -24708, -24335, -23961, -23587, -23211, -22834, -22457, -22079, -21700, -21320, -20939, -20558, -20176, -19793, -19409,
	-19025, -18639, -18254, -17867, -17480, -17092, -16703, -16314, -15924, -15534, -15143, -14752, -14360, -13967, -13574, -13180, -12786, -12391, -11996, -11601,
	-11205, -10808, -10411, -10014,  -9617,  -9219,  -8820,  -8422,  -8023,  -7624,  -7224,  -6824,  -6424,  -6024,  -5623,  -5223,  -4822,  -4421,  -4019,  -3618,
	 -3216,  -2815,  -2413,  -2011,  -1609,  -1207,   -805,   -403, 	-1,    402,    804,   1206,   1608,   2010,   2412,   2814,   3215,   3617,   4018,   4420,
	  4821,   5222,   5622,   6023,   6423,   6823,   7223,   7623,   8022,   8421,   8819,   9218,   9616,  10013,  10410,  10807,  11204,  11600,  11995,  12390,
	 12785,  13179,  13573,  13966,  14359,  14751,  15142,  15533,  15923,  16313,  16702,  17091,  17479,  17866,  18253,  18638,  19024,  19408,  19792,  20175,
	 20557,  20938,  21319,  21699,  22078,  22456,  22833,  23210,  23586,  23960,  24334,  24707,  25079,  25450,  25820,  26189,  26557,  26925,  27291,  27656,
	 28020,  28383,  28745,  29105,  29465,  29824,  30181,  30538,  30893,  31247,  31600,  31952,  32302,  32651,  32999,  33346,  33692,  34036,  34379,  34721,
	 35061,  35400,  35738,  36074,  36409,  36743,  37075,  37406,  37736,  38064,  38390,  38716,  39039,  39362,  39682,  40002,  40319,  40636,  40950,  41263,
	 41575,  41885,  42194,  42501,  42806,  43110,  43412,  43712,  44011,  44308,  44603,  44897,  45189,  45480,  45768,  46055,  46340,  46624,  46906,  47186,
	 47464,  47740,  48015,  48288,  48558,  48828,  49095,  49360,  49624,  49886,  50146,  50403,  50660,  50914,  51166,  51416,  51665,  51911,  52155,  52398,
	 52639,  52877,  53114,  53348,  53581,  53811,  54040,  54266,  54491,  54713,  54933,  55152,  55368,  55582,  55794,  56004,  56212,  56417,  56621,  56822,
	 57022,  57219,  57414,  57606,  57797,  57986,  58172,  58356,  58538,  58718,  58895,  59070,  59243,  59414,  59583,  59749,  59913,  60075,  60235,  60392,
	 60547,  60700,  60850,  60998,  61144,  61288,  61429,  61568,  61705,  61839,  61971,  62100,  62228,  62353,  62475,  62596,  62714,  62829,  62942,  63053,
	 63162,  63268,  63371,  63473,  63571,  63668,  63762,  63854,  63943,  64030,  64115,  64197,  64276,  64353,  64428,  64501,  64571,  64638,  64703,  64766,
	 64826,  64884,  64939,  64992,  65043,  65091,  65136,  65179,  65220,  65258,  65294,  65327,  65358,  65386,  65412,  65436,  65457,  65475,  65491,  65505,
	 65516,  65524,  65531,  65534
};

static uint64_t ams_isqrt(uint64_t x)
{
	register uint64_t result, tmp;

	result = 0;
	tmp = (1LL << 62);  // second-to-top bit set
	while (tmp > x) {
		tmp >>= 2;
	}
	while (tmp != 0) {
		if (x >= (result + tmp)) {
			x -= result + tmp;
			result += 2 * tmp;  // <-- faster than 2 * one
		}
		result >>= 1;
		tmp >>= 2;
	}
	return result;
}

void ams_get_magnitude(int64_t* data_r, int64_t* data_i, int32_t* buffer, int size)
	// data : 41~50 bits
{   //data must be twice as long as size
	int i;

	for (i = 0; i < size; ++i) {
		//sqrt(real^2 + imaginary^2)
		uint64_t square = 0;
		int64_t t_r = data_r[i] >> 4;
		int64_t t_i = data_i[i] >> 4;
		square = ((t_r * t_r) >> 7) + ((t_i * t_i) >> 7);
		buffer[i] = (int32_t)ams_isqrt(square); //26 bit
	}
}

// n is a power of 2
int _log2n(int n)
{
	//int len = sizeof(int) * 8;
	int len = 32, i;
	for (i = 0; i < len; i++)
	{
		if ((n&1) == 1)
			return i;
		else
			n >>= 1;
	}
	return -1;
}

// Utility function for reversing the bits
// of given index x
unsigned int bitReverse(unsigned int x, int log2n)
{
	int n = 0, i;
	for (i = 0; i < log2n; i++)
	{
		n <<= 1;
		n |= (x & 1);
		x >>= 1;
	}
	return n;
}

void _fft(int32_t* a_r, int32_t* a_i, int64_t* A_r, int64_t* A_i, int n)
{
	int log2n = _log2n(n), s, k, j;
	unsigned int i;
	// bit reversal of the given array
	for (i = 0; i < n; ++i) {
		int rev = bitReverse(i, log2n);
		A_r[i] = ((int64_t)a_r[rev]) << 16; // 16+16=32   Q16
		A_i[i] = ((int64_t)a_i[rev]) << 16; // 16+16=32   Q16
	}
	for (s = 1; s <= log2n; s++) {
		int m = 1 << s;
		int m_2 = m >> 1;
		int64_t wm_r = (int64_t)cos[1024 >> s];    //wm_r = cos(2 pi / m)    Q16
		int64_t wm_i = -(int64_t)sin[1024 >> s];   //wm_i = -sin(2 pi / m)    Q16

		for (k = 0; k < n; k += m)
		{
			int64_t w_r = 1LL << 16;  // Q16 => 65536
			int64_t w_i = 0;          // Q16

			for (j = 0; j < m_2; j++)
			{
				int i1 = k + j;
				int i2 = i1 + m_2;
				int64_t t_r = w_r * A_r[i2] - w_i * A_i[i2];   // Q16*Q16,  16+32=48~55
				int64_t t_i = w_r * A_i[i2] + w_i * A_r[i2];   // Q16*Q16,  16+32=48~55
				int64_t u_r = A_r[i1];    // Q16,  32
				int64_t u_i = A_i[i1];    // Q16
				int64_t w2_r = w_r * wm_r - w_i * wm_i;   // Q16*Q16,  16+16=32
				int64_t w2_i = w_r * wm_i + w_i * wm_r;   // Q16*Q16
				t_r >>= 16;    // Q16,  32~49
				t_i >>= 16;    // Q16
				A_r[i1] = u_r + t_r;      // Q16,  48~55
				A_i[i1] = u_i + t_i;
				A_r[i2] = u_r - t_r;
				A_i[i2] = u_i - t_i;
				w_r = w2_r >> 16;    // Q16
				w_i = w2_i >> 16;    // Q16
			}
		}
	}
}

int32_t buf_r[AMS_FFT_SIZE] = {0};
int32_t buf_i[AMS_FFT_SIZE] = {0};
int64_t out_r[AMS_FFT_SIZE] = {0};
int64_t out_i[AMS_FFT_SIZE] = {0};

void FFT(int32_t* data, enum fft_size size)
	// buf_r <= 16bits data
{
	static int log_cnt = 0;
	int i, hamming_step = 2048/size;

	if (size > AMS_FFT_SIZE || (size & 0x7f) != 0) { //FFT size : multiply of 128
		//@TODO add return codes so we know it failed
		return;
	}

	for (i = 0; i < size; i++) {
#ifndef USE_GET_FIFO_ALS
		if (!tsl2510_data->saturation && data[i] >= 0x3FFF) {
			ALS_info("DEBUG_FLICKER saturation");
			tsl2510_data->saturation = true;
		}
#endif

		buf_r[i] = ((int64_t)data[i]*(int64_t)hamming[i * hamming_step]) >> 10;        // 16+16-10=22   Q6
		if (log_cnt > 30)
			ALS_info("DEBUG_FLICKER data[%d] => %d buf[%d] => %lld", i, data[i], i, buf_r[i]);
	}
	_fft(buf_r, buf_i, out_r, out_i, size);
	for (i = 0; i < AMS_FFT_SIZE; i++) {
		out_r[i] >>= 6;
		out_i[i] >>= 6;
	}
	ams_get_magnitude(out_r, out_i, data, size);
	if (log_cnt > 30)
		log_cnt = 0;
	else
		log_cnt++;
}

// AMS FFT END

static const struct of_device_id tsl2510_match_table[] = {
	{.compatible = "ams,tsl2510",},
	{},
};

static int ams_deviceGetFlickerData(ams_deviceCtx_t *ctx, void *exportData)
{
	ams_flicker_ctx_t *flickerCtx = (ams_flicker_ctx_t *)&ctx->flickerCtx;
	memcpy((uint16_t*)&exportData[0], &flickerCtx->flicker_data[0], sizeof(uint16_t)*AMS_FFT_SIZE);
	return AMS_FFT_SIZE;
}

static long tsl2510_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
{
	void __user *argp = (void __user *)arg;
	int ret = 0;
	//int i = 0;
	int data_length = 0;
	struct tsl2510_device_data *data = container_of(file->private_data, struct tsl2510_device_data, miscdev);

	ALS_dbg("%s - ioctl start, %d\n", __func__, cmd);
	mutex_lock(&data->flickerdatalock);

	switch (cmd) {
		case TSL2510_IOCTL_READ_FLICKER:

			data_length = ams_deviceGetFlickerData(data->deviceCtx, (void*)&data->flicker_data[0]);
			ALS_dbg("%s - TSL2510_IOCTL_READ_FLICKER = %d\n", __func__, data->flicker_data[0]);

			//for(i=0 ; i < data_length; i++)
			//    ALS_dbg("%s flicker_data[%d] = %d\n", __func__, i,data->flicker_data[i]);
			if(data_length != 0)
			{
				ret = copy_to_user(argp,
						data->flicker_data,
						sizeof(int16_t)*data_length);
				if (unlikely(ret))
					goto ioctl_error;

			}

			break;

		default:
			ALS_err("%s - invalid cmd\n", __func__);
			break;
	}

	mutex_unlock(&data->flickerdatalock);
	return ret;

ioctl_error:
	mutex_unlock(&data->flickerdatalock);
	ALS_err("%s - read flicker data err(%d)\n", __func__, ret);
	return -ret;
}

static const struct file_operations tsl2510_fops = {
	.owner = THIS_MODULE,
	.open = nonseekable_open,
	.unlocked_ioctl = tsl2510_ioctl,
};

static uint8_t alsGainToReg(uint32_t x)
{
	int i;

	for (i = sizeof(alsGain_conversion) / sizeof(uint32_t) - 1; i != 0; i--) {
		if (x >= alsGain_conversion[i])
			break;
	}
	return (i << 0);
}

static uint16_t alsSampleTimeUsToReg(uint32_t x)
{
	uint16_t regValue;

	regValue = (x * 1000) / AMS_USEC_PER_TICK;

	return regValue;
}

static uint16_t alsTimeUsToReg(uint32_t x, AMS_PORT_portHndl *portHndl)
{
	uint16_t regValue;
	uint16_t sample_time;

	if (portHndl) {
		ams_getWord(portHndl, DEVREG_SAMPLE_TIME0, &regValue);
		ALS_dbg("===== %s regValue =%x =====\n", __func__, regValue);
		regValue = regValue & MASK_ALS_SAMPLE_TIME;

		sample_time = ((regValue + 1) * AMS_USEC_PER_TICK) / 1000;

		ALS_dbg("===== %s Sample time =%d =====\n", __func__, sample_time);
	} else {
		sample_time = 250; // default 250usec
	}

	regValue = (x / sample_time) - 1;

	return regValue;
}

static void tsl2510_debug_var(struct tsl2510_device_data *data)
{
	ALS_dbg("===== %s =====\n", __func__);
	ALS_dbg("%s client %p slave_addr 0x%x\n", __func__,
			data->client, data->client->addr);
	ALS_dbg("%s dev %p\n", __func__, data->dev);
	ALS_dbg("%s als_input_dev %p\n", __func__, data->als_input_dev);
	ALS_dbg("%s als_pinctrl %p\n", __func__, data->als_pinctrl);
	ALS_dbg("%s pins_sleep %p\n", __func__, data->pins_sleep);
	ALS_dbg("%s pins_active %p\n", __func__, data->pins_active);
	ALS_dbg("%s als_enabled %d\n", __func__, data->enabled);
	ALS_dbg("%s als_sampling_rate %d\n", __func__, data->sampling_period_ns);
	ALS_dbg("%s regulator_state %d\n", __func__, data->regulator_state);
	ALS_dbg("%s als_int %d\n", __func__, data->pin_als_int);
	ALS_dbg("%s als_irq %d\n", __func__, data->dev_irq);
	ALS_dbg("%s irq_state %d\n", __func__, data->irq_state);
	ALS_dbg("===== %s =====\n", __func__);
}



static int tsl2510_write_reg_bulk(struct tsl2510_device_data *device, u8 reg_addr, u8* data, u8 length)
{
	int err = -1;
	int tries = 0;
	int num = 1;

	u8* buffer = NULL;

	struct i2c_msg msgs[] = {
		{
			.addr = device->client->addr,
			.flags = device->client->flags & I2C_M_TEN,
			.len = (length+1),
			.buf = buffer,
		},
	};

	buffer = devm_kzalloc(&device->client->dev, (length+1), GFP_KERNEL); // address + data
	if (buffer == NULL) {
		ALS_err("%s - couldn't allocate buffer data memory\n", __func__);
		return -ENOMEM;
	}

	buffer[0] = reg_addr;
	memcpy(&buffer[1] , &data[0], length);

	if (!device->pm_state || device->regulator_state == 0) {
		ALS_err("%s - write error, pm suspend or reg_state %d\n",
				__func__, device->regulator_state);
		err = -EFAULT;
		return err;
	}

	mutex_lock(&device->suspendlock);

	do {
		err = i2c_transfer(device->client->adapter, msgs, num);
		if (err != num)
			msleep_interruptible(AMSDRIVER_I2C_RETRY_DELAY);
		if (err < 0)
			ALS_err("%s - i2c_transfer error = %d\n", __func__, err);
	} while ((err != num) && (++tries < AMSDRIVER_I2C_MAX_RETRIES));

	mutex_unlock(&device->suspendlock);

	if (err != num) {
		ALS_err("%s -write transfer error:%d\n", __func__, err);
		err = -EIO;
		device->i2c_err_cnt++;
		return err;
	}
	//devm_kfree(&device->client->dev, buffer);
	//buffer = 0;

	return 0;
}

static int tsl2510_write_reg(struct tsl2510_device_data *device,
		u8 reg_addr, u8 data)
{
	int err = -1;
	int tries = 0;
	int num = 1;
	u8 buffer[2] = { reg_addr, data };
	struct i2c_msg msgs[] = {
		{
			.addr = device->client->addr,
			.flags = device->client->flags & I2C_M_TEN,
			.len = 2,
			.buf = buffer,
		},
	};

	if (!device->pm_state || device->regulator_state == 0) {
		ALS_err("%s - write error, pm suspend or reg_state %d\n",
				__func__, device->regulator_state);
		err = -EFAULT;
		return err;
	}

	mutex_lock(&device->suspendlock);

	do {
		err = i2c_transfer(device->client->adapter, msgs, num);
		if (err != num)
			msleep_interruptible(AMSDRIVER_I2C_RETRY_DELAY);
		if (err < 0)
			ALS_err("%s - i2c_transfer error = %d\n", __func__, err);
	} while ((err != num) && (++tries < AMSDRIVER_I2C_MAX_RETRIES));

	mutex_unlock(&device->suspendlock);

	if (err != num) {
		ALS_err("%s -write transfer error:%d\n", __func__, err);
		err = -EIO;
		device->i2c_err_cnt++;
		return err;
	}

	return 0;
}

static int tsl2510_read_reg(struct tsl2510_device_data *device,
		u8 reg_addr, u8 *buffer, int length)
{
	int err = -1;
	int tries = 0; /* # of attempts to read the device */
	int num = 2;
	struct i2c_msg msgs[] = {
		{
			.addr = device->client->addr,
			.flags = device->client->flags & I2C_M_TEN,
			.len = 1,
			.buf = buffer,
		},
		{
			.addr = device->client->addr,
			.flags = (device->client->flags & I2C_M_TEN) | I2C_M_RD,
			.len = length,
			.buf = buffer,
		},
	};

	if (!device->pm_state || device->regulator_state == 0) {
		ALS_err("%s - read error, pm suspend or reg_state %d\n",
				__func__, device->regulator_state);
		err = -EFAULT;
		return err;
	}

	mutex_lock(&device->suspendlock);

	do {
		buffer[0] = reg_addr;
		err = i2c_transfer(device->client->adapter, msgs, num);
		if (err != num)
			msleep_interruptible(AMSDRIVER_I2C_RETRY_DELAY);
		if (err < 0)
			ALS_err("%s - i2c_transfer error = %d\n", __func__, err);
	} while ((err != num) && (++tries < AMSDRIVER_I2C_MAX_RETRIES));

	mutex_unlock(&device->suspendlock);

	if (err != num) {
		ALS_err("%s -read transfer error:%d\n", __func__, err);
		err = -EIO;
		device->i2c_err_cnt++;
	} else
		err = 0;

	return err;
}

static int ams_getByte(AMS_PORT_portHndl *portHndl, ams_deviceRegister_t reg, uint8_t *readData)
{
	struct tsl2510_device_data *data = i2c_get_clientdata(portHndl);
	int err = 0;
	uint8_t length = 1;

	/* Sanity check input param */
	if (reg >= DEVREG_REG_MAX)
		return 0;

	err = tsl2510_read_reg(data, deviceRegisterDefinition[reg].address, readData, length);

	return err;
}

static int ams_setByte(AMS_PORT_portHndl *portHndl, ams_deviceRegister_t reg, uint8_t setData)
{
	struct tsl2510_device_data *data = i2c_get_clientdata(portHndl);
	int err = 0;

	/* Sanity check input param */
	if (reg >= DEVREG_REG_MAX)
		return 0;

	err = tsl2510_write_reg(data, deviceRegisterDefinition[reg].address, setData);

	return err;
}

static int ams_getBuf(AMS_PORT_portHndl *portHndl, ams_deviceRegister_t reg, uint8_t *readData, uint8_t length)
{
	struct tsl2510_device_data *data = i2c_get_clientdata(portHndl);
	int err = 0;

	/* Sanity check input param */
	if (reg >= DEVREG_REG_MAX)
		return 0;

	err = tsl2510_read_reg(data, deviceRegisterDefinition[reg].address, readData, length);

	return err;
}

int ams_setBuf(AMS_PORT_portHndl *portHndl, ams_deviceRegister_t reg, uint8_t *setData, uint8_t length)
{
	struct tsl2510_device_data *data = i2c_get_clientdata(portHndl);
	int err = 0;

	/* Sanity check input param */
	if (reg >= DEVREG_REG_MAX)
		return 0;

	err = tsl2510_write_reg_bulk(data, deviceRegisterDefinition[reg].address, setData, length);
	return err;
}

static int ams_getWord(AMS_PORT_portHndl *portHndl, ams_deviceRegister_t reg, uint16_t *readData)
{
	struct tsl2510_device_data *data = i2c_get_clientdata(portHndl);
	int err = 0;
	uint8_t length = sizeof(uint16_t);
	uint8_t buffer[sizeof(uint16_t)];

	/* Sanity check input param */
	if (reg >= DEVREG_REG_MAX)
		return 0;

	err = tsl2510_read_reg(data, deviceRegisterDefinition[reg].address, buffer, length);

	*readData = ((buffer[0] << AMS_ENDIAN_1) + (buffer[1] << AMS_ENDIAN_2));

	return err;
}

static int ams_setWord(AMS_PORT_portHndl *portHndl, ams_deviceRegister_t reg, uint16_t setData)
{
	struct tsl2510_device_data *data = i2c_get_clientdata(portHndl);
	int err = 0;
	uint8_t buffer[sizeof(uint16_t)];

	/* Sanity check input param */
	if (reg >= (DEVREG_REG_MAX - 1))
		return 0;

	buffer[0] = ((setData >> AMS_ENDIAN_1) & 0xff);
	buffer[1] = ((setData >> AMS_ENDIAN_2) & 0xff);

	err = tsl2510_write_reg(data, deviceRegisterDefinition[reg].address, buffer[0]);
	err = tsl2510_write_reg(data, deviceRegisterDefinition[reg + 1].address, buffer[1]);

	return err;
}

int ams_getField(AMS_PORT_portHndl *portHndl, ams_deviceRegister_t reg, uint8_t *setData, ams_regMask_t mask)
{
	struct tsl2510_device_data *data = i2c_get_clientdata(portHndl);
	int err = 0;
	uint8_t length = 1;

	/* Sanity check input param */
	if (reg >= DEVREG_REG_MAX)
		return 0;

	err = tsl2510_read_reg(data, deviceRegisterDefinition[reg].address, setData, length);

	*setData &= mask;

	return err;
}

static int ams_setField(AMS_PORT_portHndl *portHndl, ams_deviceRegister_t reg, uint8_t setData, ams_regMask_t mask)
{
	struct tsl2510_device_data *data = i2c_get_clientdata(portHndl);
	int err = 1;
	uint8_t length = 1;
	uint8_t original_data;
	uint8_t new_data;

	/* Sanity check input param */
	if (reg >= DEVREG_REG_MAX)
		return 0;

	err = tsl2510_read_reg(data, deviceRegisterDefinition[reg].address, &original_data, length);
	if (err < 0)
		return err;

	new_data = original_data & ~mask;
	new_data |= (setData & mask);

	if (new_data != original_data)
		err = tsl2510_write_reg(data, deviceRegisterDefinition[reg].address, new_data);

	return err;
}

static void als_getDefaultCalibrationData(ams_ccb_als_calibration_t *data)
{
	if (data != NULL) {
		data->Time_base = AMS_ALS_TIMEBASE;
		data->thresholdLow = AMS_ALS_THRESHOLD_LOW;
		data->thresholdHigh = AMS_ALS_THRESHOLD_HIGH;
		data->calibrationFactor = 1000;
	}
}

static int amsAlg_als_processData(amsAlsContext_t *ctx, amsAlsDataSet_t *inputData)
{
	int64_t lux = 0;
	uint32_t CWRatio = 0;
	uint32_t tempWb = 0, tempClear = 0;

	ALS_info("%s - raw: %d, %d\n", __func__, inputData->datasetArray->clearADC, inputData->datasetArray->widebandADC);

	if (inputData->status & ALS_STATUS_RDY) {
		ctx->results.rawClear = inputData->datasetArray->clearADC;
		ctx->results.rawWideband = inputData->datasetArray->widebandADC;
		ctx->results.irrClear = inputData->datasetArray->clearADC;
		ctx->results.irrWideband = inputData->datasetArray->widebandADC;

		if (!tsl2510_data->saturation) {
			if (ctx->results.irrWideband < ctx->results.irrClear) {
				ctx->results.IR = 0;
			} else {
				tempWb = (WIDEBAND_CONST * AMS_ALS_FACTOR) * ctx->results.irrWideband;
				tempClear = (CLEAR_CONST * AMS_ALS_FACTOR) * ctx->results.irrClear;

				if (tempWb < tempClear) {
					ctx->results.IR = 0;
				} else {
					ctx->results.IR = (tempWb - tempClear) / AMS_ALS_FACTOR;
				}
			}
		} else {
			ctx->results.IR = 0;
		}
	}

	CWRatio = (ctx->results.rawClear /ctx->results.rawWideband);
	ALS_info("%s - IRR Clear : %d, IRR WIDEBAND :%d, CWRatio :%d\n", __func__, ctx->results.irrClear, ctx->results.irrWideband,CWRatio);
	ALS_info("%s - RAW Clear : %d, RAW WIDEBAND :%d\n", __func__, ctx->results.rawClear, ctx->results.rawWideband);
	ALS_info("%s - calculated IR :%d\n", __func__, ctx->results.IR);

	if(CWRatio > 15) {
		CWRatio = 15;
	}

	if(ctx->results.rawWideband  == 0) {
		CWRatio = 15;
	}

	if(CWRatio ==0) { // Normal lux
		lux = ctx->results.rawClear * (((coef_a * ctx->results.rawClear) /ctx->results.rawWideband) + coef_b);
	} else { //CWRatio data have over 15
		lux = ctx->results.rawClear * ((coef_a * CWRatio) + coef_b);
	}

	lux = lux >> 10; //devide 1024
	ALS_info("%s - Lux :%llu\n", __func__, lux );

	return 0;
}

static bool ams_getMode(ams_deviceCtx_t *ctx, ams_mode_t *mode)
{
	*mode = ctx->mode;

	return false;
}

uint32_t ams_getResult(ams_deviceCtx_t *ctx)
{
	uint32_t returnValue = ctx->updateAvailable;

	ctx->updateAvailable = 0;

	return returnValue;
}

static int amsAlg_als_initAlg(amsAlsContext_t *ctx, amsAlsInitData_t *initData);
static int amsAlg_als_getAlgInfo(amsAlsAlgoInfo_t *info);
static int amsAlg_als_processData(amsAlsContext_t *ctx, amsAlsDataSet_t *inputData);
//static int ams_smux_set(ams_deviceCtx_t *ctx);

static int ccb_alsInit(void *dcbCtx, ams_ccb_als_init_t *initData)
{
	ams_deviceCtx_t *ctx = (ams_deviceCtx_t *)dcbCtx;
	ams_ccb_als_ctx_t *ccbCtx = &ctx->ccbAlsCtx;
	amsAlsInitData_t initAlsData;
	amsAlsAlgoInfo_t infoAls;
	int ret = 0;

	ALS_dbg("%s - ccb_alsInit\n", __func__);

	if (initData)
		memcpy(&ccbCtx->initData, initData, sizeof(ams_ccb_als_init_t));
	else
		ccbCtx->initData.calibrate = false;

	initAlsData.adaptive = false;
	initAlsData.irRejection = false;
	initAlsData.gain = ccbCtx->initData.configData.gain;
	initAlsData.time_us = ccbCtx->initData.configData.uSecTime;
	initAlsData.calibration.adcMaxCount = ccbCtx->initData.calibrationData.adcMaxCount;
	initAlsData.calibration.calibrationFactor = ccbCtx->initData.calibrationData.calibrationFactor;
	initAlsData.calibration.Time_base = ccbCtx->initData.calibrationData.Time_base;
	initAlsData.calibration.thresholdLow = ccbCtx->initData.calibrationData.thresholdLow;
	initAlsData.calibration.thresholdHigh = ccbCtx->initData.calibrationData.thresholdHigh;
	//initAlsData.calibration.calibrationFactor = ccbCtx->initData.calibrationData.calibrationFactor;
	amsAlg_als_getAlgInfo(&infoAls);

	amsAlg_als_initAlg(&ccbCtx->ctxAlgAls, &initAlsData);

	AMS_SET_ALS_TIME(ccbCtx->initData.configData.uSecTime, ret);
	if (ret < 0) {
		ALS_err("%s - failed to AMS_SET_ALS_TIME\n", __func__);
		return ret;
	}

	if( ctx->sensor_mode == 1) { //ambient mode : als only
		AMS_SET_ALS_PERS(0x00, ret);
	} else { //camera mode : als + flicker
		AMS_SET_ALS_PERS(0x01, ret);
	}
	if (ret < 0) {
		ALS_err("%s - failed to AMS_SET_ALS_PERS\n", __func__);
		return ret;
	}
	ccbCtx->shadowAiltReg = 0x00ffffff;
	ccbCtx->shadowAihtReg = 0;

	AMS_SET_ALS_THRS_LOW(ccbCtx->shadowAiltReg, ret);
	if (ret < 0) {
		ALS_err("%s - failed to AMS_SET_ALS_THRS_LOW\n", __func__);
		return ret;
	}

	AMS_SET_ALS_THRS_HIGH(ccbCtx->shadowAihtReg, ret);
	if (ret < 0) {
		ALS_err("%s - failed to AMS_SET_ALS_THRS_HIGH\n", __func__);
		return ret;
	}

	AMS_SET_ALS_GAIN0(ctx->ccbAlsCtx.initData.configData.gain, ret);
	if (ret < 0) {
		ALS_err("%s - failed to AMS_SET_ALS_GAIN\n", __func__);
		return ret;
	}

	AMS_SET_ALS_GAIN1(ctx->ccbAlsCtx.initData.configData.gain, ret);
	if (ret < 0) {
		ALS_err("%s - failed to AMS_SET_ALS_GAIN\n", __func__);
		return ret;
	}

	if( ctx->sensor_mode == 0) { //camera mode
		AMS_SET_ALS_AINT_DIRECT(HIGH, ret);
		if (ret < 0) {
			ALS_err("%s - failed to AMS_SET_ALS_AINT_DIRECT\n", __func__);
			return ret;
		}
	}
	ccbCtx->state = AMS_CCB_ALS_RGB;

	return ret;
}

static int AMS_SET_FIFO_MAP(ams_deviceCtx_t *ctx);
static int AMS_SET_FIFO_MAP(ams_deviceCtx_t *ctx)
{
	int ret = 0;
	ret = ams_setField(ctx->portHndl, DEVREG_MOD_FIFO_DATA_CFG0, LOW, MASK_MOD_ALS_FIFO_DATA0_WRITE_ENABLE);

	if (ret < 0) {
		ALS_err("%s - failed to MASK_MOD_ALS_FIFO_DATA0_WRITE_ENABLE\n", __func__);
		return ret;
	}
#if 0
	ret = ams_setField(ctx->portHndl, DEVREG_MOD_FIFO_DATA_CFG0, HIGH, MASK_MOD_FD_FIFO_DATA0_COMPRESSION_ENABLE);

	if (ret < 0) {
		ALS_err("%s - failed to MASK_MOD_FD_FIFO_DATA0_COMPRESSION_ENABLE\n", __func__);
		return ret;
	}
#endif

	ret = ams_setField(ctx->portHndl, DEVREG_MOD_FIFO_DATA_CFG1, LOW, MASK_MOD_ALS_FIFO_DATA1_WRITE_ENABLE);

	if (ret < 0) {
		ALS_err("%s - failed to MASK_MOD_ALS_FIFO_DATA1_WRITE_ENABLE\n", __func__);
		return ret;
	}

	ret = ams_setField(ctx->portHndl, DEVREG_MOD_FIFO_DATA_CFG2, LOW, MASK_MOD_ALS_FIFO_DATA2_WRITE_ENABLE);

	if (ret < 0) {
		ALS_err("%s - failed to MASK_MOD_ALS_FIFO_DATA2_WRITE_ENABLE\n", __func__);
		return ret;
	}


	return ret;
}

static void tsl2510_sequencer_init(ams_deviceCtx_t *ctx)
{
	int ret = 0;
	ALS_dbg("%s \n",__func__) ;
	/* Assign ALS to sequencer step 0 */
	ret = ams_setField(ctx->portHndl,
			DEVREG_MEAS_SEQR_ALS_FD_1,
			0x01,
			TSL2510_MASK_MEASUREMENT_SEQUENCER_ALS_PATTERN );
	if (ret < 0) {
		ALS_err("%s - failed to set SEQR_ALS_FD_1",__func__);
	}


	/* Assign Flicker to sequencer step 1 */
	/* Assign modulator 0 to flicker */
	ret = ams_setField(ctx->portHndl,
			DEVREG_MEAS_SEQR_FD_0,
			0x01,
			TSL2510_MASK_MEASUREMENT_SEQUENCER_MOD0_FD_PATTERN );
	if (ret < 0) {
		ALS_err("%s - failed to set SEQR_FD_0",__func__);
	}

	/* Assign modulator 1 to flicker */
	ret = ams_setField(ctx->portHndl,
			DEVREG_MEAS_SEQR_FD_0,
			0x10,
			TSL2510_MASK_MEASUREMENT_SEQUENCER_MOD1_FD_PATTERN );
	if (ret < 0) {
		ALS_err("%s - failed to set SEQR_FD_0",__func__);
	}
}

static void tsl2510_fifo_format_init(ams_deviceCtx_t *ctx)
{
	int ret = 0;
	/* Enable the end marker */
	ret = ams_setField(ctx->portHndl,
			DEVREG_MEAS_MODE1,
			HIGH,
			TSL2510_MASK_MOD_FIFO_FD_END_MARKER_WRITE_ENABLE);
	if (ret < 0) {
		ALS_err("%s - set FIFO_FD_END_MARKER_WRITE_ENABLE err");
	}

	ctx->has_fifo_fd_end_marker = true;

	/* Enable the gain */
	ret = ams_setField(ctx->portHndl,
			DEVREG_MEAS_MODE1,
			HIGH,
			TSL2510_MASK_MOD_FIFO_FD_GAIN_WRITE_ENABLE);

	if (ret < 0) {
		ALS_err("%s - set FIFO_FD_GAIN_WRITE_ENABLE err");
	}

	ctx->has_fifo_fd_gain = true;
	ALS_dbg("%s \n",__func__) ;
}

int ccb_flickerInit(void *dcbCtx/*, ams_ccb_als_init_t *initData*/)
{
	ams_deviceCtx_t *ctx = (ams_deviceCtx_t *)dcbCtx;
	ams_flicker_ctx_t *ccbCtx = (ams_flicker_ctx_t *)&ctx->flickerCtx;
	int ret = 0;


	//AMS_SET_FLICKER_NUM_SAMPLES(AMS_FLICKER_NUM_SAMPLES, ret);
	AMS_SET_FLICKER_NUM_SAMPLES(AMS_CLR_WIDE_FLICKER_NUM_SAMPLES, ret);
	ctx->flicker_num_samples = AMS_FLICKER_NUM_SAMPLES;
	if (ret < 0) {
		ALS_err("%s - failed to AMS_SET_FLICKER_NUM_SAMPLES\n", __func__);
		return ret;
	}

	AMS_SET_FIFO_THR(AMS_FLICKER_THR_LVL, ret);
	if (ret < 0) {
		ALS_err("%s - failed to AMS_FLICKER_THR_LVL\n", __func__);
		return ret;
	}

	ret = AMS_SET_FIFO_MAP(ctx);
	if (ret < 0) {
		ALS_err("%s - failed to AMS_SET_FIFO_MAP\n", __func__);
		return ret;
	}

	// Test
	//ret = ams_setByte(ctx->portHndl, DEVREG_MEAS_SEQR_FD_0, 0x10);
	//ret = ams_setByte(ctx->portHndl, DEVREG_MEAS_SEQR_ALS_FD_1, 0x00);

#if defined(CONFIG_AMS_ADD_MARKER_AND_GAIN_FIFO)
	AMS_FD_GAIN_TO_FIFO(ret);
	if (ret < 0) {
		ALS_err("%s - failed to AMS_FD_GAIN_TO_FIFO\n", __func__);
		return ret;
	}

	AMS_FD_END_MARKER_TO_FIFO(ret);
	if (ret < 0) {
		ALS_err("%s - failed to AMS_FD_END_MARKER_TO_FIFO\n", __func__);
		return ret;
	}
#endif
	tsl2510_sequencer_init(ctx);
	tsl2510_fifo_format_init(ctx);

	AMS_FIFO_CLEAR(ret);
	if (ret < 0) {
		ALS_err("%s - failed to FIFO CLEAR\n", __func__);
		return ret;
	}

	/* ams_setField(ctx->portHndl,
	   DEVREG_MEAS_MODE0,
	   HIGH,
	   0x20); */

	ams_setField(ctx->portHndl,
			DEVREG_SIEN,
			HIGH,
			0x02);

	ccbCtx->flicker_data_cnt = 0;
	ctx->hamming_status = true;
	memset(&ccbCtx->flicker_data[0], 0, (sizeof(uint16_t)*AMS_FFT_SIZE));
	ccbCtx->data_ready = 0;
	ccbCtx->gain = 0;
	ctx->fifo_mod0_gain = 0;
	ctx->fifo_mod1_gain = 0;

	return ret;
}

static void ccb_alsInfo(ams_ccb_als_info_t *infoData)
{
	if (infoData != NULL) {
		infoData->algName = "ALS";
		infoData->contextMemSize = sizeof(ams_ccb_als_ctx_t);
		infoData->scratchMemSize = 0;
		infoData->defaultCalibrationData.calibrationFactor = 1000;
		als_getDefaultCalibrationData(&infoData->defaultCalibrationData);
	}
}

static void ccb_alsSetConfig(void *dcbCtx, ams_ccb_als_config_t *configData)
{
	ams_ccb_als_ctx_t *ccbCtx = &((ams_deviceCtx_t *)dcbCtx)->ccbAlsCtx;

	ccbCtx->initData.configData.threshold = configData->threshold;
}

#define MAX_FIFO_LEN (2048)
#define SIGMA 3

//static uint16_t flicker_data[AMS_FFT_SIZE];
static uint8_t fifodata[MAX_FIFO_LEN];

#define NUM_SAMPLE_BYTES (AMS_FFT_SIZE*2)

static uint32_t calc_average(uint32_t *buffer, int count)
{
	uint32_t sum = 0;
	int i;
	uint16_t average = 0;

	if ((NULL != buffer) && (count > 0))
	{
		for (i = 0; i < count; i++)
		{
			sum += buffer[i];
		}
		average = sum / count;
	}
	return average;
}

#define TSL2510_THD_CLEAR      1800LL    /* 1.8 * 1000 */
#define TSL2510_THD_RATIO      3LL       /* 0.003 * 1000 */
#define TSL2510_GAIN_MAX       4096LL    /* 4096 */
#define TSL2510_THD_RATIO_AUTO 1000LL       /*  */
#define MAX_NUM_FLICKER_SAMPLES 2048LL
#define MAX_NUM_FLICKER_SAMPLE_BYTES (MAX_NUM_FLICKER_SAMPLES * 2)

static uint64_t calc_thd(uint16_t clear_avg_fifo, uint32_t clear_avg, uint32_t *fft_out_data)
{
	uint64_t threshold;
	uint64_t ratio_fixed;
	uint64_t ratio_final;

	if (clear_avg_fifo <= 1) {
		ratio_fixed = (TSL2510_THD_CLEAR * TSL2510_GAIN_MAX);
	} else {
		if (clear_avg)
			ratio_fixed = (TSL2510_THD_CLEAR << 7)/ clear_avg; // clear_avg left-shifted 7.
		else
			ratio_fixed = (TSL2510_THD_CLEAR << 7); // clear_avg left-shifted 7.
	}

	if ((TSL2510_THD_RATIO_AUTO) > ratio_fixed) {
		ratio_final = TSL2510_THD_RATIO_AUTO;
	} else {
		ratio_final = ratio_fixed;
	}

	threshold = ((uint64_t)fft_out_data[0] * ratio_final * TSL2510_THD_RATIO)/1000000;

	ALS_info("calc_thd threshold = %lld, fifoout[5] %lld, ratio_final %lld \n", threshold, fft_out_data[5], ratio_final);
	return threshold;
}

static uint8_t fifo_out_data[MAX_NUM_FLICKER_SAMPLE_BYTES];

static void parse_fifo_end_data(ams_deviceCtx_t * ctx )
{
	uint8_t fifo_end_data[7];
	int fifo_end_size = 0;
	int fifo_end_len;
	int gain_index = 0;
	int checksum_index = 0;
	uint16_t tmp;
	uint16_t kfifolen = 0;

	/* Calculate the number of end bytes */
	if (true == ctx ->has_fifo_fd_end_marker)
	{
		fifo_end_size += 3;
	}
	if (true == ctx ->has_fifo_fd_checksum)
	{
		fifo_end_size += 2;
	}
	if (true == ctx ->has_fifo_fd_gain)
	{
		fifo_end_size += 2;
	}

	/* Get the end bytes */
	memset(fifo_end_data, 0x0, sizeof(fifo_end_data));
	if ((kfifolen = kfifo_len(&ams_fifo)) >= fifo_end_size)
	{
		fifo_end_len = kfifo_out(&ams_fifo, fifo_end_data, fifo_end_size);
	}

	/* Determine the index for the various end data */
	if ((true == ctx ->has_fifo_fd_end_marker) &&
			(true == ctx ->has_fifo_fd_checksum) &&
			(true == ctx ->has_fifo_fd_gain))
	{
		checksum_index = 3;
		gain_index = 5;
	}
	else if ((true == ctx ->has_fifo_fd_end_marker) &&
			(false == ctx ->has_fifo_fd_checksum) &&
			(true == ctx ->has_fifo_fd_gain))
	{
		checksum_index = 0;
		gain_index = 3;
	}
	else if ((true == ctx ->has_fifo_fd_end_marker) &&
			(true == ctx ->has_fifo_fd_checksum) &&
			(false == ctx ->has_fifo_fd_gain))
	{
		checksum_index = 3;
		gain_index = 0;
	}
	else if ((false == ctx ->has_fifo_fd_end_marker) &&
			(true == ctx ->has_fifo_fd_checksum) &&
			(true == ctx ->has_fifo_fd_gain))
	{
		checksum_index = 0;
		gain_index = 2;
	}
	else if ((false == ctx ->has_fifo_fd_end_marker) &&
			(false == ctx ->has_fifo_fd_checksum) &&
			(true == ctx ->has_fifo_fd_gain))
	{
		checksum_index = 0;
		gain_index = 0;
	}
	else if ((false == ctx ->has_fifo_fd_end_marker) &&
			(true == ctx ->has_fifo_fd_checksum) &&
			(false == ctx ->has_fifo_fd_gain))
	{
		checksum_index = 0;
		gain_index = 0;
	}


	/* Parse the data */
	/* Data is written to the fifo in little endian, byte swap is required */
	if (true == ctx->has_fifo_fd_checksum)
	{
		tmp = ((fifo_end_data[checksum_index + 1] << 8) | fifo_end_data[checksum_index]);
		ctx->fifo_checksum = tmp;
	}

	if ((true == ctx->has_fifo_fd_gain) && ((fifo_end_data[0] == 0) && (fifo_end_data[1] == 0) && (fifo_end_data[2] == 0)) && (kfifolen >= fifo_end_size))
	{
		tmp = ((fifo_end_data[gain_index + 1] << 8) | fifo_end_data[gain_index]);

		ALS_info("%s: tmp: %04x ,  fifo_end_data[%d] =0x%x , fifo_end_data[+1] = 0x%x , \n", __func__, tmp,gain_index,fifo_end_data[gain_index],fifo_end_data[gain_index+1]);
		/* After the byte swap the gain data is like so
		 *
		 *                       Bits
		 *      15-12       11-8        7-4          3-0
		 *  -------------------------------------------------
		 * |  not used | mod2 gain | mod1 gain  | mod0 gain  |
		 *  -------------------------------------------------
		 *
		 */
		ctx->fifo_mod0_gain = tmp & 0xFF;
		//ctx->fifo_mod1_gain = (tmp >> 4) & 0x0F;
	}

}

ssize_t read_fifo(ams_deviceCtx_t * ctx , uint16_t *buf, int size)
{
	int len;
	int kfifo_Len;
	int i =0,j =0 ;
	uint16_t tmp =0;

	memset(fifo_out_data, 0x0, sizeof(fifo_out_data));

	kfifo_Len =  kfifo_len(&ams_fifo);

	if(kfifo_Len >=size){ //512
		len = kfifo_out(&ams_fifo,fifo_out_data,size);
		/* byte swap flicker data*/
		for (i = 0, j = 0; i < size; i+=2, j++) {
			tmp = ((fifo_out_data[i + 1] << 8) | fifo_out_data[i]); //256
			buf[j] = tmp;
		}

		parse_fifo_end_data(ctx);
	} else {
		len = 0;
	}
	ALS_info("read_fifo read size  %d , kfifo_Len =%d\n",len,kfifo_Len);
	return len;
}

static uint16_t buffer[AMS_FLICKER_NUM_SAMPLES];

int get_fft(ams_deviceCtx_t * ctx , uint32_t *out)
{
	uint32_t clear_buffer[AMS_FFT_SIZE] = { 0 };
	uint32_t wideband_buffer[AMS_FFT_SIZE] = { 0 };
	ssize_t size = 0;
	unsigned int i ,j =0 ;
	uint16_t clear_gain , wideband_gain = 0;
	uint8_t fifo_mod0_gain ,fifo_mod1_gain =0;
	int ret = 0;

	memset(clear_buffer, 0, AMS_FFT_SIZE * sizeof(uint32_t));
	memset(wideband_buffer, 0, AMS_FFT_SIZE * sizeof(uint32_t));
	memset(buffer, 0x00, sizeof(uint16_t) * AMS_FFT_SIZE * 2);

	size = read_fifo(ctx, buffer, AMS_FLICKER_NUM_SAMPLES); //

	kfifo_reset(&ams_fifo);

	/* Separate Clear and Wideband data */
	for (i = 0, j = 0; i < (int)(size/2); i+=2, j++) { //256 sample (clear & wide)
		/* Clear */
		out[j] = clear_buffer[j] = buffer[i]; //seperate 128

		/* Wideband */
		wideband_buffer[j] = buffer[i + 1]; //seperate 128
		//ALS_info("CLEAR[ %d]=%d, WIDE[%d]=%d \n",j,clear_buffer[j],j, wideband_buffer[j]);
	}

	ctx->clear_average_fifo = calc_average(clear_buffer, AMS_CLR_WIDE_FLICKER_NUM_SAMPLES);//128
	ctx->wideband_average_fifo = calc_average(wideband_buffer, AMS_CLR_WIDE_FLICKER_NUM_SAMPLES);//128
	ALS_info("clear_average_fifo %d , wideband_average_fifo %d ,mod0_gain 0x%x , mod1_gain 0x%x  \n", \
			ctx->clear_average_fifo, ctx->wideband_average_fifo, ctx->fifo_mod0_gain, ctx->fifo_mod1_gain);

	fifo_mod0_gain = ctx->fifo_mod0_gain & 0x0F;//clear
	fifo_mod1_gain = (ctx->fifo_mod0_gain >> 4) & 0x0F;//wide

	if (fifo_mod0_gain >= (sizeof(tsl2510_gain_conversion) / sizeof(uint16_t))) {
		clear_gain = tsl2510_gain_conversion[0];
		ALS_err("set default clear_gain = %d (mod0_gain = 0x%x, gain_table size = %d)", clear_gain, ctx->fifo_mod0_gain, (sizeof(tsl2510_gain_conversion) / sizeof(uint16_t)));
	} else {
		clear_gain = tsl2510_gain_conversion[fifo_mod0_gain];
	}

	if (fifo_mod1_gain >= (sizeof(tsl2510_gain_conversion) / sizeof(uint16_t))) {
		wideband_gain = tsl2510_gain_conversion[0];
		ALS_err("set default wideband_gain = %d (mod1_gain = 0x%x, gain_table size = %d)", wideband_gain, (ctx->fifo_mod0_gain >> 4), (sizeof(tsl2510_gain_conversion) / sizeof(uint16_t)));

	} else {
		wideband_gain = tsl2510_gain_conversion[fifo_mod1_gain];
	}

	ctx->clear_average = ((uint32_t)ctx->clear_average_fifo) << 7;
	ctx->wideband_average = ((uint32_t)ctx->wideband_average_fifo) << 7;
	ctx->clear_average /= clear_gain;
	ctx->wideband_average /= wideband_gain;

	ALS_info("cavg_fifo: %d, wavg_fifo: %d,  gain0 =%d , gain1 = %d cavg: %d, wavg: %d\n",
			ctx->clear_average_fifo, ctx->wideband_average_fifo,
			fifo_mod0_gain,fifo_mod1_gain,
			ctx->clear_average, ctx->wideband_average);

	FFT(out, AMS_FFT_SIZE);
	AMS_FIFO_CLEAR(ret);

	if (ret < 0) {
		ALS_err("%s - failed to FIFO CLEAR\n", __func__);
		return ret;
	}
	//ams_rfft(buffer, AMS_FFT_SIZE);
	//ams_get_magnitude((int16_t*)buffer,(uint16_t*)out,AMS_FFT_SIZE/2);
	return 1;
}

bool  ccb_sw_bin4096_flicker_GetResult(void * dcbCtx)
{
	ams_deviceCtx_t * ctx = (ams_deviceCtx_t*)dcbCtx;
	static uint32_t buf[MAX_NUM_FLICKER_SAMPLES] = {0,};
	int max = -1, max2 = -1, i = 0;
	ams_flicker_ctx_t *ccbCtx = (ams_flicker_ctx_t *)&ctx->flickerCtx;
	uint16_t mHz = 9999;
	uint resolution = (1000000 / AMS_SAMPLING_TIME)/AMS_FFT_SIZE;
	uint64_t thd =0;
	uint min_freq = 70 / resolution;
	uint max_freq = 500 / resolution;

	memset(buf,0,sizeof(buf));

	if(get_fft(ctx,buf)){
		//buf[0] = 0;
		for (i = 0; i < min_freq; i++)
			ALS_info("ccb_sw_bin4096_flicker_GetResult: buf[%d]=%d\n", i, buf[i]);
		for (i = min_freq; i <= max_freq; ++i) {			// 10~500
			ALS_info("ccb_sw_bin4096_flicker_GetResult: buf[%d]=%d\n", i, buf[i]);
			if (max2 < 0 || buf[i] > buf[max2]) {
				max2 = i;
			}
			if (max < 0 || buf[max2] > buf[max]) {
				int temp = max;
				max = max2;
				max2 = temp;
			}
		}

		/* New code */
		thd = calc_thd(ctx->clear_average_fifo, ctx->clear_average, buf);
		ALS_info("DEBUG_FLICKER DC:%lld", buf[0]);
		ALS_info("DEBUG_FLICKER buf[%d]=%u, thd %lld", max, buf[max], thd);
		ALS_info("DEBUG_FLICKER max %d max2 %d", max, max2);

		if ((buf[max] < buf[60/resolution-1] || buf[max] < buf[60/resolution+1]) &&
			(buf[60/resolution] > buf[60/resolution-1] && buf[60/resolution] > buf[60/resolution+1])) {
			if (max == 120/resolution || max == 180/resolution
					|| max == 240/resolution || max == 360/resolution) {
				if (buf[120/resolution] > thd) {
					if (buf[100/resolution] > thd)
						mHz = 100;
					else
						mHz = 120;
					ALS_info("flicker_freq %d\n", mHz);
				} else {
					mHz = 0; //Harmonic
					ALS_info("flicker_freq is zero");
				}
			}
		}

		if (mHz == 9999) {
			if (buf[max] > thd) {
				uint32_t hyst_100, hyst_120;

				hyst_100 = 100/resolution;
				hyst_120 = 120/resolution;

				if (max != hyst_100 && max <= hyst_100+1 && max >= hyst_100-1) {
					max = hyst_100;
					ALS_info("except 100hz");
				} else if (max != hyst_120 && max <= hyst_120+1 && max >= hyst_120-1) {
					max = hyst_120;
					ALS_info("except 120hz");
				}
				mHz = (max * resolution);
				ALS_info("flicker_freq %d\n", mHz);
			} else {
				mHz = 0;
				ALS_info("flicker_freq is zero");
			}
		}
		ccbCtx->frequency = mHz;
	}
	ctx->flickerCtx.data_ready = 0;

	return true;
}

static u8 als_buffer[AMS_FLICKER_NUM_SAMPLES] = {0};

void fifo_get_als(uint32_t *clearband, uint32_t *wideband, size_t size)
{
	uint32_t widebuf[AMS_FLICKER_THR_LVL];
	uint32_t clearbuf[AMS_FLICKER_THR_LVL];
	size_t widecnt = 0, clearcnt = 0;
	int tmp, i, start, end;
	size_t len = kfifo_out_peek(&ams_fifo, als_buffer, AMS_FLICKER_NUM_SAMPLES);

	start = (len-size)&~0x0001;
	end = len&~0x0001;

	for (i = start; i < end; i += 2) {
		tmp = als_buffer[i+1]<<8 | als_buffer[i];
		if ((i/2) & 0x0001) /* wideband */
			widebuf[widecnt++] = tmp;
		else {/* clearband */
			clearbuf[clearcnt++] = tmp;
			if (!tsl2510_data->saturation && tmp >= 0x3FFF) {
				tsl2510_data->saturation = true;
				ALS_info("DEBUG_FLICKER saturation");
			}
		}
	}

	*wideband = calc_average(widebuf, widecnt);
	*clearband = calc_average(clearbuf, clearcnt);
}

static bool ccb_FIFOEvent(void *dcbCtx)
{
	uint8_t fifo_lvl = 0;
	uint8_t fifo_ov = 0;
	uint8_t fifo_uf = 0;
	uint16_t fifo_size = 0;
	int len = 0;
	int size = 0;
	//    uint16_t data = 0;
	int  num_samples = 0;
	int num_sample_bytes= 0;
#if defined(CONFIG_AMS_ADD_MARKER_AND_GAIN_FIFO)
	uint8_t fd_gain = 0;
#endif
	int ret = 0 ;

	ams_deviceCtx_t *ctx = (ams_deviceCtx_t *)dcbCtx;
	ams_flicker_ctx_t *ccbCtx = (ams_flicker_ctx_t *)&ctx->flickerCtx;

	ccbCtx->statusReg = ctx->shadowFIFOStatusReg;
	num_samples =ctx->flicker_num_samples;
	num_sample_bytes = num_samples*4;

	ams_getByte(ctx->portHndl, DEVREG_FIFO_LEVEL, &fifo_lvl); //current fifo count

	ccbCtx->fifolvl = (uint16_t)((fifo_lvl << 2) | (ccbCtx->statusReg & 0x03));

	fifo_ov = (ccbCtx->statusReg & MASK_FIFO_OVERFLOW) >> 7;
	fifo_uf = (ccbCtx->statusReg & MASK_FIFO_UNDERFLOW) >> 6;

	ccbCtx->overflow += fifo_ov;
	if (fifo_ov > 0) {
		AMS_FIFO_CLEAR(ret);
		if (ret < 0) {
			ALS_err("%s - failed to FIFO CLEAR\n", __func__);
			return ret;
		}
		ccbCtx->fifolvl = 0;

		kfifo_reset(&ams_fifo);
		ALS_err("%s - fifo over flow [0x%x]\n", __func__, fifo_ov);
		return false;
	}
	if (fifo_uf > 0) {
		ALS_err("%s - fifo under flow [0x%x]\n", __func__, fifo_uf);
	}

	fifo_size = ccbCtx->fifolvl;

	//quotient = fifo_size / 32;
	//remainder = fifo_size % 32;

	ALS_info("%s - FIFO LVL or FIFO size = %d\n ", __func__, ccbCtx->fifolvl);
	while (fifo_size > 0) {
		if (fifo_size >= I2C_SMBUS_BLOCK_MAX) {
			size = I2C_SMBUS_BLOCK_MAX;
		}
		else {
			size = fifo_size;
		}
		memset(&fifodata, 0x0, sizeof(fifodata));
		ams_getBuf(ctx->portHndl, DEVREG_FIFO_DATA, (uint8_t *)&fifodata, size);

		fifo_size -= size;
		kfifo_in(&ams_fifo, fifodata, size);
		if (kfifo_is_full(&ams_fifo)) {
			kfifo_reset(&ams_fifo);
			ALS_err("%s - ams_fifo is full\n", __func__);
			break;
		}
	}

	if((len = kfifo_len(&ams_fifo)) >= (num_samples)) //512 byte , 256 level
		//if((len = kfifo_len(&ams_fifo)) >= (num_sample_bytes)) // 512 SAMPLE * clear & wide
	{
		ctx->flickerCtx.data_ready = 1;
		//dev_info(&chip->client->dev, "Sample Rate: %ld Hz\n", sample_rate);
		ALS_info("%s FIFO now is full!!! ready  to calc freq   fifo size %d ",__func__,len);

	}
#ifdef USE_GET_FIFO_ALS
	else { // ALS process
		amsAlsDataSet_t inputData;
		adcDataSet_t dataSet;
		amsAlsContext_t *alsCtx = &(ctx->ccbAlsCtx.ctxAlgAls);
		uint32_t wideband, clearband;
		uint32_t gain0, gain1;
		u8 gain;

		inputData.status = ALS_STATUS_RDY;
		inputData.datasetArray = (alsData_t *)&dataSet;
		fifo_get_als(&clearband, &wideband, ccbCtx->fifolvl);

		AMS_GET_MOD_GAIN(gain0, gain1, gain, ret);
		if (ret < 0) {
			ALS_err("%s - failed to AMS_GET_ALS_GAIN\n", __func__);
			return ret;
		}
		ctx->clear_average = clearband << 7;
		ctx->wideband_average = wideband << 7;
		ctx->clear_average /= (gain0/500);
		ctx->wideband_average /= (gain1/500);
		alsCtx->ClearGain = gain0;
		alsCtx->WBGain = gain1;
		alsCtx->time_us = AMS_SAMPLING_TIME * (ccbCtx->fifolvl / 4);

		dataSet.AdcClear = ctx->clear_average;
		dataSet.AdcWb = ctx->wideband_average;

		amsAlg_als_processData(&ctx->ccbAlsCtx.ctxAlgAls, &inputData);
		ctx->updateAvailable |= (1 << AMS_AMBIENT_SENSOR);

		ALS_info("cavg_fifo: %d, wavg_fifo: %d,  gain0=%d , gain1= %d cavg: %d, wavg: %d time_us:%d\n",
				clearband, wideband, gain&0x0F, (gain&0xF0)>>4,
				ctx->clear_average, ctx->wideband_average, alsCtx->time_us);
	}
#endif
	//AMS_FIFO_CLEAR(ret);


	return false;
}


static int ccb_alsHandle(void *dcbCtx, ams_ccb_als_dataSet_t *alsData)
{
	ams_deviceCtx_t *ctx = (ams_deviceCtx_t *)dcbCtx;
	ams_ccb_als_ctx_t *ccbCtx = &((ams_deviceCtx_t *)dcbCtx)->ccbAlsCtx;
	amsAlsDataSet_t inputDataAls;
	static adcDataSet_t adcData; /* QC - is this really needed? */
	uint8_t ADCs[4]; //Clear + WIDEBAND
	int ret = 0;

	/* get gain from HW register if so configured */
	if (ctx->ccbAlsCtx.initData.autoGain) {
		uint32_t scaledGain;
		uint32_t scaledGain1;

		uint8_t gain;

		AMS_GET_ALS_GAIN(scaledGain, scaledGain1, gain, ret);
		if (ret < 0) {
			ALS_err("%s - failed to AMS_GET_ALS_GAIN\n", __func__);
			return ret;
		}
		ctx->ccbAlsCtx.ctxAlgAls.ClearGain = scaledGain;
		ctx->ccbAlsCtx.ctxAlgAls.WBGain = scaledGain1;
	}

	switch (ccbCtx->state) {
		case AMS_CCB_ALS_RGB: /* state to measure RGB */
			if ((alsData->status2Reg & (ALS_DATA_VALID)) /*|| ctx->alwaysReadAls*/)
			{
				AMS_ALS_GET_ALS_DATA(&ADCs[0], ret);
				if (ret < 0) {
					ALS_err("%s - failed to AMS_ALS_GET_CRGB_W\n", __func__);
					return ret;
				}
				inputDataAls.status = ALS_STATUS_RDY;

				if ((alsData->alsstatusReg & 0x04) == 0)
					adcData.AdcClear = ((ADCs[1] << 8) | (ADCs[0] << 0)) << 4;
				else
					adcData.AdcClear = ((ADCs[1] << 8) | (ADCs[0] << 0));

				if ((alsData->alsstatusReg & 0x02) == 0)
					adcData.AdcWb = ((ADCs[3] << 8) | (ADCs[2] << 0)) << 4;
				else
					adcData.AdcWb = ((ADCs[3] << 8) | (ADCs[2] << 0));

				if ((alsData->alsstatus2Reg & 0x0F) == 0)
					adcData.AdcClear = (((adcData.AdcClear) << 1)); // 0.5x
				else
					adcData.AdcClear = (((adcData.AdcClear) >> ((alsData->alsstatus2Reg & 0x0F) - 1)));

				if (((alsData->alsstatus2Reg & 0xF0) >> 4) == 0)
					adcData.AdcWb = (((adcData.AdcWb) << 1)); // 0.5x
				else
					adcData.AdcWb = (((adcData.AdcWb) >> (((alsData->alsstatus2Reg & 0xF0) >> 4) - 1)));

				inputDataAls.datasetArray = (alsData_t *)&adcData;
				AMS_PORT_LOG_CRGB_W(adcData);
				ALS_info("Clear AGAIN = %d, WIDE AGAIN =%d\n", ctx->ccbAlsCtx.ctxAlgAls.ClearGain, ctx->ccbAlsCtx.ctxAlgAls.WBGain);

				amsAlg_als_processData(&ctx->ccbAlsCtx.ctxAlgAls, &inputDataAls);

				if (ctx->mode & MODE_ALS_LUX)
					ctx->updateAvailable |= (1 << AMS_AMBIENT_SENSOR);
				ccbCtx->state = AMS_CCB_ALS_RGB;
			}
			break;

		default:
			ccbCtx->state = AMS_CCB_ALS_RGB;
			break;
	}
	return false;
}

static void ccb_alsGetResult(void *dcbCtx, ams_ccb_als_result_t *exportData)
{
	ams_ccb_als_ctx_t *ccbCtx = &((ams_deviceCtx_t *)dcbCtx)->ccbAlsCtx;

	/* export data */
	exportData->clear = ccbCtx->ctxAlgAls.results.irrClear;
	exportData->ir = ccbCtx->ctxAlgAls.results.IR;
	exportData->wideband = ccbCtx->ctxAlgAls.results.irrWideband;
	exportData->time_us = ccbCtx->ctxAlgAls.time_us;
	exportData->ClearGain = ccbCtx->ctxAlgAls.ClearGain;
	exportData->WBGain = ccbCtx->ctxAlgAls.WBGain;
	exportData->rawClear = ccbCtx->ctxAlgAls.results.rawClear;
	exportData->rawWideband = ccbCtx->ctxAlgAls.results.rawWideband;
}

static bool _2510_alsSetThreshold(ams_deviceCtx_t *ctx, int32_t threshold)
{
	ams_ccb_als_config_t configData;

	configData.threshold = threshold;
	ccb_alsSetConfig(ctx, &configData);

	return false;
}

static void  ams_sensor_mode_set(ams_deviceCtx_t *ctx, uint8_t  sensor_mode)
{
	int ret = 0;

	ctx->sensor_mode = sensor_mode;

	ALS_dbg("%s - ams_sensor_mode_set %d \n", __func__,sensor_mode);

	if (sensor_mode == 0) {
		AMS_ALS_SENSOR_6PD_TURNON(ret);
	} else {
		AMS_ALS_SENSOR_2PD_TURNON(ret);
	}
}

static int ams_deviceSetConfig(ams_deviceCtx_t *ctx, ams_configureFeature_t feature, deviceConfigOptions_t option, uint32_t data)
{
	int ret = 0;

	if (feature == AMS_CONFIG_ALS_LUX) {
		ALS_dbg("%s - ams_configureFeature_t AMS_CONFIG_ALS_LUX\n", __func__);
		switch (option) {
			case AMS_CONFIG_ENABLE: /* ON / OFF */
				ALS_info("%s - deviceConfigOptions_t AMS_CONFIG_ENABLE(%u)\n", __func__, data);
				ALS_info("%s - current mode %d\n", __func__, ctx->mode);
				if (data == 0) {
					if (ctx->mode == MODE_ALS_LUX) {
						/* if no other active features, turn off device */
						ctx->shadowEnableReg = 0;
						ctx->shadowIntenabReg = 0;
						ctx->mode = MODE_OFF;
					} else {
						if ((ctx->mode & MODE_ALS_ALL) == MODE_ALS_LUX) {
							ctx->shadowEnableReg &= ~MASK_AEN;
							ctx->shadowIntenabReg &= ~MASK_ALS_INT_ALL;
						}
						ctx->mode &= ~(MODE_ALS_LUX);
					}
				}
				else {
					if ((ctx->mode & MODE_ALS_ALL) == 0) {
						ret = ccb_alsInit(ctx, &ctx->ccbAlsCtx.initData);
						if (ret < 0) {
							ALS_err("%s - failed to ccb_alsInit\n", __func__);
							return ret;
						}

						ctx->shadowEnableReg |= (AEN | PON);
						//if( ctx->sensor_mode == 1)	{ //als need polling mode , 200msec
						//    ctx->shadowIntenabReg |= AIEN;
						//}
					} else {
						/* force interrupt */
						ret = ams_setWord(ctx->portHndl, DEVREG_AILT0, 0x00);

						if (ret < 0) {
							ALS_err("%s - failed to set DEVREG_AIHTL\n", __func__);
							return ret;
						}

						ret = ams_setByte(ctx->portHndl, DEVREG_AILT2, 0x00);

						if (ret < 0) {
							ALS_err("%s - failed to set DEVREG_AIHTL\n", __func__);
							return ret;
						}

					}
					ctx->mode |= MODE_ALS_LUX;
				}
				break;
			case AMS_CONFIG_THRESHOLD: /* set threshold */
				ALS_info("%s - deviceConfigOptions_t AMS_CONFIG_THRESHOLD\n", __func__);
				ALS_info("%s - data %d\n", __func__, data);
				_2510_alsSetThreshold(ctx, data);
				break;
			default:
				break;
		}
	}
#if defined(CONFIG_AMS_OPTICAL_SENSOR_FLICKER)
	if (feature == AMS_CONFIG_FLICKER) {
		ALS_dbg("%s - ams_configureFeature_t AMS_CONFIG_FLICKER\n", __func__);
		switch (option) {
			case AMS_CONFIG_ENABLE: /* power on */
				ALS_info("%s - deviceConfigOptions_t AMS_CONFIG_ENABLE(%u)\n", __func__, data);
				ALS_info("%s - current mode %d\n", __func__, ctx->mode);
				if (data == 0) {
					ret = ams_setField(ctx->portHndl, DEVREG_INTENAB, LOW, MASK_FIEN);// FIFO Interrupt disable
					if (ret < 0) {
						ALS_err("%s - failed to set DEVREG_CFG9\n", __func__);
						return ret;
					}
					if (ctx->mode == MODE_FLICKER) {
						/* if no other active features, turn off device */
						ctx->shadowEnableReg = 0;
						ctx->shadowIntenabReg = 0;
						ctx->mode = MODE_OFF;
						ams_setByte(ctx->portHndl, DEVREG_CONTROL, 0x02); //20180828 FIFO Buffer , FINT, FIFO_OV, FIFO_LVL all clear
					}
					else {
						ctx->mode &= ~MODE_FLICKER;
						ctx->shadowEnableReg &= ~(FDEN);
					}
				}
				else {
					ctx->shadowEnableReg |= (PON | FDEN);
					ctx->shadowIntenabReg |= (SIEN|FIEN);
					ctx->mode |= MODE_FLICKER;
					ccb_flickerInit(ctx /*,&ctx->ccbAlsCtx.initData*/);
					kfifo_reset(&ams_fifo);
				}
				break;
			case AMS_CONFIG_THRESHOLD: /* set threshold */
				ALS_info("%s - deviceConfigOptions_t AMS_CONFIG_THRESHOLD\n", __func__);
				/* TODO?:  set FD_COMPARE value? */
				break;
			default:
				break;
		}
	}
#endif
	ret = ams_setByte(ctx->portHndl, DEVREG_INTENAB, ctx->shadowIntenabReg);
	if (ret < 0) {
		ALS_err("%s - failed to set DEVREG_INTENAB\n", __func__);
		return ret;
	}

	ret = ams_setByte(ctx->portHndl, DEVREG_ENABLE, ctx->shadowEnableReg);
	if (ret < 0) {
		ALS_err("%s - failed to set DEVREG_ENABLE\n", __func__);
		return ret;
	}

	return 0;
}

#define STAR_ATIME  50 //50 msec
#define STAR_D_FACTOR  2266

static int amsAlg_als_setConfig(amsAlsContext_t *ctx, amsAlsConf_t *inputData)
{
	int ret = 0;

	if (inputData != NULL) {
		//ctx->gain = inputData->gain;
		ctx->time_us = inputData->time_us;
	}
	//als_update_statics(ctx);

	return ret;
}

/*
 * getConfig: is used to quarry the algorithm's configuration
 */
static int amsAlg_als_getConfig(amsAlsContext_t *ctx, amsAlsConf_t *outputData)
{
	int ret = 0;

	//outputData->gain = ctx->gain;
	outputData->time_us = ctx->time_us;

	return ret;
}

static int amsAlg_als_getResult(amsAlsContext_t *ctx, amsAlsResult_t *outData)
{
	int ret = 0;

	outData->rawClear = ctx->results.rawClear;
	outData->rawWideband = ctx->results.rawWideband;
	outData->irrClear = ctx->results.irrClear;
	outData->irrWideband = ctx->results.irrWideband;
	outData->mLux_ave = ctx->results.mLux_ave / AMS_LUX_AVERAGE_COUNT;
	outData->IR = ctx->results.IR;
	outData->CCT = ctx->results.CCT;
	outData->adaptive = ctx->results.adaptive;

	if (ctx->notStableMeasurement)
		ctx->notStableMeasurement = false;

	outData->mLux = ctx->results.mLux;

	return ret;
}

static int amsAlg_als_initAlg(amsAlsContext_t *ctx, amsAlsInitData_t *initData)
{
	int ret = 0;

	memset(ctx, 0, sizeof(amsAlsContext_t));

	if (initData != NULL) {
		ctx->calibration.Time_base = initData->calibration.Time_base;
		ctx->calibration.thresholdLow = initData->calibration.thresholdLow;
		ctx->calibration.thresholdHigh = initData->calibration.thresholdHigh;
		ctx->calibration.calibrationFactor = initData->calibration.calibrationFactor;
	}

	if (initData != NULL) {
		//ctx->gain = initData->gain;
		ctx->time_us = initData->time_us;
		ctx->adaptive = initData->adaptive;
	}
	else {
		ALS_dbg("error: initData == NULL\n");
	}

	//als_update_statics(ctx);
	return ret;
}

static int amsAlg_als_getAlgInfo(amsAlsAlgoInfo_t *info)
{
	int ret = 0;

	info->algName = "AMS_ALS";
	info->contextMemSize = sizeof(amsAlsContext_t);
	info->scratchMemSize = 0;

	info->initAlg = &amsAlg_als_initAlg;
	info->processData = &amsAlg_als_processData;
	info->getResult = &amsAlg_als_getResult;
	info->setConfig = &amsAlg_als_setConfig;
	info->getConfig = &amsAlg_als_getConfig;

	return ret;
}
static int tsl2510_print_reg_status(void)
{
	int reg, err;
	u8 recvData;

	for (reg = 0; reg < DEVREG_REG_MAX; reg++) {
		err = tsl2510_read_reg(tsl2510_data, deviceRegisterDefinition[reg].address, &recvData, 1);
		if (err != 0) {
			ALS_err("%s - error reading 0x%02x err:%d\n",
					__func__, reg, err);
		}
		else {
			ALS_dbg("%s - 0x%02x = 0x%02x\n",
					__func__, deviceRegisterDefinition[reg].address, recvData);
		}
	}
	return 0;
}

static int tsl2510_set_sampling_rate(u32 sampling_period_ns)
{
	//ALS_dbg("%s - set_sampling_rate not support\n", __func__);

	return 0;
}


static int tsl2510_set_nr_sample(struct tsl2510_device_data *data , u16 fifo_thr)
{
	ams_deviceCtx_t *ctx = data->deviceCtx;
	int ret = 0;

	AMS_DISABLE_FD(ret);
	if (ret < 0) {
		ALS_err("%s - failed to AMS_DISABLE_FD\n", __func__);
		return ret;
	}
	AMS_SET_FLICKER_NUM_SAMPLES(fifo_thr, ret);
	if (ret < 0) {
		ALS_err("%s - failed to AMS_SET_FLICKER_NUM_SAMPLES\n", __func__);
		return ret;
	}
	AMS_REENABLE_FD(ret);
	if (ret < 0) {
		ALS_err("%s - failed to AMS_REENABLE_FD\n", __func__);
		return ret;
	}
	return 1;
}

static int tsl2510_set_sampling_time(struct tsl2510_device_data *data , u16 time)
{
	ams_deviceCtx_t *ctx = data->deviceCtx;
	int ret = 0;

	AMS_DISABLE_FD(ret);
	if (ret < 0) {
		ALS_err("%s - failed to AMS_DISABLE_FD\n", __func__);
		return ret;
	}
	AMS_SET_SAMPLE_TIME(time, ret);
	if (ret < 0) {
		ALS_err("%s - failed to AMS_SET_SAMPLE_TIME\n", __func__);
		return ret;
	}
	AMS_REENABLE_FD(ret);
	if (ret < 0) {
		ALS_err("%s - failed to AMS_REENABLE_FD\n", __func__);
		return ret;
	}
	return 1;
}


static int tsl2510_hamming_status(struct tsl2510_device_data *data , bool on_off)
{
	ams_deviceCtx_t *ctx = data->deviceCtx;
	int ret = 0;

	AMS_DISABLE_FD(ret);
	if (ret < 0) {
		ALS_err("%s - failed to AMS_DISABLE_FD\n", __func__);
		return ret;
	}

	ctx->hamming_status = on_off;

	AMS_REENABLE_FD(ret);
	if (ret < 0) {
		ALS_err("%s - failed to AMS_REENABLE_FD\n", __func__);
		return ret;
	}
	return 1;
}


static int tsl2510_polling_enable(struct tsl2510_device_data *data , bool on_off)
{
	ams_deviceCtx_t *ctx = data->deviceCtx;
	int ret = 0;

	if (on_off == true) {
		AMS_DISABLE_FD(ret); //disable FD
		if (ret < 0) {
			ALS_err("%s - failed to AMS_DISABLE_FD\n", __func__);
			return ret;
		}

		AMS_DISABLE_FDINT(ret); //disable FINT
		if (ret < 0) {
			ALS_err("%s - failed to AMS_DISABLE_FDINT\n", __func__);
			return ret;
		}
		AMS_REENABLE_ALS(ret);

		if(data->timer_is_exist) {
			if (data->timer_is_active) {
				ALS_dbg("%s - als_timer is already running\n", __func__);
			} else {
				hrtimer_start(&data->timer, data->light_poll_delay, HRTIMER_MODE_REL); /* polling start*/
				data->timer_is_active = true;
			}
		}
	} else {
		if(data->timer_is_exist) {
			if (data->timer_is_active) {
				hrtimer_cancel(&data->timer); /*polling stop*/
				data->timer_is_active = false;
			} else {
				ALS_dbg("%s - als_timer is already stopped\n", __func__);
			}
		}

		AMS_DISABLE_ALS(ret);
		AMS_REENABLE_FD(ret);
		if (ret < 0) {
			ALS_err("%s - failed to AMS_REENABLE_FD\n", __func__);
			return ret;
		}
		AMS_REENABLE_FDINT(ret);
		if (ret < 0) {
			ALS_err("%s - failed to AMS_REENABLE_FDINT\n", __func__);
			return ret;
		}
	}

	return 1;
}

static int tsl2510_pon_reenable(struct tsl2510_device_data *data , bool on_off)
{
	ams_deviceCtx_t *ctx = data->deviceCtx;
	int ret = 0;

	if(on_off) {
		AMS_ENABLE_PON(ret);
		if (ret < 0) {
			ALS_err("%s - failed to AMS_ENABLE_PON\n", __func__);
			return ret;
		}
	} else {
		AMS_REENABLE(ret);
		if (ret < 0) {
			ALS_err("%s - failed to AMS_REENABLE\n", __func__);
			return ret;
		}
	}
	return 1;
}

static int tsl2510_set_fifo_thr(struct tsl2510_device_data *data , u16 fifo_thr)
{
	ams_deviceCtx_t *ctx = data->deviceCtx;
	int ret = 0;

	AMS_DISABLE_FD(ret);
	if (ret < 0) {
		ALS_err("%s - failed to AMS_DISABLE_FD\n", __func__);
		return ret;
	}

	AMS_SET_FIFO_THR(fifo_thr, ret);
	if (ret < 0) {
		ALS_err("%s - failed to AMS_SET_FIFO_THR\n", __func__);
		return ret;
	}

	AMS_REENABLE_FD(ret);
	if (ret < 0) {
		ALS_err("%s - failed to AMS_REENABLE_FD\n", __func__);
		return ret;
	}
	return 1;
}


static void tsl2510_irq_set_state(struct tsl2510_device_data *data, int irq_enable)
{
	ALS_dbg("%s - irq_enable : %d, irq_state : %d\n",
			__func__, irq_enable, data->irq_state);

	if (irq_enable) {
		if (data->irq_state++ == 0)
			enable_irq(data->dev_irq);
	}
	else {
		if (data->irq_state == 0)
			return;
		if (--data->irq_state <= 0) {
			disable_irq(data->dev_irq);
			data->irq_state = 0;
		}
	}
}

static int tsl2510_power_ctrl(struct tsl2510_device_data *data, int onoff)
{
	int rc = 0;

	ALS_dbg("%s - onoff : %d, state : %d\n", __func__, onoff, data->regulator_state);

	if (onoff == PWR_ON) {
		if (data->regulator_state != 0) {
			ALS_dbg("%s - duplicate regulator\n", __func__);
			data->regulator_state++;
			return 0;
		}

		if (data->regulator_vbus_1p8) {
			if(regulator_is_enabled(data->regulator_vbus_1p8)) {
				ALS_dbg("%s - vbus regulator already enabled", __func__);
			}
			else if(!data->vbus_1p8_enable) {
				rc = regulator_enable(data->regulator_vbus_1p8);
				if (rc) {
					ALS_err("%s - enable vbus_1p8 failed, rc=%d\n", __func__, rc);
					goto enable_vbus_1p8_failed;
				} else {
					data->vbus_1p8_enable = true;
					ALS_dbg("%s - enable vbus_1p8 done, rc=%d\n", __func__, rc);
				}
			} else {
				ALS_dbg("%s - vbus_1p8 already enabled, en=%d\n", __func__, data->vbus_1p8_enable);
			}
		}

		if (data->regulator_vdd_1p8) {
			if (!data->vdd_1p8_enable) {
				rc = regulator_enable(data->regulator_vdd_1p8);
				if (rc) {
					ALS_err("%s - enable vdd_1p8 failed, rc=%d\n", __func__, rc);
					goto enable_vdd_1p8_failed;
				} else {
					data->vdd_1p8_enable = true;
					ALS_dbg("%s - enable vdd_1p8 done, rc=%d\n", __func__, rc);
#if defined(CONFIG_AMS_ALS_COMPENSATION_FOR_AUTO_BRIGHTNESS)
					if (!data->als_flag)
						msleep_interruptible(40);
					else
						usleep_range(1000, 1100);
#else
					msleep_interruptible(40);
#endif
				}
			} else {
				ALS_dbg("%s - vdd_1p8 already enabled, en=%d\n", __func__, data->vdd_1p8_enable);
			}
		}
		data->regulator_state++;
		data->pm_state = PM_RESUME;
	} else {
		if (data->regulator_state == 0) {
			ALS_dbg("%s - already off the regulator\n", __func__);
			return 0;
		} else if (data->regulator_state != 1) {
			ALS_dbg("%s - duplicate regulator\n", __func__);
			data->regulator_state--;
			return 0;
		}
		data->regulator_state--;

		if (data->regulator_vdd_1p8) {
			if (data->vdd_1p8_enable) {
				rc = regulator_disable(data->regulator_vdd_1p8);
				if (rc) {
					ALS_err("%s - disable vdd_1p8 failed, rc=%d\n", __func__, rc);
				} else {
					data->vdd_1p8_enable = false;
					ALS_dbg("%s - disable vdd_1p8 done, rc=%d\n", __func__, rc);
				}
			} else {
				ALS_dbg("%s - vdd_1p8 already disabled, en=%d\n", __func__, data->vdd_1p8_enable);
			}
		}

		if (data->regulator_vbus_1p8) {
			if (data->vbus_1p8_enable) {
				rc = regulator_disable(data->regulator_vbus_1p8);
				if (rc) {
					ALS_err("%s - disable vbus_1p8 failed, rc=%d\n", __func__, rc);
				} else {
					data->vbus_1p8_enable = false;
					ALS_dbg("%s - disable vbus_1p8 done, rc=%d\n", __func__, rc);
				}
			} else {
				ALS_dbg("%s - vbus_1p8 already disabled, en=%d\n", __func__, data->vbus_1p8_enable);
			}
		}
	}

	goto done;

enable_vdd_1p8_failed:
	if (data->regulator_vbus_1p8) {
		if (data->vbus_1p8_enable) {
			rc = regulator_disable(data->regulator_vbus_1p8);
			if (rc) {
				ALS_err("%s - disable vbus_1p8 failed, rc=%d\n", __func__, rc);
			} else {
				data->vbus_1p8_enable = false;
				ALS_dbg("%s - disable vbus_1p8 done, rc=%d\n", __func__, rc);
			}
		} else {
			ALS_dbg("%s - vbus_1p8 already disabled, en=%d\n", __func__, data->vbus_1p8_enable);
		}
	}
enable_vbus_1p8_failed:
done:
	//usleep_range(2000, 2100);
	return rc;
}

static bool ams_deviceGetAls(ams_deviceCtx_t *ctx, ams_apiAls_t *exportData);
static bool ams_deviceGetFlicker(ams_deviceCtx_t *ctx, ams_apiAlsFlicker_t *exportData);

static void report_als(struct tsl2510_device_data *chip)
{
	ams_apiAls_t outData = {0};
	static unsigned int als_cnt;
	int temp_ir = 0;

	if (chip->als_input_dev) {
		ams_deviceGetAls(chip->deviceCtx, &outData);

		if (chip->saturation) {
			temp_ir = FLICKER_SENSOR_ERR_ID_SATURATION;
		} else {
			temp_ir = outData.ir;
		}

		input_report_rel(chip->als_input_dev, REL_X, temp_ir + 1);
		input_report_rel(chip->als_input_dev, REL_RY, outData.clear + 1);
		input_report_abs(chip->als_input_dev, ABS_X, outData.time_us + 1);
		input_report_abs(chip->als_input_dev, ABS_Y, outData.ClearGain + 1);
		input_report_abs(chip->als_input_dev, ABS_Z, outData.WBGain + 1);
		input_sync(chip->als_input_dev);

		if (als_cnt++ > 10) {
			ALS_dbg("%s - I:%d, W:%d, C:%d, TIME:%d, Clear GAIN:%d WB GAIN : %d\n", __func__,
					temp_ir, outData.wideband, outData.clear, outData.time_us, outData.ClearGain, outData.WBGain);
			als_cnt = 0;
		} else {
			ALS_info("%s - I:%d, W:%d, C:%d, TIME:%d, Clear GAIN:%d WB GAIN : %d\n", __func__,
					temp_ir, outData.wideband, outData.clear, outData.time_us, outData.ClearGain, outData.WBGain);
		}

		chip->user_ir_data = temp_ir;
#if IS_ENABLED(CONFIG_SENSORS_FLICKER_SELF_TEST)
		als_eol_update_als(outData.ir, outData.clear, outData.wideband, 0);
#endif
	}
	chip->saturation = false;
}

static void report_flicker(struct tsl2510_device_data *chip)
{
	ams_apiAlsFlicker_t outData;
	uint flicker = 0;
	static unsigned int flicker_cnt;

	if (chip->als_input_dev) {
		ams_deviceGetFlicker(chip->deviceCtx, &outData);
		flicker = outData.mHz;
		input_report_rel(chip->als_input_dev, REL_RZ, flicker + 1);
		input_sync(chip->als_input_dev);

		if (flicker_cnt++ > 10) {
			ALS_dbg("%s - flicker = %d\n", __func__, flicker);
			flicker_cnt = 0;
		} else {
			ALS_info("%s - flicker = %d\n", __func__, flicker);
		}

		chip->user_flicker_data = flicker;
#if IS_ENABLED(CONFIG_SENSORS_FLICKER_SELF_TEST)
		als_eol_update_flicker(flicker);
#endif
	}
}

static ssize_t als_ir_show(struct device *dev,
		struct device_attribute *attr, char *buf)
{
	ams_apiAls_t outData = {0};
	struct tsl2510_device_data *chip = dev_get_drvdata(dev);

	ams_deviceGetAls(chip->deviceCtx, &outData);

	return snprintf(buf, PAGE_SIZE, "%d\n", outData.ir);
}

static ssize_t als_clear_show(struct device *dev,
		struct device_attribute *attr, char *buf)
{
	ams_apiAls_t outData = {0};
	struct tsl2510_device_data *chip = dev_get_drvdata(dev);

	ams_deviceGetAls(chip->deviceCtx, &outData);

	return snprintf(buf, PAGE_SIZE, "%d\n", outData.clear);
}

static ssize_t als_wideband_show(struct device *dev,
		struct device_attribute *attr, char *buf)
{
	ams_apiAls_t outData = {0};
	struct tsl2510_device_data *chip = dev_get_drvdata(dev);

	ams_deviceGetAls(chip->deviceCtx, &outData);

	return snprintf(buf, PAGE_SIZE, "%d\n", outData.wideband);
}

static ssize_t als_raw_data_show(struct device *dev,
		struct device_attribute *attr, char *buf)
{
	ams_apiAls_t outData = {0};
	struct tsl2510_device_data *chip = dev_get_drvdata(dev);

	ams_deviceGetAls(chip->deviceCtx, &outData);

	return snprintf(buf, PAGE_SIZE, "%d,%d\n", outData.rawWideband, outData.rawClear);
}

static size_t als_enable_set(struct tsl2510_device_data *chip, uint8_t valueToSet)
{
	int rc = 0;

	ams_sensor_mode_set(chip->deviceCtx,chip->sensor_mode);
	if(chip->sensor_mode == 0) { /*Camera(flicker) + als sensor*/

#if defined(CONFIG_AMS_OPTICAL_SENSOR_FLICKER)
		rc = ams_deviceSetConfig(chip->deviceCtx, AMS_CONFIG_FLICKER, AMS_CONFIG_ENABLE, valueToSet);
		if (rc < 0) {
			ALS_err("%s - ams_deviceSetConfig FLICKER fail, rc=%d\n", __func__, rc);
			return rc;
		}
#endif

	} else { /*ALS ONLY work, should be set PD ( 1 Clear ch , 1 Wide band ch)*/
#if defined(CONFIG_AMS_OPTICAL_SENSOR_ALS_CCB)
		rc = ams_deviceSetConfig(chip->deviceCtx, AMS_CONFIG_ALS_LUX, AMS_CONFIG_ENABLE, valueToSet);
		if (rc < 0) {
			ALS_err("%s - ams_deviceSetConfig ALS_LUX fail, rc=%d\n", __func__, rc);
			return rc;
		}
#endif
	}
	rc = tsl2510_polling_enable(chip,chip->sensor_mode);
	if (rc < 0) {
		ALS_err("%s - tsl2510_polling_enable  fail, rc=%d\n", __func__, rc);
		return rc;
	}

	chip->enabled = (u8)valueToSet;
	return 0;
}

#if defined(CONFIG_AMS_OPTICAL_SENSOR_FLICKER)
static ssize_t flicker_data_show(struct device *dev,
		struct device_attribute *attr, char *buf)
{
	ams_apiAlsFlicker_t outData;
	struct tsl2510_device_data *chip = dev_get_drvdata(dev);

	ams_deviceGetFlicker(chip->deviceCtx, &outData);

	return snprintf(buf, PAGE_SIZE, "%d\n", outData.mHz);
}
#endif
/* als input enable/disable sysfs */
static ssize_t tsl2510_enable_show(struct device *dev,
		struct device_attribute *attr, char *buf)
{
	struct tsl2510_device_data *data = dev_get_drvdata(dev);
	ams_mode_t mode;

	ams_getMode(data->deviceCtx, &mode);

	if (mode & MODE_ALS_ALL)
		return snprintf(buf, PAGE_SIZE, "%d\n", 1);
	else
		return snprintf(buf, PAGE_SIZE, "%d\n", 0);
}

static int ams_deviceInit(ams_deviceCtx_t *ctx, AMS_PORT_portHndl *portHndl, ams_calibrationData_t *calibrationData);

int tsl2510_stop(struct tsl2510_device_data *data);
int tsl2510_start(struct tsl2510_device_data *data);

#if defined(CONFIG_AMS_ALS_COMPENSATION_FOR_AUTO_BRIGHTNESS)
void tsl2510_als_init(struct tsl2510_device_data *data)
{
	ams_deviceCtx_t *ctx = data->deviceCtx;
	int err = 0;

	err = ams_deviceInit(data->deviceCtx, data->client, NULL);
	if (err < 0) {
		ALS_err("%s - ams_deviceInit failed.\n", __func__);
		return;
	}
	ALS_dbg("%s - ok\n", __func__);

	AMS_SET_ALS_TIME(16000, err);
	AMS_SET_ALS_PERS(0x00, err);
	AMS_SET_ALS_GAIN0(16000, err);
	AMS_SET_ALS_GAIN1(16000, err);
	ams_setByte(ctx->portHndl, DEVREG_ENABLE, AEN | PON);
}

int tsl2510_als_start(struct tsl2510_device_data *data)
{
	int err = 0;

	ALS_dbg("%s",__func__);
	mutex_lock(&data->activelock);

	err = tsl2510_power_ctrl(data, PWR_ON);
	if (err < 0) {
		ALS_err("%s - als_regulator_on fail err = %d\n", __func__, err);
		goto mutex_unlock;
	}

	if (data->regulator_state == 1 && data->enabled == 0)
		tsl2510_als_init(data);

	goto done;

mutex_unlock:
done:
	mutex_unlock(&data->activelock);
	return err;
}

int tsl2510_als_stop(struct tsl2510_device_data *data)
{
	int err = 0;
	ams_deviceCtx_t *ctx = data->deviceCtx;

	ALS_dbg("%s",__func__);
	mutex_lock(&data->activelock);

	if (data->regulator_state == 0) {
		ALS_dbg("%s - already power off - disable skip\n", __func__);
		goto err_already_off;
	} else if (data->regulator_state == 1 && data->enabled == 0) {
		err = ams_setByte(ctx->portHndl, DEVREG_ENABLE, 0);
		if (err != 0)
			ALS_err("%s - disable err : %d\n", __func__, err);
	}

	err = tsl2510_power_ctrl(data, PWR_OFF);
	if (err < 0)
		ALS_err("%s - als_regulator_off fail err = %d\n",
			__func__, err);

err_already_off:
	mutex_unlock(&data->activelock);

	return err;
}

static ssize_t tsl2510_als_enable_store(struct device *dev,
		struct device_attribute *attr, const char *buf, size_t count)
{
	struct tsl2510_device_data *data = dev_get_drvdata(dev);
	bool value;

	if (strtobool(buf, &value))
		return -EINVAL;

	ALS_dbg("%s - en : %d, c : %d\n", __func__, value, data->enabled);
	if (data->als_flag == value)
		return count;

	data->als_flag = value;

	if (value)
		tsl2510_als_start(data);
	else
		tsl2510_als_stop(data);

	return count;
}

static ssize_t tsl2510_als_enable_show(struct device *dev,
		struct device_attribute *attr, char *buf)
{
	struct tsl2510_device_data *data = dev_get_drvdata(dev);

	return snprintf(buf, PAGE_SIZE, "%u\n", data->als_flag);
}

static ssize_t tsl2510_als_data_show(struct device *dev,
		struct device_attribute *attr, char *buf)
{
	struct tsl2510_device_data *data = dev_get_drvdata(dev);
	ams_deviceCtx_t *ctx = data->deviceCtx;
	ams_ccb_als_dataSet_t ccbAlsData;
	static adcDataSet_t adcData = {0, 0};
	uint8_t ADCs[4];
	int ret;

	if ((data->regulator_state != 1) ||
		(data->enabled != 0) || !data->als_flag)
		return snprintf(buf, PAGE_SIZE, "-1, -1");

	ret = ams_getByte(ctx->portHndl, DEVREG_ALS_STATUS,
			&ctx->shadowAlsStatusReg);
	if (ret < 0) {
		ALS_err("%s - failed to get DEVREG_ALS_STATUS\n", __func__);
		return snprintf(buf, PAGE_SIZE, "-6, -6");
	}
	ret = ams_getByte(ctx->portHndl, DEVREG_ALS_STATUS2,
			&ctx->shadowAlsStatus2Reg);
	if (ret < 0) {
		ALS_err("%s - failed to get DEVREG_ALS_STATUS2\n", __func__);
		return snprintf(buf, PAGE_SIZE, "-6, -6");
	}

	ccbAlsData.alsstatusReg = ctx->shadowAlsStatusReg;
	ccbAlsData.alsstatus2Reg = ctx->shadowAlsStatus2Reg;

	AMS_ALS_GET_ALS_DATA(&ADCs[0], ret);
	if (ret < 0) {
		ALS_err("%s - failed to AMS_ALS_GET_CRGB_W\n", __func__);
		return snprintf(buf, PAGE_SIZE, "-6, -6");
	}

	if ((ccbAlsData.alsstatusReg & 0x04) == 0)
		adcData.AdcClear = ((ADCs[1] << 8) | (ADCs[0] << 0)) << 4;
	else
		adcData.AdcClear = ((ADCs[1] << 8) | (ADCs[0] << 0));

	if ((ccbAlsData.alsstatusReg & 0x02) == 0)
		adcData.AdcWb = ((ADCs[3] << 8) | (ADCs[2] << 0)) << 4;
	else
		adcData.AdcWb = ((ADCs[3] << 8) | (ADCs[2] << 0));

	if ((ccbAlsData.alsstatus2Reg & 0x0F) == 0)
		adcData.AdcClear = (((adcData.AdcClear) << 1)); // 0.5x
	else
		adcData.AdcClear = (((adcData.AdcClear) >> ((ccbAlsData.alsstatus2Reg & 0x0F) - 1)));

	if (((ccbAlsData.alsstatus2Reg & 0xF0) >> 4) == 0)
		adcData.AdcWb = (((adcData.AdcWb) << 1)); // 0.5x
	else
		adcData.AdcWb = (((adcData.AdcWb) >> (((ccbAlsData.alsstatus2Reg & 0xF0) >> 4) - 1)));

	return snprintf(buf, PAGE_SIZE, "%u, %u\n", adcData.AdcClear, adcData.AdcWb);
}
#endif /* CONFIG_AMS_ALS_COMPENSATION_FOR_AUTO_BRIGHTNESS */

static ssize_t tsl2510_enable_store(struct device *dev,
		struct device_attribute *attr, const char *buf, size_t count)
{
	struct tsl2510_device_data *data = dev_get_drvdata(dev);
	bool value;

	if (strtobool(buf, &value))
		return -EINVAL;

	ALS_dbg("%s - en : %d, c : %d\n", __func__, value, data->enabled);

	if (value)
		tsl2510_start(data);
	else
		tsl2510_stop(data);

	return count;
}

int tsl2510_start(struct tsl2510_device_data *data)
{
	int err = 0;

	ALS_dbg("%s",__func__);
	mutex_lock(&data->activelock);

	err = tsl2510_power_ctrl(data, PWR_ON);
	if (err < 0) {
		ALS_err("%s - als_regulator_on fail err = %d\n", __func__, err);
		goto mutex_unlock;
	}

#if defined(CONFIG_AMS_ALS_COMPENSATION_FOR_AUTO_BRIGHTNESS)
	if ((data->regulator_state == 1) ||
		(data->als_flag && data->regulator_state == 2)) {
#else
	if (data->regulator_state == 1) {
#endif
		err = ams_deviceInit(data->deviceCtx, data->client, NULL);
		if (err < 0) {
			ALS_err("%s - ams_deviceInit failed.\n", __func__);
			goto err_device_init;
		}
		ALS_dbg("%s - ams_deviceInit ok\n", __func__);

		if(data->sensor_mode == 0) { /*Camera(flicker) + als sensor*/
			tsl2510_irq_set_state(data, PWR_ON);
		}

		err = als_enable_set(data, AMSDRIVER_ALS_ENABLE);
		if (err < 0) {
			input_report_rel(data->als_input_dev, REL_RZ, -5 + 1); /* F_ERR_I2C -5 detected i2c error */
			input_sync(data->als_input_dev);
			ALS_err("%s - enable error %d\n", __func__, err);
			goto err_device_init;
		}
	}

	data->mode_cnt.amb_cnt++;
	goto done;

err_device_init:
	tsl2510_power_ctrl(data, PWR_OFF);
mutex_unlock:
done:
	mutex_unlock(&data->activelock);

	return err;
}

int tsl2510_stop(struct tsl2510_device_data *data)
{
	int err = 0;

	ALS_dbg("%s",__func__);
	mutex_lock(&data->activelock);

	if (data->regulator_state == 0) {
		ALS_dbg("%s - already power off - disable skip\n",
				__func__);
		err = -1;
		goto err_already_off;
#if defined(CONFIG_AMS_ALS_COMPENSATION_FOR_AUTO_BRIGHTNESS)
	} else if ((data->regulator_state == 1) ||
		(data->als_flag && data->regulator_state == 2)) {
#else
	} else if (data->regulator_state == 1) {
#endif
		if(data->sensor_mode == 0) { /*Camera(flicker) + als sensor*/
			tsl2510_irq_set_state(data, PWR_OFF);
			usleep_range(1000, 1100);
		}

		err = als_enable_set(data, AMSDRIVER_ALS_DISABLE);
		if (err != 0)
			ALS_err("%s - disable err : %d\n", __func__, err);
	}

	err = tsl2510_power_ctrl(data, PWR_OFF);
	if (err < 0)
		ALS_err("%s - als_regulator_off fail err = %d\n",
				__func__, err);

#if defined(CONFIG_AMS_OPTICAL_SENSOR_POLLING)
	if(data->timer_is_exist) {
		hrtimer_cancel(&data->timer);
		data->timer_is_active = false;
	}

	if (data->wq) {
		cancel_work_sync(&data->work_light);
	}
#endif

#if defined(CONFIG_AMS_ALS_COMPENSATION_FOR_AUTO_BRIGHTNESS)
	if (data->regulator_state == 1 && data->als_flag)
		tsl2510_als_init(data);
#endif

err_already_off:
	mutex_unlock(&data->activelock);

	return err;
}

static ssize_t tsl2510_poll_delay_show(struct device *dev,
		struct device_attribute *attr, char *buf)
{
	struct tsl2510_device_data *data = dev_get_drvdata(dev);

	return snprintf(buf, PAGE_SIZE, "%d\n", data->sampling_period_ns);
}

static ssize_t tsl2510_poll_delay_store(struct device *dev,
		struct device_attribute *attr,
		const char *buf, size_t size)
{
	struct tsl2510_device_data *data = dev_get_drvdata(dev);
	u32 sampling_period_ns = 0;
	int err = 0;

	mutex_lock(&data->activelock);

	err = kstrtoint(buf, 10, &sampling_period_ns);

	if (err < 0) {
		ALS_err("%s - kstrtoint failed.(%d)\n", __func__, err);
		mutex_unlock(&data->activelock);
		return err;
	}
	data->light_poll_delay = ns_to_ktime(sampling_period_ns);
	err = tsl2510_set_sampling_rate(sampling_period_ns);

	if (err > 0)
		data->sampling_period_ns = sampling_period_ns;

	ALS_dbg("%s - tsl2510_poll_delay_store  as %d\n", __func__, sampling_period_ns);

	mutex_unlock(&data->activelock);

	return size;
}

static ssize_t tsl2510_fifo_thr_show(struct device *dev,
		struct device_attribute *attr, char *buf)
{
	struct tsl2510_device_data *data = dev_get_drvdata(dev);

	return snprintf(buf, PAGE_SIZE, "%d\n", data->fifo_thr);
}

static ssize_t tsl2510_fifo_thr_store(struct device *dev,
		struct device_attribute *attr,
		const char *buf, size_t size)
{
	struct tsl2510_device_data *data = dev_get_drvdata(dev);
	u32 fifo_thr = 0;
	int err = 0;

	mutex_lock(&data->activelock);

	err = kstrtoint(buf, 10, &fifo_thr);

	if (err < 0) {
		ALS_err("%s - kstrtoint failed.(%d)\n", __func__, err);
		mutex_unlock(&data->activelock);
		return err;
	}
	err = tsl2510_set_fifo_thr(data,fifo_thr);


	ALS_dbg("%s - tsl2510_fifo_thr_store  as %d\n", __func__, fifo_thr);

	mutex_unlock(&data->activelock);

	return size;
}

static ssize_t tsl2510_fd_nr_sample_show(struct device *dev,
		struct device_attribute *attr, char *buf)
{
	struct tsl2510_device_data *data = dev_get_drvdata(dev);

	return snprintf(buf, PAGE_SIZE, "%d\n", data->fifo_thr);
}

static ssize_t tsl2510_fd_nr_sample_store(struct device *dev,
		struct device_attribute *attr,
		const char *buf, size_t size)
{
	struct tsl2510_device_data *data = dev_get_drvdata(dev);
	u32 fifo_thr = 0;
	int err = 0;

	mutex_lock(&data->activelock);

	err = kstrtoint(buf, 10, &fifo_thr);

	if (err < 0) {
		ALS_err("%s - kstrtoint failed.(%d)\n", __func__, err);
		mutex_unlock(&data->activelock);
		return err;
	}
	err = tsl2510_set_nr_sample(data,fifo_thr);


	ALS_dbg("%s - tsl2510_fd_nr_sample_store  as %d\n", __func__, fifo_thr);

	mutex_unlock(&data->activelock);

	return size;
}

static ssize_t tsl2510_sampling_time_show(struct device *dev,
		struct device_attribute *attr, char *buf)
{
	struct tsl2510_device_data *data = dev_get_drvdata(dev);

	return snprintf(buf, PAGE_SIZE, "%d\n", data->fifo_thr);
}

static ssize_t tsl2510_sampling_time_store(struct device *dev,
		struct device_attribute *attr,
		const char *buf, size_t size)
{
	struct tsl2510_device_data *data = dev_get_drvdata(dev);
	u32 fifo_thr = 0;
	int err = 0;

	mutex_lock(&data->activelock);

	err = kstrtoint(buf, 10, &fifo_thr);

	if (err < 0) {
		ALS_err("%s - kstrtoint failed.(%d)\n", __func__, err);
		mutex_unlock(&data->activelock);
		return err;
	}
	err = tsl2510_set_sampling_time(data,fifo_thr);


	ALS_dbg("%s - tsl2510_set_sampling_time as %d\n", __func__, fifo_thr);

	mutex_unlock(&data->activelock);

	return size;
}


static ssize_t tsl2510_hamming_show(struct device *dev,
		struct device_attribute *attr, char *buf)
{
	struct tsl2510_device_data *data = dev_get_drvdata(dev);

	return snprintf(buf, PAGE_SIZE, "%d\n", data->fifo_thr);
}

static ssize_t tsl2510_hamming_store(struct device *dev,
		struct device_attribute *attr,
		const char *buf, size_t size)
{
	struct tsl2510_device_data *data = dev_get_drvdata(dev);
	u32 hamming_on_ff = 0;
	int err = 0;

	mutex_lock(&data->activelock);

	err = kstrtoint(buf, 10, &hamming_on_ff);

	if (err < 0) {
		ALS_err("%s - kstrtoint failed.(%d)\n", __func__, err);
		mutex_unlock(&data->activelock);
		return err;
	}


	err = tsl2510_hamming_status(data,hamming_on_ff);


	ALS_dbg("%s - tsl2510_hamming_store %d \n", __func__, hamming_on_ff);

	mutex_unlock(&data->activelock);

	return size;
}


static ssize_t tsl2510_polling_enable_store(struct device *dev,
		struct device_attribute *attr,
		const char *buf, size_t size)
{
	struct tsl2510_device_data *data = dev_get_drvdata(dev);
	u32 hamming_on_ff = 0;
	int err = 0;

	mutex_lock(&data->activelock);

	err = kstrtoint(buf, 10, &hamming_on_ff);

	if (err < 0) {
		ALS_err("%s - kstrtoint failed.(%d)\n", __func__, err);
		mutex_unlock(&data->activelock);
		return err;
	}

	err = tsl2510_polling_enable(data,hamming_on_ff);

	ALS_dbg("%s - tsl2510_polling_enable_store %d \n", __func__, hamming_on_ff);

	mutex_unlock(&data->activelock);

	return size;
}

static ssize_t tsl2510_regs_write_store (struct device *dev,
		struct device_attribute *attr,
		const char *buf, size_t size)
{
	int num = 0;
	int ret = 0;
	u8 reg = 0x00;

	char r_value = 0x00;
	char w_value = 0x00;

	struct tsl2510_device_data *data = dev_get_drvdata(dev);

	num = sscanf(buf,"W:0x%hhx,0x%hhx",&reg,&w_value);

	mutex_lock(&data->activelock);

	ret = tsl2510_read_reg(data, (u8)reg, &r_value, 1);
	if (ret != 0) {
		ALS_err("%s - err=%d, val=0x%06x\n",
				__func__, ret, r_value);
		mutex_unlock(&data->activelock);
		return ret;
	}

	ret = tsl2510_pon_reenable(data,true);//pon

	if (ret < 0) {
		ALS_err("%s - failed to AMS_ENABLE_PON\n", __func__);
		mutex_unlock(&data->activelock);
		return 0;
	}

	ALS_dbg("%s   read reg 0x%x , val 0x%x \n",__func__, reg,r_value);

	ret = tsl2510_write_reg(data, (u8)reg, (u8)w_value);
	if (ret < 0) {
		ALS_err("%s - fail err = %d\n", __func__, ret);
		mutex_unlock(&data->activelock);
		return ret;
	}

	ALS_dbg("%s   write reg 0x%x , val 0x%x \n",__func__, reg,w_value);

	ret = tsl2510_pon_reenable(data,false);//reenable

	if (ret < 0) {
		ALS_err("%s - failed to AMS_REENABLE\n", __func__);
		mutex_unlock(&data->activelock);
		return 0;
	}

	mutex_unlock(&data->activelock);
	return size;
}

static ssize_t tsl2510_sensor_mode_show(struct device *dev,
		struct device_attribute *attr, char *buf)
{
	struct tsl2510_device_data *data = dev_get_drvdata(dev);

	return snprintf(buf, PAGE_SIZE, "%d\n", data->sensor_mode);
}

static ssize_t tsl2510_sensor_mode_store (struct device *dev,
		struct device_attribute *attr,
		const char *buf, size_t size)
{
	struct tsl2510_device_data *data = dev_get_drvdata(dev);
	u32 sensor_mode = 0;
	int err = 0;
	int prev_state = 0;

	prev_state = data->enabled;

	if (data->enabled > 0) {
		tsl2510_stop(data);
	}
	mutex_lock(&data->activelock);

	err = kstrtoint(buf, 10, &sensor_mode);

	if (err < 0) {
		ALS_err("%s - kstrtoint failed.(%d)\n", __func__, err);
		mutex_unlock(&data->activelock);
		return err;
	}

	data->sensor_mode = (u8)sensor_mode;
	ALS_dbg("%s - tsl2510_sensor_mode %d \n", __func__, sensor_mode);

	mutex_unlock(&data->activelock);

	if (prev_state > 0) {
		tsl2510_start(data);
	}

	return size;
}


static DEVICE_ATTR(enable, S_IRUGO | S_IWUSR | S_IWGRP,
		tsl2510_enable_show, tsl2510_enable_store);
static DEVICE_ATTR(poll_delay, S_IRUGO | S_IWUSR | S_IWGRP,
		tsl2510_poll_delay_show, tsl2510_poll_delay_store);
static DEVICE_ATTR(fifo_thr, S_IRUGO | S_IWUSR | S_IWGRP,
		tsl2510_fifo_thr_show, tsl2510_fifo_thr_store);
static DEVICE_ATTR(fd_nr_sample, S_IRUGO | S_IWUSR | S_IWGRP,
		tsl2510_fd_nr_sample_show, tsl2510_fd_nr_sample_store);
static DEVICE_ATTR(sampling_time, S_IRUGO | S_IWUSR | S_IWGRP,
		tsl2510_sampling_time_show, tsl2510_sampling_time_store);
static DEVICE_ATTR(hamming_on_off, S_IRUGO | S_IWUSR | S_IWGRP,
		tsl2510_hamming_show, tsl2510_hamming_store);
static DEVICE_ATTR(poll_enable, S_IRUGO | S_IWUSR | S_IWGRP,
		NULL, tsl2510_polling_enable_store);
static DEVICE_ATTR(2510_regs, S_IRUGO | S_IWUSR | S_IWGRP,
		NULL, tsl2510_regs_write_store);
static DEVICE_ATTR(sensor_mode, S_IRUGO | S_IWUSR | S_IWGRP,
		tsl2510_sensor_mode_show, tsl2510_sensor_mode_store);

static struct attribute *als_sysfs_attrs[] = {
	&dev_attr_enable.attr,
	&dev_attr_poll_delay.attr,
	&dev_attr_poll_enable.attr,
	&dev_attr_fifo_thr.attr,
	&dev_attr_fd_nr_sample.attr,
	&dev_attr_sampling_time.attr,
	&dev_attr_hamming_on_off.attr,
	&dev_attr_2510_regs.attr,
	&dev_attr_sensor_mode.attr,
	NULL
};

static struct attribute_group als_attribute_group = {
	.attrs = als_sysfs_attrs,
};

/* als_sensor sysfs */
static ssize_t tsl2510_name_show(struct device *dev,
		struct device_attribute *attr, char *buf)
{
	struct tsl2510_device_data *data = dev_get_drvdata(dev);
	ams_deviceCtx_t *ctx = data->deviceCtx;
	char chip_name[NAME_LEN];

	switch (ctx->deviceId) {
		case AMS_TSL2510:
		case AMS_TSL2510_UNTRIM:
			strlcpy(chip_name, TSL2510_CHIP_NAME, sizeof(chip_name));
			break;
		default:
			strlcpy(chip_name, TSL2510_CHIP_NAME, sizeof(chip_name));
			break;
	}

	return snprintf(buf, PAGE_SIZE, "%s\n", chip_name);
}

static ssize_t tsl2510_vendor_show(struct device *dev,
		struct device_attribute *attr, char *buf)
{
	return snprintf(buf, PAGE_SIZE, "%s\n", VENDOR);
}

static ssize_t tsl2510_flush_store(struct device *dev,
		struct device_attribute *attr, const char *buf, size_t size)
{
	struct tsl2510_device_data *data = dev_get_drvdata(dev);
	ams_deviceCtx_t *ctx = data->deviceCtx;
	int ret = 0;
	u8 handle = 0;

	mutex_lock(&data->activelock);
	ret = kstrtou8(buf, 10, &handle);
	if (ret < 0) {
		ALS_err("%s - kstrtou8 failed.(%d)\n", __func__, ret);
		mutex_unlock(&data->activelock);
		return ret;
	}
	ALS_dbg("%s - handle = %d\n", __func__, handle);
	mutex_unlock(&data->activelock);

	input_report_rel(data->als_input_dev, REL_MISC, handle);

	return size;
}

static ssize_t tsl2510_int_pin_check_show(struct device *dev,
		struct device_attribute *attr, char *buf)
{
	/* need to check if this should be implemented */
	ALS_dbg("%s - not implement\n", __func__);
	return snprintf(buf, PAGE_SIZE, "%d\n", 0);
}

static ssize_t tsl2510_read_reg_show(struct device *dev,
		struct device_attribute *attr, char *buf)
{
	struct tsl2510_device_data *data = dev_get_drvdata(dev);

	ALS_info("%s - val=0x%06x\n", __func__, data->reg_read_buf);

	return snprintf(buf, PAGE_SIZE, "%d\n", data->reg_read_buf);
}

static ssize_t tsl2510_read_reg_store(struct device *dev,
		struct device_attribute *attr, const char *buf, size_t size)
{
	struct tsl2510_device_data *data = dev_get_drvdata(dev);

	int err = -1;
	unsigned int cmd = 0;
	u8 val = 0;

	mutex_lock(&data->i2clock);
	if (data->regulator_state == 0) {
		ALS_dbg("%s - need to power on\n", __func__);
		mutex_unlock(&data->i2clock);
		return size;
	}
	err = sscanf(buf, "%8x", &cmd);
	if (err == 0) {
		ALS_err("%s - sscanf fail\n", __func__);
		mutex_unlock(&data->i2clock);
		return size;
	}

	err = tsl2510_read_reg(data, (u8)cmd, &val, 1);
	if (err != 0) {
		ALS_err("%s - err=%d, val=0x%06x\n",
				__func__, err, val);
		mutex_unlock(&data->i2clock);
		return size;
	}
	data->reg_read_buf = (u32)val;
	mutex_unlock(&data->i2clock);

	return size;
}
static ssize_t tsl2510_write_reg_store(struct device *dev,
		struct device_attribute *attr, const char *buf, size_t size)
{
	struct tsl2510_device_data *data = dev_get_drvdata(dev);

	int err = -1;
	unsigned int cmd = 0;
	unsigned int val = 0;

	mutex_lock(&data->i2clock);
	if (data->regulator_state == 0) {
		ALS_dbg("%s - need to power on.\n", __func__);
		mutex_unlock(&data->i2clock);
		return size;
	}
	err = sscanf(buf, "%8x, %8x", &cmd, &val);
	if (err == 0) {
		ALS_err("%s - sscanf fail %s\n", __func__, buf);
		mutex_unlock(&data->i2clock);
		return size;
	}

	err = tsl2510_write_reg(data, (u8)cmd, (u8)val);
	if (err < 0) {
		ALS_err("%s - fail err = %d\n", __func__, err);
		mutex_unlock(&data->i2clock);
		return err;
	}
	mutex_unlock(&data->i2clock);

	return size;
}

static ssize_t tsl2510_debug_show(struct device *dev,
		struct device_attribute *attr, char *buf)
{
	struct tsl2510_device_data *data = dev_get_drvdata(dev);

	ALS_info("%s - debug mode = %u\n", __func__, data->debug_mode);

	return snprintf(buf, PAGE_SIZE, "%u\n", data->debug_mode);
}

static ssize_t tsl2510_debug_store(struct device *dev,
		struct device_attribute *attr, const char *buf, size_t size)
{
	struct tsl2510_device_data *data = dev_get_drvdata(dev);
	int err;
	s32 mode;

	mutex_lock(&data->activelock);
	err = kstrtoint(buf, 10, &mode);
	if (err < 0) {
		ALS_err("%s - kstrtoint failed.(%d)\n", __func__, err);
		mutex_unlock(&data->activelock);
		return err;
	}
	data->debug_mode = (u8)mode;
	ALS_info("%s - mode = %d\n", __func__, mode);

	switch (data->debug_mode) {
		case DEBUG_REG_STATUS:
			tsl2510_print_reg_status();
			break;
		case DEBUG_VAR:
			tsl2510_debug_var(data);
			break;
		default:
			break;
	}
	mutex_unlock(&data->activelock);

	return size;
}

static ssize_t tsl2510_device_id_show(struct device *dev,
		struct device_attribute *attr, char *buf)
{
	ALS_dbg("%s - device_id not support\n", __func__);

	return snprintf(buf, PAGE_SIZE, "NOT SUPPORT\n");
}

static ssize_t tsl2510_part_type_show(struct device *dev,
		struct device_attribute *attr, char *buf)
{
	struct tsl2510_device_data *data = dev_get_drvdata(dev);
	ams_deviceCtx_t *ctx = data->deviceCtx;

	return snprintf(buf, PAGE_SIZE, "%d\n", ctx->deviceId);
}

static ssize_t tsl2510_i2c_err_show(struct device *dev,
		struct device_attribute *attr, char *buf)
{
	struct tsl2510_device_data *data = dev_get_drvdata(dev);
	u32 err_cnt = 0;

	err_cnt = data->i2c_err_cnt;

	return snprintf(buf, PAGE_SIZE, "%d\n", err_cnt);
}

static ssize_t tsl2510_i2c_err_store(struct device *dev,
		struct device_attribute *attr, const char *buf, size_t size)
{
	struct tsl2510_device_data *data = dev_get_drvdata(dev);

	data->i2c_err_cnt = 0;

	return size;
}

static ssize_t tsl2510_curr_adc_show(struct device *dev,
		struct device_attribute *attr, char *buf)
{
	struct tsl2510_device_data *data = dev_get_drvdata(dev);

	return snprintf(buf, PAGE_SIZE,
			"\"HRIC\":\"%d\",\"HRRC\":\"%d\",\"HRIA\":\"%d\",\"HRRA\":\"%d\"\n",
			0, 0, data->user_ir_data, data->user_flicker_data);
}

static ssize_t tsl2510_curr_adc_store(struct device *dev,
		struct device_attribute *attr, const char *buf, size_t size)
{
	struct tsl2510_device_data *data = dev_get_drvdata(dev);

	data->user_ir_data = 0;
	data->user_flicker_data = 0;

	return size;
}

static ssize_t tsl2510_mode_cnt_show(struct device *dev,
		struct device_attribute *attr, char *buf)
{
	struct tsl2510_device_data *data = dev_get_drvdata(dev);

	return snprintf(buf, PAGE_SIZE,
			"\"CNT_HRM\":\"%d\",\"CNT_AMB\":\"%d\",\"CNT_PROX\":\"%d\",\"CNT_SDK\":\"%d\",\"CNT_CGM\":\"%d\",\"CNT_UNKN\":\"%d\"\n",
			data->mode_cnt.hrm_cnt, data->mode_cnt.amb_cnt, data->mode_cnt.prox_cnt,
			data->mode_cnt.sdk_cnt, data->mode_cnt.cgm_cnt, data->mode_cnt.unkn_cnt);
}

static ssize_t tsl2510_mode_cnt_store(struct device *dev,
		struct device_attribute *attr, const char *buf, size_t size)
{
	struct tsl2510_device_data *data = dev_get_drvdata(dev);

	data->mode_cnt.hrm_cnt = 0;
	data->mode_cnt.amb_cnt = 0;
	data->mode_cnt.prox_cnt = 0;
	data->mode_cnt.sdk_cnt = 0;
	data->mode_cnt.cgm_cnt = 0;
	data->mode_cnt.unkn_cnt = 0;

	return size;
}

static ssize_t tsl2510_factory_cmd_show(struct device *dev,
		struct device_attribute *attr, char *buf)
{
	struct tsl2510_device_data *data = dev_get_drvdata(dev);
	static int cmd_result;

	mutex_lock(&data->activelock);

	if (data->isTrimmed)
		cmd_result = 1;
	else
		cmd_result = 0;

	ALS_dbg("%s - cmd_result = %d\n", __func__, cmd_result);

	mutex_unlock(&data->activelock);

	return snprintf(buf, PAGE_SIZE, "%d\n", cmd_result);
}

static ssize_t tsl2510_version_show(struct device *dev,
		struct device_attribute *attr, char *buf)
{
	ALS_info("%s - cmd_result = %s.%s.%s%s\n", __func__,
			VERSION, SUB_VERSION, HEADER_VERSION, VENDOR_VERSION);

	return snprintf(buf, PAGE_SIZE, "%s.%s.%s%s\n",
			VERSION, SUB_VERSION, HEADER_VERSION, VENDOR_VERSION);
}

static ssize_t tsl2510_sensor_info_show(struct device *dev,
		struct device_attribute *attr, char *buf)
{
	ALS_dbg("%s - sensor_info_data not support\n", __func__);

	return snprintf(buf, PAGE_SIZE, "NOT SUPPORT\n");
}

#if IS_ENABLED(CONFIG_SENSORS_FLICKER_SELF_TEST)
static struct result_data *eol_result = NULL;

static ssize_t tsl2510_eol_mode_show(struct device *dev,
		struct device_attribute *attr, char *buf)
{
	struct tsl2510_device_data *data = dev_get_drvdata(dev);

	if (data->eol_enabled) {
		snprintf(buf, MAX_TEST_RESULT, "EOL_RUNNING");
	} else if (eol_result == NULL) {
		snprintf(buf, MAX_TEST_RESULT, "NO_EOL_TEST");
	} else {
		snprintf(buf, MAX_TEST_RESULT, "%d, %s, %d, %s, %d, %s, %d, %s, %d, %s, %d, %s, %d, %s, %d, %s\n",
				eol_result->flicker[EOL_STATE_100], FREQ100_SPEC_IN(eol_result->flicker[EOL_STATE_100]),
				eol_result->flicker[EOL_STATE_120], FREQ120_SPEC_IN(eol_result->flicker[EOL_STATE_120]),
				eol_result->wideband[EOL_STATE_100], WIDE_SPEC_IN(eol_result->wideband[EOL_STATE_100]),
				eol_result->wideband[EOL_STATE_120], WIDE_SPEC_IN(eol_result->wideband[EOL_STATE_120]),
				eol_result->clear[EOL_STATE_100], CLEAR_SPEC_IN(eol_result->clear[EOL_STATE_100]),
				eol_result->clear[EOL_STATE_120], CLEAR_SPEC_IN(eol_result->clear[EOL_STATE_120]),
				eol_result->ratio[EOL_STATE_100], ICRATIO_SPEC_IN(eol_result->ratio[EOL_STATE_100]),
				eol_result->ratio[EOL_STATE_120], ICRATIO_SPEC_IN(eol_result->ratio[EOL_STATE_120]));

		eol_result = NULL;
	}
	ALS_dbg("%s", buf);

	return MAX_TEST_RESULT;
}

static ssize_t tsl2510_eol_mode_store(struct device *dev,
		struct device_attribute *attr, const char *buf, size_t size)
{
	struct tsl2510_device_data *data = dev_get_drvdata(dev);
	ams_deviceCtx_t *ctx = data->deviceCtx;
	int err = 0;
	static int prev_sensor_mode = 0, prev_state = 0;
	ssize_t ret = 0;

	data->eol_enabled = true;

	prev_sensor_mode = data->sensor_mode;
	data->sensor_mode = 0;

	if (data->regulator_state > 0) {
		ALS_dbg("%s - init sensor mode", __func__);
		prev_state = data->regulator_state;
		/* Initialize to set sensor mode CAMERA */
		while (data->regulator_state) {
			tsl2510_stop(data);
			if (err < 0)
				ALS_err("%s - err in stop", __func__);
		}
		while (data->regulator_state < prev_state) {
			tsl2510_start(data);
			if (err < 0)
				ALS_err("%s - err in start", __func__);
		}
	}

	err = tsl2510_start(data);

	AMS_AGC_DISABLE(err);					//AMS_SET_ALS_AUTOGAIN(LOW, err);
	if (err < 0) {
		ALS_err("%s - failed to disable AGC\n", __func__);
		goto gain_ctrl_failed;
	}

	AMS_SET_ALS_GAIN0(EOL_GAIN, err);
	if (err < 0) {
		ALS_err("%s - failed to AMS_SET_ALS_GAIN0\n", __func__);
		goto gain_ctrl_failed;
	}

	AMS_SET_ALS_GAIN1(EOL_GAIN, err);
	if (err < 0) {
		ALS_err("%s - failed to AMS_SET_ALS_GAIN1\n", __func__);
		goto gain_ctrl_failed;
	}
	ALS_dbg("%s - fixed ALS GAIN : %d\n", __func__, EOL_GAIN);

	als_eol_set_env(true, 80);
	eol_result = als_eol_mode();


	AMS_SET_ALS_GAIN0(ctx->ccbAlsCtx.initData.configData.gain, err);
	if (err < 0) {
		ALS_err("%s - failed to AMS_SET_ALS_GAIN0\n", __func__);
		goto gain_ctrl_failed;
	}

	AMS_SET_ALS_GAIN1(ctx->ccbAlsCtx.initData.configData.gain, err);
	if (err < 0) {
		ALS_err("%s - failed to AMS_SET_ALS_GAIN1\n", __func__);
		goto gain_ctrl_failed;
	}

	AMS_AGC_ENABLE(err);					 //AMS_SET_ALS_AUTOGAIN(LOW, err);
	if(err < 0){
		ALS_err("%s - failed to enable AGC", __func__);
		goto gain_ctrl_failed;
	}

	ret = size;

gain_ctrl_failed:

	err = tsl2510_stop(data);
	if (err < 0)
		ALS_err("%s - err in stop", __func__);

	data->sensor_mode = prev_sensor_mode;

	if (data->regulator_state > 0) {
		ALS_dbg("%s - init sensor mode", __func__);
		prev_state = data->regulator_state;
		/* Initialize to set sensor mode CAMERA */
		while (data->regulator_state) {
			err = tsl2510_stop(data);
			if (err < 0)
				ALS_err("%s - err in stop", __func__);
		}
		while (data->regulator_state < prev_state) {
			err = tsl2510_start(data);
			if (err < 0)
				ALS_err("%s - err in start", __func__);
		}
	}
	prev_state = 0;
	data->eol_enabled = false;

	return ret;
}
#endif

static DEVICE_ATTR(name, S_IRUGO, tsl2510_name_show, NULL);
static DEVICE_ATTR(vendor, S_IRUGO, tsl2510_vendor_show, NULL);
static DEVICE_ATTR(als_flush, S_IWUSR | S_IWGRP, NULL, tsl2510_flush_store);
static DEVICE_ATTR(int_pin_check, S_IRUGO, tsl2510_int_pin_check_show, NULL);
static DEVICE_ATTR(read_reg, S_IRUGO | S_IWUSR | S_IWGRP,
		tsl2510_read_reg_show, tsl2510_read_reg_store);
static DEVICE_ATTR(write_reg, S_IWUSR | S_IWGRP, NULL, tsl2510_write_reg_store);
static DEVICE_ATTR(als_debug, S_IRUGO | S_IWUSR | S_IWGRP,
		tsl2510_debug_show, tsl2510_debug_store);
static DEVICE_ATTR(device_id, S_IRUGO, tsl2510_device_id_show, NULL);
static DEVICE_ATTR(part_type, S_IRUGO, tsl2510_part_type_show, NULL);
static DEVICE_ATTR(i2c_err_cnt, S_IRUGO | S_IWUSR | S_IWGRP, tsl2510_i2c_err_show, tsl2510_i2c_err_store);
static DEVICE_ATTR(curr_adc, S_IRUGO | S_IWUSR | S_IWGRP, tsl2510_curr_adc_show, tsl2510_curr_adc_store);
static DEVICE_ATTR(mode_cnt, S_IRUGO | S_IWUSR | S_IWGRP, tsl2510_mode_cnt_show, tsl2510_mode_cnt_store);
static DEVICE_ATTR(als_factory_cmd, S_IRUGO, tsl2510_factory_cmd_show, NULL);
static DEVICE_ATTR(als_version, S_IRUGO, tsl2510_version_show, NULL);
static DEVICE_ATTR(sensor_info, S_IRUGO, tsl2510_sensor_info_show, NULL);
static DEVICE_ATTR(als_ir, S_IRUGO, als_ir_show, NULL);
static DEVICE_ATTR(als_clear, S_IRUGO, als_clear_show, NULL);
static DEVICE_ATTR(als_wideband, S_IRUGO, als_wideband_show, NULL);
static DEVICE_ATTR(als_raw_data, S_IRUGO, als_raw_data_show, NULL);
#if defined(CONFIG_AMS_OPTICAL_SENSOR_FLICKER)
static DEVICE_ATTR(flicker_data, S_IRUGO, flicker_data_show, NULL);
#endif
#if IS_ENABLED(CONFIG_SENSORS_FLICKER_SELF_TEST)
static DEVICE_ATTR(eol_mode, S_IRUGO | S_IWUSR | S_IWGRP, tsl2510_eol_mode_show, tsl2510_eol_mode_store);
#endif
#if defined(CONFIG_AMS_ALS_COMPENSATION_FOR_AUTO_BRIGHTNESS)
static DEVICE_ATTR(als_enable, S_IRUGO | S_IWUSR | S_IWGRP, tsl2510_als_enable_show, tsl2510_als_enable_store);
static DEVICE_ATTR(als_data, S_IRUGO, tsl2510_als_data_show, NULL);
#endif

static struct device_attribute *tsl2510_sensor_attrs[] = {
	&dev_attr_name,
	&dev_attr_vendor,
	&dev_attr_als_flush,
	&dev_attr_int_pin_check,
	&dev_attr_read_reg,
	&dev_attr_write_reg,
	&dev_attr_als_debug,
	&dev_attr_device_id,
	&dev_attr_part_type,
	&dev_attr_i2c_err_cnt,
	&dev_attr_curr_adc,
	&dev_attr_mode_cnt,
	&dev_attr_als_factory_cmd,
	&dev_attr_als_version,
	&dev_attr_sensor_info,
	&dev_attr_als_ir,
	&dev_attr_als_clear,
	&dev_attr_als_wideband,
	&dev_attr_als_raw_data,
#if defined(CONFIG_AMS_OPTICAL_SENSOR_FLICKER)
	&dev_attr_flicker_data,
#endif
#if IS_ENABLED(CONFIG_SENSORS_FLICKER_SELF_TEST)
	&dev_attr_eol_mode,
#endif
#if defined(CONFIG_AMS_ALS_COMPENSATION_FOR_AUTO_BRIGHTNESS)
	&dev_attr_als_enable,
	&dev_attr_als_data,
#endif
	NULL,
};
static int _2510_handleAlsEvent(ams_deviceCtx_t *ctx);
static void _2510_handleFIFOEvent(ams_deviceCtx_t *ctx);

static void _2510_handleFIFOEvent(ams_deviceCtx_t *ctx)
{
	int err =0;
	int clear_gain;
	int wideband_gain;
	int fifo_mod0_gain;
	int fifo_mod1_gain;
	amsAlsDataSet_t inputData;
	adcDataSet_t dataSet;

	inputData.status = ALS_STATUS_RDY;
	inputData.datasetArray = (alsData_t *)&dataSet;

	ccb_FIFOEvent(ctx);

	if(ctx->flickerCtx.data_ready == 1) {
		AMS_ENABLE_PON(err);
		if (err < 0) {
			ALS_err("%s - failed to AMS_ENABLE_PON\n", __func__);
		}

		ccb_sw_bin4096_flicker_GetResult(ctx);

#ifndef USE_GET_FIFO_ALS
		dataSet.AdcClear = ctx->clear_average;
		dataSet.AdcWb = ctx->wideband_average;
		fifo_mod0_gain = ctx->fifo_mod0_gain & 0x0F;//clear
		fifo_mod1_gain = (ctx->fifo_mod0_gain >> 4) & 0x0F;//wide

		if (fifo_mod0_gain >= (sizeof(tsl2510_gain_conversion) / sizeof(uint16_t))) {
			clear_gain = tsl2510_gain_conversion[0] * 500;
			ALS_err("set default clear_gain = %d (mod0_gain = 0x%x, gain_table size = %d)", clear_gain, ctx->fifo_mod0_gain, (sizeof(tsl2510_gain_conversion) / sizeof(uint16_t)));
		} else {
			clear_gain = tsl2510_gain_conversion[fifo_mod0_gain] * 500;
		}

		if (fifo_mod1_gain >= (sizeof(tsl2510_gain_conversion) / sizeof(uint16_t))) {
			wideband_gain = tsl2510_gain_conversion[0] * 500;
			ALS_err("set default wideband_gain = %d (mod1_gain = 0x%x, gain_table size = %d)", wideband_gain, (ctx->fifo_mod0_gain >> 4), (sizeof(tsl2510_gain_conversion) / sizeof(uint16_t)));
		} else {
			wideband_gain = tsl2510_gain_conversion[fifo_mod1_gain] * 500;
		}

		ctx->ccbAlsCtx.ctxAlgAls.ClearGain = clear_gain;
		ctx->ccbAlsCtx.ctxAlgAls.WBGain = wideband_gain;
		amsAlg_als_processData(&ctx->ccbAlsCtx.ctxAlgAls, &inputData);
		//ctx->flickerCtx.als_data_ready = 1;
#endif
		ctx->updateAvailable |= (1 << AMS_SW_FLICKER_SENSOR);        /* request from IQ team. als_data & flicker_data should be reported as quickly as possible */

		//AMS_REENABLE_FD_PON(err);
		AMS_REENABLE(err);
		if (err < 0) {
			ALS_err("%s - failed to AMS_REENABLE_FD_PON\n", __func__);
		}
	} else if(ctx->flickerCtx.als_data_ready == 1) {
		ctx->updateAvailable |= (1 << AMS_AMBIENT_SENSOR);
	}
}

static int ams_devicePollingHandler(ams_deviceCtx_t *ctx)
{
	int ret = 0;
	ret = ams_getByte(ctx->portHndl, DEVREG_STATUS2, &ctx->shadowStatus2Reg);

	if (ret < 0) {
		ALS_err("%s - failed to get DEVREG_STATUS\n", __func__);
		return ret;
	}

	// _2510_handleFIFOEvent(ctx);

	if ((ctx->shadowStatus2Reg & ALS_DATA_VALID) /*|| ctx->alwaysReadAls*/) {
		ret = ams_getByte(ctx->portHndl, DEVREG_ALS_STATUS, &ctx->shadowAlsStatusReg);
		if (ret < 0) {
			ALS_err("%s - failed to get DEVREG_ALS_STATUS\n", __func__);
			return ret;
		}

		ret = ams_getByte(ctx->portHndl, DEVREG_ALS_STATUS2, &ctx->shadowAlsStatus2Reg);
		if (ret < 0) {
			ALS_err("%s - failed to get DEVREG_ALS_STATUS2\n", __func__);
			return ret;
		}

		if (ctx->mode & MODE_ALS_ALL) {
			ALS_info("%s - _2510_handleAlsEvent :%d alwaysReadAls = %d\n", __func__, (ctx->shadowStatus1Reg & AINT), ctx->alwaysReadAls);
			ret = _2510_handleAlsEvent(ctx);
			if (ret < 0) {
				ALS_err("%s - failed to _2510_handleAlsEvent\n", __func__);
				//return ret;
			}
		}
	}
	return 0;
}


static int ams_deviceEventHandler(ams_deviceCtx_t *ctx)
{
	int ret = 0;
	uint8_t status5 = 0;

	ret = ams_getByte(ctx->portHndl, DEVREG_STATUS, &ctx->shadowStatus1Reg);

	if (ret < 0) {
		ALS_err("%s - failed to get DEVREG_STATUS\n", __func__);
		return ret;
	}

	ret = ams_getByte(ctx->portHndl, DEVREG_STATUS2, &ctx->shadowStatus2Reg);
	//ret = ams_getByte(ctx->portHndl, DEVREG_MEAS_SEQR_STEP0_MOD_GAINX_L, &ctx->fifo_mod0_gain);
	//ret = ams_getByte(ctx->portHndl, DEVREG_MOD_GAIN_H, &ctx->fifo_mod1_gain);

	//clear_gain = tsl2510_gain_conversion[ctx->fifo_mod0_gain];
	//wideband_gain = tsl2510_gain_conversion[ctx->fifo_mod1_gain];


	if (ret < 0) {
		ALS_err("%s - failed to get DEVREG_STATUS\n", __func__);
		return ret;
	}

	if (ctx->shadowStatus1Reg & SINT) {
		ret = ams_getByte(ctx->portHndl, DEVREG_STATUS5, &status5);
		if (ret < 0) {
			ALS_err("%s - failed to get DEVREG_STATUS5\n", __func__);
			return ret;
		}
		ALS_info("%s - ctx->shadowStatus1Reg %x, status5 %x, mode %x", __func__, ctx->shadowStatus1Reg, status5, ctx->mode);
	}

loop:
	ALS_info("%s - loop: DCB 0x%02x, STATUS 0x%02x, ALS_STATUS 0x%02x, ALS_STATUS2 0x%02x\n", __func__, ctx->mode, ctx->shadowStatus1Reg, ctx->shadowAlsStatusReg, ctx->shadowAlsStatus2Reg);


#if defined(CONFIG_AMS_OPTICAL_SENSOR_FLICKER)
	if (ctx->shadowStatus1Reg & FINT) {
		ret = ams_getByte(ctx->portHndl, DEVREG_FIFO_STATUS0, &ctx->shadowFIFOStatusReg);
		if (ret < 0) {
			ALS_err("%s - failed to get DEVREG_FIFO_STATUS0\n", __func__);
			//return ret;
		}
		if (ctx->mode & MODE_FLICKER) {
			ALS_info("%s - _2510_handleFIFOEvent \n", __func__);
			_2510_handleFIFOEvent(ctx);
		}
	}
#endif

	//if ((ctx->shadowStatus1Reg & AINT) /*|| ctx->alwaysReadAls*/) {
	if ((ctx->shadowStatus2Reg & ALS_DATA_VALID) /*|| ctx->alwaysReadAls*/) {
		ret = ams_getByte(ctx->portHndl, DEVREG_ALS_STATUS, &ctx->shadowAlsStatusReg);
		if (ret < 0) {
			ALS_err("%s - failed to get DEVREG_ALS_STATUS\n", __func__);
			return ret;
		}
		ret = ams_getByte(ctx->portHndl, DEVREG_ALS_STATUS2, &ctx->shadowAlsStatus2Reg);
		if (ret < 0) {
			ALS_err("%s - failed to get DEVREG_ALS_STATUS2\n", __func__);
			return ret;
		}
		if (ctx->mode & MODE_ALS_ALL) {
			ALS_info("%s - _2510_handleAlsEvent :%d alwaysReadAls = %d\n", __func__, (ctx->shadowStatus1Reg & AINT), ctx->alwaysReadAls);
			ret = _2510_handleAlsEvent(ctx);
			if (ret < 0) {
				ALS_err("%s - failed to _2510_handleAlsEvent\n", __func__);
				//return ret;
			}
		}
	}

	/* Clear Processed Interrupt */
	/* this clears interrupt(s) and STATUS5 */
	if (ctx->shadowStatus1Reg != 0) {
		/* this clears interrupt(s) and STATUS5 */
		ret = ams_setByte(ctx->portHndl, DEVREG_STATUS, ctx->shadowStatus1Reg);
		if (ret < 0) {
			ALS_err("%s - failed to set DEVREG_STATUS\n", __func__);
			return ret;
		}
	}

	if (status5 != 0) {
		ret = ams_setByte(ctx->portHndl, DEVREG_STATUS5, status5);
		if (ret < 0) {
			ALS_err("%s - failed to set DEVREG_STATUS5\n", __func__);
			return ret;
		}
	}

	/* Check Remainning Interrupt */
	ret = ams_getByte(ctx->portHndl, DEVREG_STATUS, &ctx->shadowStatus1Reg);
	if (ret < 0) {
		ALS_err("%s - failed to get DEVREG_STATUS\n", __func__);
		return ret;
	}
	if (ctx->shadowStatus1Reg != 0) {
		ALS_err("%s - goto loop", __func__);
		goto loop;
	}

	/*
	 *	the individual handlers may have temporarily disabled things
	 *	AMS_REENABLE(ret);
	 *	if (ret < 0) {
	 *		ALS_err("%s - failed to AMS_REENABLE\n", __func__);
	 *		return ret;
	 *	}
	 */
	return ret;
}

irqreturn_t tsl2510_irq_handler(int dev_irq, void *device)
{
	int err;
	struct tsl2510_device_data *data = device;
	int interruptsHandled = 0;

	ALS_info("%s - als_irq = %d\n", __func__, dev_irq);

	if (data->regulator_state == 0) {
		ALS_dbg("%s - stop irq handler (reg_state : %d, enabled : %d)\n",
				__func__, data->regulator_state, data->enabled);
		return IRQ_HANDLED;
	} else if (data->enabled == 0) {
		ALS_dbg("%s - ALS not enabled, clear irq (regulator_state : %d, enabled : %d)",
				__func__, data->regulator_state, data->enabled);
		ams_setByte(data->client, DEVREG_STATUS, AMS_ALL_INT);
		return IRQ_HANDLED;
	}

	//mutex_lock(&data->activelock);

	err = ams_deviceEventHandler(data->deviceCtx);
	interruptsHandled = ams_getResult(data->deviceCtx);

	if (err == 0) {
		if (data->als_input_dev == NULL) {
			ALS_err("%s - als_input_dev is NULL\n", __func__);
		}
		else {
#if defined(CONFIG_AMS_OPTICAL_SENSOR_ALS)
			if (interruptsHandled & (1 << AMS_AMBIENT_SENSOR))
				report_als(data);
#endif

#if defined(CONFIG_AMS_OPTICAL_SENSOR_FLICKER)
			if (interruptsHandled & (1 << AMS_FLICKER_SENSOR))
				report_flicker(data);

			if (interruptsHandled & (1 << AMS_SW_FLICKER_SENSOR)) {
#ifndef USE_GET_FIFO_ALS
				report_als(data);
				msleep_interruptible(30);
				/* HwModuleTest need this delay to distinguish ALS / Flicker */
#endif
				report_flicker(data);
			}
#endif
		}
	}
	else {
		ALS_err("%s - ams_deviceEventHandler failed\n", __func__);
	}

	//mutex_unlock(&data->activelock);

	return IRQ_HANDLED;
}

#if defined(CONFIG_AMS_OPTICAL_SENSOR_POLLING)
static void tsl2510_work_func_light(struct work_struct *work)
{
	int err;
	//    int lux;
	int pollingHandled = 0;

	struct tsl2510_device_data *data
		= container_of(work, struct tsl2510_device_data, work_light);
	ALS_info("%s -msec \n", __func__);

	// testing
	//return 0;
	if (data->regulator_state == 0 || data->enabled == 0) {
		ALS_dbg("%s - stop irq handler (reg_state : %d, enabled : %d)\n",
				__func__, data->regulator_state, data->enabled);

		ams_setByte(data->client, DEVREG_STATUS, (AINT | AMS_ALL_INT));
	}

	mutex_lock(&data->flickerdatalock);

	err = ams_devicePollingHandler(data->deviceCtx);
	pollingHandled = ams_getResult(data->deviceCtx);

	if (err == 0) {
		if (data->als_input_dev == NULL) {
			ALS_err("%s - als_input_dev is NULL\n", __func__);
		} else {
#if defined(CONFIG_AMS_OPTICAL_SENSOR_ALS)
			if (pollingHandled & (1 << AMS_AMBIENT_SENSOR)) {
				report_als(data);
			}
#endif

#if defined(CONFIG_AMS_OPTICAL_SENSOR_FLICKER)
			if (pollingHandled & (1 << AMS_FLICKER_SENSOR))
				report_flicker(data);
#endif
		}
	} else {
		ALS_err("%s - ams_deviceEventHandler failed\n", __func__);
	}

	mutex_unlock(&data->flickerdatalock);
}

static enum hrtimer_restart tsl2510_timer_func(struct hrtimer *timer)
{
	struct tsl2510_device_data *data = container_of(timer, struct tsl2510_device_data, timer);
	queue_work(data->wq, &data->work_light);
	hrtimer_forward_now(&data->timer, data->light_poll_delay);
	return HRTIMER_RESTART;
}
#endif

static int tsl2510_setup_irq(struct tsl2510_device_data *data)
{
	int errorno = -EIO;
	errorno = request_threaded_irq(data->dev_irq, NULL,
			tsl2510_irq_handler, IRQF_TRIGGER_FALLING | IRQF_ONESHOT,
			"als_rear_sensor_irq", data);

	if (errorno < 0) {
		ALS_err("%s - failed for setup dev_irq errono= %d\n",
				__func__, errorno);
		errorno = -ENODEV;
		return errorno;
	}

	disable_irq(data->dev_irq);

	return errorno;
}

static void tsl2510_init_var(struct tsl2510_device_data *data)
{
	data->client = NULL;
	data->dev = NULL;
	data->als_input_dev = NULL;
	data->als_pinctrl = NULL;
	data->pins_sleep = NULL;
	data->pins_active = NULL;
	data->enabled = 0;
	data->sampling_period_ns = 0;
	data->regulator_state = 0;
	data->regulator_vbus_1p8 = NULL;
	data->regulator_vdd_1p8 = NULL;
	data->vbus_1p8_enable = false;
	data->vdd_1p8_enable = false;
	data->irq_state = 0;
	data->suspend_cnt = 0;
	data->reg_read_buf = 0;
	data->pm_state = PM_RESUME;
	data->i2c_err_cnt = 0;
	data->user_ir_data = 0;
	data->user_flicker_data = 0;
	data->awb_sample_cnt = 0;
	data->flicker_data_cnt = 0;
	//flicker_data_cnt = 0;
	data->saturation = false;
	data->timer_is_exist = false;
	data->timer_is_active = false;
#if defined(CONFIG_AMS_ALS_COMPENSATION_FOR_AUTO_BRIGHTNESS)
	data->als_flag = 0;
#endif
}

static int tsl2510_parse_dt(struct tsl2510_device_data *data)
{
	struct device *dev = &data->client->dev;
	struct device_node *dNode = dev->of_node;
	struct device_node *vbus_of_node = NULL;
	struct device_node *vdd_of_node = NULL;
#if IS_ENABLED(CONFIG_OF)
	enum of_gpio_flags flags;

	if (dNode == NULL)
		return -ENODEV;

	data->pin_als_int = of_get_named_gpio_flags(dNode, "als_rear,irq-gpio", 0, &flags);
	if (data->pin_als_int < 0) {
		ALS_err("%s - get als_rear_int error\n", __func__);
		return -ENODEV;
	}
#endif 	/* CONFIG_OF */

	vbus_of_node = of_parse_phandle(dNode, "vbus_1p8-supply", 0);
	if (vbus_of_node) {
		data->regulator_vbus_1p8 = regulator_get(&data->client->dev, "vbus_1p8");
		if (IS_ERR(data->regulator_vbus_1p8) || data->regulator_vbus_1p8 == NULL) {
			ALS_err("%s - get vbus_1p8 regulator failed\n", __func__);
			data->regulator_vbus_1p8 = NULL;
		} else {
			ALS_dbg("%s - get vbus_1p8 regulator = %p done \n", __func__, data->regulator_vbus_1p8);
		}
	} else {
		ALS_err("%s - get vbus_1p8 regulator failed\n", __func__);
		data->regulator_vbus_1p8 = NULL;
	}

	vdd_of_node = of_parse_phandle(dNode, "vdd_1p8-supply", 0);
	if (vdd_of_node) {
		data->regulator_vdd_1p8 = regulator_get(&data->client->dev, "vdd_1p8");
		if (IS_ERR(data->regulator_vdd_1p8) || data->regulator_vdd_1p8 == NULL) {
			ALS_err("%s - get vdd_1p8 regulator failed\n", __func__);
			data->regulator_vdd_1p8 = NULL;
			return -ENODEV;
		} else {
			ALS_dbg("%s - get vdd_1p8 regulator = %p done \n", __func__, data->regulator_vdd_1p8);
		}
	} else {
		ALS_err("%s - get vdd_1p8 regulator failed\n", __func__);
		data->regulator_vdd_1p8 = NULL;
	}

	data->als_pinctrl = devm_pinctrl_get(dev);
	if (IS_ERR_OR_NULL(data->als_pinctrl)) {
		ALS_err("%s - get pinctrl(%li) error\n",
				__func__, PTR_ERR(data->als_pinctrl));
		data->als_pinctrl = NULL;
		return -EINVAL;
	}

	data->pins_sleep = pinctrl_lookup_state(data->als_pinctrl, "sleep");
	if (IS_ERR_OR_NULL(data->pins_sleep)) {
		ALS_err("%s - get pins_sleep(%li) error\n",
				__func__, PTR_ERR(data->pins_sleep));
		devm_pinctrl_put(data->als_pinctrl);
		data->pins_sleep = NULL;
		return -EINVAL;
	}

	data->pins_active = pinctrl_lookup_state(data->als_pinctrl, "active");
	if (IS_ERR_OR_NULL(data->pins_active)) {
		ALS_err("%s - get pins_active(%li) error\n",
				__func__, PTR_ERR(data->pins_active));

		devm_pinctrl_put(data->als_pinctrl);
		data->pins_active = NULL;
		return -EINVAL;
	}

	ALS_dbg("%s - done.\n", __func__);

	return 0;
}

static int tsl2510_setup_gpio(struct tsl2510_device_data *data)
{
	int errorno = -EIO;

	errorno = gpio_request(data->pin_als_int, "als_rear_int");
	if (errorno) {
		ALS_err("%s - failed to request als_int\n", __func__);
		return errorno;
	}

	errorno = gpio_direction_input(data->pin_als_int);
	if (errorno) {
		ALS_err("%s - failed to set als_int as input\n", __func__);
		goto err_gpio_direction_input;
	}
	data->dev_irq = gpio_to_irq(data->pin_als_int);

	goto done;

err_gpio_direction_input:
	gpio_free(data->pin_als_int);
done:
	return errorno;
}

static int _2510_alsInit(ams_deviceCtx_t *ctx, ams_calibrationData_t *calibrationData)
{
	int ret = 0;

	if (calibrationData == NULL) {
		ams_ccb_als_info_t infoData;

		ALS_info("%s - calibrationData is null\n", __func__);
		ccb_alsInfo(&infoData);
		ctx->ccbAlsCtx.initData.calibrationData.calibrationFactor = infoData.defaultCalibrationData.calibrationFactor;
		ctx->ccbAlsCtx.initData.calibrationData.Time_base = infoData.defaultCalibrationData.Time_base;
		ctx->ccbAlsCtx.initData.calibrationData.thresholdLow = infoData.defaultCalibrationData.thresholdLow;
		ctx->ccbAlsCtx.initData.calibrationData.thresholdHigh = infoData.defaultCalibrationData.thresholdHigh;
		ctx->ccbAlsCtx.initData.calibrationData.calibrationFactor = infoData.defaultCalibrationData.calibrationFactor;
	}
	else {
		ALS_info("%s - calibrationData is non-null\n", __func__);
		//ctx->ccbAlsCtx.initData.calibrationData.luxTarget = calibrationData->alsCalibrationLuxTarget;
		//ctx->ccbAlsCtx.initData.calibrationData.luxTargetError = calibrationData->alsCalibrationLuxTargetError;
		ctx->ccbAlsCtx.initData.calibrationData.calibrationFactor = calibrationData->alsCalibrationFactor;
		ctx->ccbAlsCtx.initData.calibrationData.Time_base = calibrationData->timeBase_us;
		ctx->ccbAlsCtx.initData.calibrationData.thresholdLow = calibrationData->alsThresholdLow;
		ctx->ccbAlsCtx.initData.calibrationData.thresholdHigh = calibrationData->alsThresholdHigh;
	}
	ctx->ccbAlsCtx.initData.calibrate = false;
	//ctx->ccbAlsCtx.initData.configData.gain = 64000;//AGAIN
	ctx->ccbAlsCtx.initData.configData.gain = 16000;//AGAIN
	ctx->ccbAlsCtx.initData.configData.uSecTime = AMS_ALS_ATIME; /*ALS Inegration time 50msec*/

	ctx->alwaysReadAls = false;
	ctx->alwaysReadFlicker = false;
	ctx->ccbAlsCtx.initData.autoGain = true; //AutoGainCtrol on
	ctx->ccbAlsCtx.initData.hysteresis = 0x02; /*Lower threshold for adata in AGC */
	return ret;
}

static bool ams_deviceGetAls(ams_deviceCtx_t *ctx, ams_apiAls_t *exportData)
{
	ams_ccb_als_result_t result;

	ccb_alsGetResult(ctx, &result);
	exportData->clear = result.clear;
	exportData->ir = result.ir;
	exportData->time_us = result.time_us;
	exportData->ClearGain = result.ClearGain;
	exportData->WBGain = result.WBGain;

	exportData->wideband    = result.wideband;
	exportData->rawClear = result.rawClear;
	exportData->rawWideband = result.rawWideband;
	return false;
}

static int _2510_handleAlsEvent(ams_deviceCtx_t *ctx)
{
	int ret = 0;
	ams_ccb_als_dataSet_t ccbAlsData;

	ccbAlsData.statusReg = ctx->shadowStatus1Reg;
	ccbAlsData.status2Reg = ctx->shadowStatus2Reg;
	ccbAlsData.alsstatusReg = ctx->shadowAlsStatusReg;
	ccbAlsData.alsstatus2Reg = ctx->shadowAlsStatus2Reg;

	ret = ccb_alsHandle(ctx, &ccbAlsData);

	return ret;
}

static bool ams_deviceGetFlicker(ams_deviceCtx_t *ctx, ams_apiAlsFlicker_t *exportData)
{
	ams_flicker_ctx_t *flickerCtx = (ams_flicker_ctx_t *)&ctx->flickerCtx;

	exportData->mHz = flickerCtx->frequency;
	return false;
}

static int ams_deviceSoftReset(ams_deviceCtx_t *ctx)
{
	int err = 0;

	ALS_dbg("%s - Start\n", __func__);

	// Before S/W reset, the PON has to be asserted
	err = ams_setByte(ctx->portHndl, DEVREG_ENABLE, PON);
	if (err < 0) {
		ALS_err("%s - failed to set DEVREG_ENABLE\n", __func__);
		return err;
	}

	err = ams_setField(ctx->portHndl, DEVREG_CONTROL, HIGH, MASK_SOFT_RESET);
	if (err < 0) {
		ALS_err("%s - failed to set DEVREG_SOFT_RESET\n", __func__);
		return err;
	}
	// Need 1 msec delay
	usleep_range(1000, 1100);

	// Recover the previous enable setting
	err = ams_setByte(ctx->portHndl, DEVREG_ENABLE, ctx->shadowEnableReg);
	if (err < 0) {
		ALS_err("%s - failed to set DEVREG_ENABLE\n", __func__);
		return err;
	}

	return err;
}

static ams_deviceIdentifier_e ams_validateDevice(AMS_PORT_portHndl *portHndl)
{
	uint8_t chipId;
	uint8_t revId;
	uint8_t auxId = 0;
	uint8_t i = 0;
	int err = 0;

	struct tsl2510_device_data *data = i2c_get_clientdata(portHndl);

	err = ams_getByte(portHndl, DEVREG_ID, &chipId);
	if (err < 0) {
		ALS_err("%s - failed to get DEVREG_ID\n", __func__);
		return AMS_UNKNOWN_DEVICE;
	}
	err = ams_getByte(portHndl, DEVREG_REVID, &revId);
	if (err < 0) {
		ALS_err("%s - failed to get DEVREG_REVID\n", __func__);
		return AMS_UNKNOWN_DEVICE;
	}
	err = ams_getByte(portHndl, DEVREG_AUXID, &auxId);
	if (err < 0) {
		ALS_err("%s - failed to get DEVREG_AUXID\n", __func__);
		return AMS_UNKNOWN_DEVICE;
	}
	ALS_dbg("%s - ID:0x%02x, revID:0x%02x, auxID:0x%02x\n", __func__, chipId, revId, auxId);

	if ((revId & 0x10) == 0x10)
		data->isTrimmed = 1;
	else
		data->isTrimmed = 0;

	do {
		if (((chipId & deviceIdentifier[i].deviceIdMask) ==
					(deviceIdentifier[i].deviceId & deviceIdentifier[i].deviceIdMask)) &&
				((revId & deviceIdentifier[i].deviceRefMask) >=
				 (deviceIdentifier[i].deviceRef & deviceIdentifier[i].deviceRefMask))) {

			return deviceIdentifier[i].device;
		}
		i++;
	} while (deviceIdentifier[i].device != AMS_LAST_DEVICE);

	return AMS_UNKNOWN_DEVICE;
}

static int ams_deviceInit(ams_deviceCtx_t *ctx, AMS_PORT_portHndl *portHndl, ams_calibrationData_t *calibrationData)
{
	int ret = 0;

	ctx->portHndl = portHndl;
	ctx->mode = MODE_OFF;
	ctx->systemCalibrationData = calibrationData;
	ctx->deviceId = ams_validateDevice(ctx->portHndl);
	ctx->shadowEnableReg = deviceRegisterDefinition[DEVREG_ENABLE].resetValue;
	ctx->agc = true;

	ret = ams_deviceSoftReset(ctx);
	if (ret < 0) {
		ALS_err("%s - failed to ams_deviceSoftReset\n", __func__);
		return ret;
	}

	AMS_SET_SAMPLE_TIME(AMS_SAMPLING_TIME, ret);
	if (ret < 0) {
		ALS_err("%s - failed to Sample time \n", __func__);
		return ret;
	}

	if (ctx->agc)
	{

		// AGC ASAT MODE
		AMS_AGC_ASAT_MODE(HIGH, ret);
		if (ret < 0) {
			ALS_err("%s - failed to set AGC ASAT MODE\n", __func__);
			return ret;
		}
		// AGC PREDIC  MODE
		AMS_AGC_PREDICT_MODE(HIGH, ret);
		if (ret < 0) {
			ALS_err("%s - failed to set AGC PREDIC  MODE\n", __func__);
			return ret;
		}

		AMS_AGC_ENABLE(ret);
		if (ret < 0) {
			ALS_err("%s - failed to set AGC ENABLE\n", __func__);
			return ret;
		}


		// SET AGC MAX GAIN
		AMS_SET_AGC_MAX_GAIN(AMS_AGC_MAX_GAIN, ret);
		if (ret < 0) {
			ALS_err("%s - failed to set SET AGC MAX GAIN\n", __func__);
			return ret;
		}

		// AGC Number of samples
		AMS_SET_AGC_NR_SAMPLES(AMS_AGC_NUM_SAMPLES, ret);
		if (ret < 0) {
			ALS_err("%s - failed to set AGC Number of samples\n", __func__);
			return ret;
		}
		//ams_setByte(ctx->portHndl, DEVREG_AGC_NR_SAMPLES_LO, 0x13);

	}

#if defined(CONFIG_AMS_OPTICAL_SENSOR_ALS_CCB)
	ret = _2510_alsInit(ctx, calibrationData);
	if (ret < 0) {
		ALS_err("%s - failed to _2510_alsInit\n", __func__);
		return ret;
	}
#endif

	return ret;
}

static bool ams_getDeviceInfo(ams_deviceInfo_t *info, ams_deviceIdentifier_e deviceId)
{
	memset(info, 0, sizeof(ams_deviceInfo_t));

	info->defaultCalibrationData.timeBase_us = AMS_USEC_PER_TICK;
	info->numberOfSubSensors = 0;
	info->memorySize = sizeof(ams_deviceCtx_t);

	switch (deviceId) {
		case AMS_TSL2510:
		case AMS_TSL2510_UNTRIM:
			info->deviceModel = "TSL2510";
			break;
		default:
			info->deviceModel = "UNKNOWN";
			break;
	}

	memcpy(info->defaultCalibrationData.deviceName, info->deviceModel, sizeof(info->defaultCalibrationData.deviceName));
	info->deviceName = "ALS/PRX/FLKR";
	info->driverVersion = "Alpha";
#if defined(CONFIG_AMS_OPTICAL_SENSOR_ALS_CCB)
	{
		/* TODO */
		ams_ccb_als_info_t infoData;

		ccb_alsInfo(&infoData);
		info->tableSubSensors[info->numberOfSubSensors] = AMS_AMBIENT_SENSOR;
		info->numberOfSubSensors++;

		info->alsSensor.driverName = infoData.algName;
		info->alsSensor.adcBits = 8;
		info->alsSensor.maxPolRate = 50;
		info->alsSensor.activeCurrent_uA = 100;
		info->alsSensor.standbyCurrent_uA = 5;
		info->alsSensor.rangeMax = 1;
		info->alsSensor.rangeMin = 0;

		info->defaultCalibrationData.alsCalibrationFactor = infoData.defaultCalibrationData.calibrationFactor;
		//		info->defaultCalibrationData.alsCalibrationLuxTarget = infoData.defaultCalibrationData.luxTarget;
		//		info->defaultCalibrationData.alsCalibrationLuxTargetError = infoData.defaultCalibrationData.luxTargetError;
#if defined(CONFIG_AMS_ALS_CRWBI) || defined(CONFIG_AMS_ALS_CRGBW)
		info->tableSubSensors[info->numberOfSubSensors] = AMS_WIDEBAND_ALS_SENSOR;
		info->numberOfSubSensors++;
#endif
	}
#endif
	return false;
}


static void fifo_work_cb(struct work_struct *work)
{
	struct fifo_chip *fifo = NULL;

	if (work) {
		fifo = container_of(work, struct fifo_chip, work);
	}
}

static int tsl2510_init_fifo(struct tsl2510_device_data *data)
{
	static struct fifo_chip fifo;

	memset(&fifo, 0, sizeof(struct fifo_chip));

	//fifo.callbacks.irq = fifo_irq;
	//data->fifo = &fifo.work;
	fifo.data = data;
	init_waitqueue_head(&data->fifo_wait);
	//if (init_fifo_device_tree(chip)) {
	//fifo_reset(chip);
	INIT_WORK(&fifo.work, fifo_work_cb);
	INIT_KFIFO(ams_fifo);
	//enable_fifo(chip, FIFO_OFF);
	//if (sysfs_create_groups(&chip->input->dev.kobj, fifo_groups)) {
	//    dev_err(&chip->input->dev, "Error creating sysfs attribute group.\n");
	//}
	//}
	return 0;
}

int tsl2510_probe(struct i2c_client *client, const struct i2c_device_id *id)
{
	int err = -ENODEV;
	struct device *dev = &client->dev;
	static struct tsl2510_device_data *data;
	struct amsdriver_i2c_platform_data *pdata = dev->platform_data;
	ams_deviceInfo_t amsDeviceInfo;
	ams_deviceIdentifier_e deviceId;

	ALS_dbg("%s - start\n", __func__);
	printk(KERN_ERR "\nams_tsl2510: tsl2510_probe() client->irq= %d\n", client->irq);

	/* check to make sure that the adapter supports I2C */
	if (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) {
		ALS_err("%s - I2C_FUNC_I2C not supported\n", __func__);
		return -ENODEV;
	}
	/* allocate some memory for the device */
	data = devm_kzalloc(dev, sizeof(struct tsl2510_device_data), GFP_KERNEL);
	if (data == NULL) {
		ALS_err("%s - couldn't allocate device data memory\n", __func__);
		return -ENOMEM;
	}

	data->flicker_data = devm_kzalloc(dev, sizeof(int16_t)*AMS_FFT_SIZE, GFP_KERNEL);
	if (data == NULL) {
		ALS_err("%s - couldn't allocate device flicker_data memory\n", __func__);
		return -ENOMEM;
	}

	tsl2510_data = data;
	tsl2510_init_var(data);

	if (!pdata) {
		pdata = devm_kzalloc(dev, sizeof(struct amsdriver_i2c_platform_data),
				GFP_KERNEL);
		if (pdata == NULL) {
			ALS_err("%s - couldn't allocate device pdata memory\n", __func__);
			goto err_malloc_pdata;
		}
#if IS_ENABLED(CONFIG_OF)
		if (of_match_device(tsl2510_match_table, &client->dev))
			pdata->of_node = client->dev.of_node;
#endif
	}

	data->client = client;
	data->miscdev.minor = MISC_DYNAMIC_MINOR;
	data->miscdev.name = MODULE_NAME_ALS;
	data->miscdev.fops = &tsl2510_fops;
	data->miscdev.mode = S_IRUGO;
	data->pdata = pdata;
	i2c_set_clientdata(client, data);
	ALS_info("%s client = %p\n", __func__, client);

	err = misc_register(&data->miscdev);
	if (err < 0) {
		ALS_err("%s - failed to misc device register\n", __func__);
		goto err_misc_register;
	}
	mutex_init(&data->i2clock);
	mutex_init(&data->activelock);
	mutex_init(&data->suspendlock);
	mutex_init(&data->flickerdatalock);

	err = tsl2510_parse_dt(data);
	if (err < 0) {
		ALS_err("%s - failed to parse dt\n", __func__);
		err = -ENODEV;
		goto err_parse_dt;
	}

	err = tsl2510_setup_gpio(data);
	if (err) {
		ALS_err("%s - failed to setup gpio\n", __func__);
		goto err_setup_gpio;
	}

	err = tsl2510_power_ctrl(data, PWR_ON);
	if (err < 0) {
		ALS_err("%s - failed to power on ctrl\n", __func__);
		goto err_power_on;
	}
	if (data->client->addr == TSL2510_SLAVE_I2C_ADDR_REVID_V0) {
		ALS_dbg("%s - slave address is REVID_V0\n", __func__);
	}
	else if (data->client->addr == TSL2510_SLAVE_I2C_ADDR_REVID_V1) {
		ALS_dbg("%s - slave address is REVID_V1\n", __func__);
	}
	else {
		err = -EIO;
		ALS_err("%s - slave address error, 0x%02x\n", __func__, data->client->addr);
		goto err_init_fail;
	}

	/********************************************************************/
	/* Validate the appropriate ams device is available for this driver */
	/********************************************************************/
	deviceId = ams_validateDevice(data->client);

	if (deviceId == AMS_UNKNOWN_DEVICE) {
		ALS_err("%s - ams_validateDevice failed: AMS_UNKNOWN_DEVICE\n", __func__);
		err = -EIO;
		goto err_id_failed;
	}
	ALS_dbg("%s - deviceId: %d\n", __func__, deviceId);

	ams_getDeviceInfo(&amsDeviceInfo, deviceId);
	ALS_dbg("%s - name: %s, model: %s, driver ver:%s\n", __func__,
			amsDeviceInfo.deviceName, amsDeviceInfo.deviceModel, amsDeviceInfo.driverVersion);

	data->deviceCtx = devm_kzalloc(dev, amsDeviceInfo.memorySize, GFP_KERNEL);
	if (data->deviceCtx == NULL) {
		ALS_err("%s - couldn't allocate device deviceCtx memory\n", __func__);
		err = -ENOMEM;
		goto err_malloc_deviceCtx;
	}

	err = ams_deviceInit(data->deviceCtx, data->client, NULL);
	if (err < 0) {
		ALS_err("%s - ams_deviceInit failed.\n", __func__);
		goto err_id_failed;
	}
	else {
		ALS_dbg("%s - ams_deviceInit ok\n", __func__);
	}

	/*
	 * S-MUX Read/Write
	 * 1  read configuration to ram Read smux configuration to RAM from smux chain
	 * 2  write configuration from ram Write smux configuration from RAM to smux chain
	 */
	//	ams_smux_set(data->deviceCtx);

	data->sensor_mode = 0;
	data->als_input_dev = input_allocate_device();
	if (!data->als_input_dev) {
		ALS_err("%s - could not allocate input device\n", __func__);
		err = -EIO;
		goto err_input_allocate_device;
	}
	data->als_input_dev->name = MODULE_NAME_ALS;
	data->als_input_dev->id.bustype = BUS_I2C;
	input_set_drvdata(data->als_input_dev, data);
	input_set_capability(data->als_input_dev, EV_REL, REL_X);
	input_set_capability(data->als_input_dev, EV_REL, REL_Y);
	input_set_capability(data->als_input_dev, EV_REL, REL_Z);
	input_set_capability(data->als_input_dev, EV_REL, REL_RX);
	input_set_capability(data->als_input_dev, EV_REL, REL_RY);
	input_set_capability(data->als_input_dev, EV_REL, REL_RZ);
	input_set_capability(data->als_input_dev, EV_REL, REL_MISC);
	input_set_capability(data->als_input_dev, EV_ABS, ABS_X);
	input_set_capability(data->als_input_dev, EV_ABS, ABS_Y);
	input_set_capability(data->als_input_dev, EV_ABS, ABS_Z);

	err = input_register_device(data->als_input_dev);
	if (err < 0) {
		input_free_device(data->als_input_dev);
		ALS_err("%s - could not register input device\n", __func__);
		goto err_input_register_device;
	}

#if IS_ENABLED(CONFIG_ARCH_EXYNOS)
	err = sensors_create_symlink(data->als_input_dev);
#else
	err = sensors_create_symlink(&data->als_input_dev->dev.kobj, data->als_input_dev->name);
#endif
	if (err < 0) {
		ALS_err("%s - could not create_symlink\n", __func__);
		goto err_sensors_create_symlink;
	}

	err = sysfs_create_group(&data->als_input_dev->dev.kobj, &als_attribute_group);
	if (err) {
		ALS_err("%s - could not create sysfs group\n", __func__);
		goto err_sysfs_create_group;
	}

	err = sensors_register(&data->sensor_dev, data, tsl2510_sensor_attrs, MODULE_NAME_ALS);
	if (err) {
		ALS_err("%s - cound not register als_sensor(%d).\n", __func__, err);
		goto als_sensor_register_failed;
	}

	err = tsl2510_setup_irq(data);
	if (err) {
		ALS_err("%s - could not setup dev_irq\n", __func__);
		goto err_setup_irq;
	}

#if defined(CONFIG_AMS_OPTICAL_SENSOR_POLLING)
	data->wq = create_singlethread_workqueue("tsl2510_wq");
	if (data->wq) {
		INIT_WORK(&data->work_light, tsl2510_work_func_light);
		hrtimer_init(&data->timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
		//data->light_poll_delay = ns_to_ktime(64 * NSEC_PER_MSEC);  //60 msec Polling time
		//data->light_poll_delay = ns_to_ktime(32 * NSEC_PER_MSEC);  //20 msec Polling time
		data->light_poll_delay = ns_to_ktime(200 * NSEC_PER_MSEC);	 //als only mode need to 200 msec Polling time
		data->timer.function = tsl2510_timer_func;
		data->timer_is_exist = true;
		ALS_dbg("%s - workqueue created and set light_poll_delay as %d\n", __func__, data->light_poll_delay);
	} else {
		data->timer_is_exist = false;
		//ret = -ENOMEM;
		ALS_err("%s: could not create workqueue\n", __func__);
		// HAVE TO GO TO ERROR CASED
		//goto init_failed;
	}
#endif  //CONFIG_AMS_OPTICAL_SENSOR_POLLING


	err = tsl2510_init_fifo(data);

	if (err) {
		ALS_err("%s - error tsl2510_init_fifo\n", __func__);
	}

	tsl2510_irq_set_state(data, PWR_ON); /* For flushing interrupt request */
	err = tsl2510_power_ctrl(data, PWR_OFF);
	if (err < 0) {
		ALS_err("%s - failed to power off ctrl\n", __func__);
		goto dev_set_drvdata_failed;
	}

	tsl2510_irq_set_state(data, PWR_OFF);
	ALS_dbg("%s - success\n", __func__);
	goto done;

dev_set_drvdata_failed:
	free_irq(data->dev_irq, data);
err_setup_irq:
	sensors_unregister(data->sensor_dev, tsl2510_sensor_attrs);
als_sensor_register_failed:
	sysfs_remove_group(&data->als_input_dev->dev.kobj,
			&als_attribute_group);
err_sysfs_create_group:
#if IS_ENABLED(CONFIG_ARCH_EXYNOS)
	sensors_remove_symlink(data->als_input_dev);
#else
	sensors_remove_symlink(&data->als_input_dev->dev.kobj, data->als_input_dev->name);
#endif
err_sensors_create_symlink:
	input_unregister_device(data->als_input_dev);
err_input_register_device:
err_input_allocate_device:
err_id_failed:
	//	devm_kfree(data->deviceCtx);
err_malloc_deviceCtx:
err_init_fail:
	tsl2510_power_ctrl(data, PWR_OFF);
err_power_on:
	gpio_free(data->pin_als_int);
err_setup_gpio:
err_parse_dt:
	if (data->regulator_vbus_1p8) {
		if (data->vbus_1p8_enable) {
			regulator_disable(data->regulator_vbus_1p8);
		}
		ALS_dbg("%s - put vbus_1p8 regulator = %p done (en = %d)\n", __func__, data->regulator_vbus_1p8, data->vbus_1p8_enable);
		regulator_put(data->regulator_vbus_1p8);
		data->regulator_vbus_1p8 = NULL;
	}

	if (data->regulator_vdd_1p8) {
		if (data->vdd_1p8_enable) {
			regulator_disable(data->regulator_vdd_1p8);
		}
		ALS_dbg("%s - put vdd_1p8 regulator = %p done (en = %d)\n", __func__, data->regulator_vdd_1p8, data->vdd_1p8_enable);
		regulator_put(data->regulator_vdd_1p8);
		data->regulator_vdd_1p8 = NULL;
	}
	//	devm_kfree(pdata);
err_malloc_pdata:

	if (data->als_pinctrl) {
		devm_pinctrl_put(data->als_pinctrl);
		data->als_pinctrl = NULL;
	}
	if (data->pins_active)
		data->pins_active = NULL;
	if (data->pins_sleep)
		data->pins_sleep = NULL;

	mutex_destroy(&data->i2clock);
	mutex_destroy(&data->activelock);
	mutex_destroy(&data->suspendlock);
	mutex_destroy(&data->flickerdatalock);
	misc_deregister(&data->miscdev);
err_misc_register:
	//	devm_kfree(data);
	ALS_err("%s failed\n", __func__);
done:
	return err;
}

int tsl2510_remove(struct i2c_client *client)
{
	struct tsl2510_device_data *data = i2c_get_clientdata(client);
	//struct fifo_chip *fifo;
	ALS_dbg("%s - start\n", __func__);
	tsl2510_power_ctrl(data, PWR_OFF);
	if (data->regulator_vbus_1p8) {
		if (data->vbus_1p8_enable) {
			regulator_disable(data->regulator_vbus_1p8);
		}
		ALS_dbg("%s - put vbus_1p8 regulator = %p done (en = %d)\n", __func__, data->regulator_vbus_1p8, data->vbus_1p8_enable);
		regulator_put(data->regulator_vbus_1p8);
		data->regulator_vbus_1p8 = NULL;
	}

	if (data->regulator_vdd_1p8) {
		if (data->vdd_1p8_enable) {
			regulator_disable(data->regulator_vdd_1p8);
		}
		ALS_dbg("%s - put vdd_1p8 regulator = %p done (en = %d)\n", __func__, data->regulator_vdd_1p8, data->vdd_1p8_enable);
		regulator_put(data->regulator_vdd_1p8);
		data->regulator_vdd_1p8 = NULL;
	}

	sensors_unregister(data->sensor_dev, tsl2510_sensor_attrs);
	sysfs_remove_group(&data->als_input_dev->dev.kobj, &als_attribute_group);
#if IS_ENABLED(CONFIG_ARCH_EXYNOS)
	sensors_remove_symlink(data->als_input_dev);
#else
	sensors_remove_symlink(&data->als_input_dev->dev.kobj, data->als_input_dev->name);
#endif
	input_unregister_device(data->als_input_dev);

	if (data->als_pinctrl) {
		devm_pinctrl_put(data->als_pinctrl);
		data->als_pinctrl = NULL;
	}
	if (data->pins_active)
		data->pins_active = NULL;
	if (data->pins_sleep)
		data->pins_sleep = NULL;

	if(data->timer_is_exist) {
		hrtimer_cancel(&data->timer);
	}

	if (data->wq) {
		cancel_work_sync(&data->work_light);
		destroy_workqueue(data->wq);
	}

	disable_irq(data->dev_irq);
	free_irq(data->dev_irq, data);
	gpio_free(data->pin_als_int);
	mutex_destroy(&data->i2clock);
	mutex_destroy(&data->activelock);
	mutex_destroy(&data->suspendlock);
	mutex_destroy(&data->flickerdatalock);
	misc_deregister(&data->miscdev);

	//	devm_kfree(data->deviceCtx);
	//	devm_kfree(data->pdata);
	//	devm_kfree(data);
	i2c_set_clientdata(client, NULL);


	//fifo = &data->fifo;
	//cancel_work_sync(&fifo->work);

	data = NULL;
	return 0;
}

static void tsl2510_shutdown(struct i2c_client *client)
{
	ALS_dbg("%s - start\n", __func__);
}

void tsl2510_pin_control(struct tsl2510_device_data *data, bool pin_set)
{
	int status = 0;
	if (!data->als_pinctrl) {
		ALS_err("%s - als_pinctrl is null\n", __func__);
		return;
	}
	if (pin_set) {
		if (!IS_ERR_OR_NULL(data->pins_active)) {
			status = pinctrl_select_state(data->als_pinctrl,
					data->pins_active);
			if (status)
				ALS_err("%s - can't set pin active state\n",
						__func__);
			ALS_info("%s active\n", __func__);
		}
	}
	else {
		if (!IS_ERR_OR_NULL(data->pins_sleep)) {
			status = pinctrl_select_state(data->als_pinctrl,
					data->pins_sleep);
			if (status)
				ALS_err("%s - can't set pin sleep state\n",
						__func__);
			ALS_info("%s sleep\n", __func__);
		}
	}
}

#if IS_ENABLED(CONFIG_PM)
static int tsl2510_suspend(struct device *dev)
{
	struct tsl2510_device_data *data = dev_get_drvdata(dev);
	int err = 0, cnt = 0;

	ALS_dbg("%s - %d\n", __func__, data->regulator_state);

#if defined(CONFIG_AMS_ALS_COMPENSATION_FOR_AUTO_BRIGHTNESS)
	if (data->als_flag) {
		data->als_flag = 0;
		tsl2510_als_stop(data);
	}
#endif
	if (data->enabled != 0 ) {
		do {
			err = tsl2510_stop(data);

			if (err < 0) {
				break;
			}
			data->suspend_cnt++;
			cnt++;
		} while (data->enabled && cnt < 5);
		data->enabled = 1;
	} else if (data->regulator_state != 0) {
		ALS_dbg("%s - abnormal state! als not enabled", __func__);
		do {
			err = tsl2510_stop(data);

			if (err < 0) {
				break;
			}
		} while (data->regulator_state != 0);
	}

	mutex_lock(&data->suspendlock);

	data->pm_state = PM_SUSPEND;
	tsl2510_pin_control(data, false);

	mutex_unlock(&data->suspendlock);

	return err;
}

static int tsl2510_resume(struct device *dev)
{
	struct tsl2510_device_data *data = dev_get_drvdata(dev);
	int err = 0;

	ALS_dbg("%s - %d\n", __func__, data->suspend_cnt);

	mutex_lock(&data->suspendlock);

	tsl2510_pin_control(data, true);

	data->pm_state = PM_RESUME;

	mutex_unlock(&data->suspendlock);

	if (data->enabled != 0) {
		do {
			tsl2510_start(data);
			data->suspend_cnt--;
		} while(data->suspend_cnt > 0);
	}
	return err;
}

static const struct dev_pm_ops tsl2510_pm_ops = {
	.suspend = tsl2510_suspend,
	.resume = tsl2510_resume
};
#endif

static const struct i2c_device_id tsl2510_idtable[] = {
	{ "tsl2510", 0 },
	{ }
};
/* descriptor of the tsl2510 I2C driver */
static struct i2c_driver tsl2510_driver = {
	.driver = {
		.name = "tsl2510",
		.owner = THIS_MODULE,
#if IS_ENABLED(CONFIG_PM)
		.pm = &tsl2510_pm_ops,
#endif
		.of_match_table = tsl2510_match_table,
	},
	.probe = tsl2510_probe,
	.remove = tsl2510_remove,
	.shutdown = tsl2510_shutdown,
	.id_table = tsl2510_idtable,
};

/* initialization and exit functions */
static int __init tsl2510_init(void)
{
	int rc = i2c_add_driver(&tsl2510_driver);
	return rc;
}

static void __exit tsl2510_exit(void)
{
	i2c_del_driver(&tsl2510_driver);
}

module_init(tsl2510_init);
module_exit(tsl2510_exit);

MODULE_SOFTDEP("pre: sensors_core");
MODULE_AUTHOR("Samsung Electronics");
MODULE_DESCRIPTION("TSL2510 ALS Driver");
MODULE_LICENSE("GPL");
