
/*
 * Copyright (c) 2018 Samsung Electronics Co., Ltd.
 *              http://www.samsung.com
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 as
 * published by the Free Software Foundation.
*/

/dts-v1/;
/plugin/;
/ {
	fragment@smd {
		target-path = "/";
		__overlay__ {
			smd: samsung_mobile_device {
				compatible = "simple-bus";
			};
		};
	};
};

/* #include "../max77775_charger.dtsi" */            /* From max77775_charger.py */
&smd {
	max77775_charger: max77775-charger {
			charger,fac_vsys = <3800>;
	};

	battery {
		battery,fgsrc_switch_name = "max77775-charger";
		battery,otg_name = "max77775-otg";
	};
};


/* /home/dpi/qb5_8814/workspace/P4_1716/android/kernel/kmodule/battery/stable/eureka/charger/max77775/max77775_charger.e1s.dtsi */
&max77775_charger {
	charger,enable_sysovlo_irq;
	charger,fac_vsys = <4400>;

	charger,fsw = <2>; /* 1.5MHz */
	charger,enable_noise_wa;
};

/* #include "../display_s6e3fac_mu1s.dtsi" */        /* From display_s6e3fac_mu1s.py */
/*
 * Samsung Exynos SoC series Panel driver
 *
 * Copyright (c) 2020 Samsung Electronics Co., Ltd
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 as
 * published by the Free Software Foundation.
 */

#include <dt-bindings/display/panel-display.h>
#include "../display_s6e3fac_mu1s_freq_hop.dtsi"

&dsim_modes {
	/* FHD */
	1080x2340@120hs {
		exynos,pmsk = <
			0x5 0x59 0x0 0xAC00 /* p m s k */
			0x0 0x0 0x0 0x0
			0x0 0x0 0x0 0x0
			0x0 0x0
			>;
		exynos,hs-clk = <1362>;
		exynos,esc-clk = <20>;
		exynos,cmd_underrun_cnt = <3452>;
	};
	1080x2340@96hs {
		exynos,pmsk = <
			0x5 0x59 0x0 0xAC00 /* p m s k */
			0x0 0x0 0x0 0x0
			0x0 0x0 0x0 0x0
			0x0 0x0
			>;
		exynos,hs-clk = <1362>;
		exynos,esc-clk = <20>;
		exynos,cmd_underrun_cnt = <5207>;
	};
	1080x2340@60phs {
		exynos,pmsk = <
			0x5 0x59 0x0 0xAC00 /* p m s k */
			0x0 0x0 0x0 0x0
			0x0 0x0 0x0 0x0
			0x0 0x0
			>;
		exynos,hs-clk = <1362>;
		exynos,esc-clk = <20>;
		exynos,cmd_underrun_cnt = <3452>;
	};
	1080x2340@48phs {
		exynos,pmsk = <
			0x5 0x59 0x0 0xAC00 /* p m s k */
			0x0 0x0 0x0 0x0
			0x0 0x0 0x0 0x0
			0x0 0x0
			>;
		exynos,hs-clk = <1362>;
		exynos,esc-clk = <20>;
		exynos,cmd_underrun_cnt = <5207>;
	};
	1080x2340@30phs {
		exynos,pmsk = <
			0x5 0x59 0x0 0xAC00 /* p m s k */
			0x0 0x0 0x0 0x0
			0x0 0x0 0x0 0x0
			0x0 0x0
			>;
		exynos,hs-clk = <1362>;
		exynos,esc-clk = <20>;
		exynos,cmd_underrun_cnt = <3452>;
	};
	1080x2340@24phs {
		exynos,pmsk = <
			0x5 0x59 0x0 0xAC00 /* p m s k */
			0x0 0x0 0x0 0x0
			0x0 0x0 0x0 0x0
			0x0 0x0
			>;
		exynos,hs-clk = <1362>;
		exynos,esc-clk = <20>;
		exynos,cmd_underrun_cnt = <3452>;
	};
	1080x2340@10phs {
		exynos,pmsk = <
			0x5 0x59 0x0 0xAC00 /* p m s k */
			0x0 0x0 0x0 0x0
			0x0 0x0 0x0 0x0
			0x0 0x0
			>;
		exynos,hs-clk = <1362>;
		exynos,esc-clk = <20>;
		exynos,cmd_underrun_cnt = <3452>;
	};
	1080x2340@60ns {
		exynos,pmsk = <
			0x5 0x59 0x0 0xAC00 /* p m s k */
			0x0 0x0 0x0 0x0
			0x0 0x0 0x0 0x0
			0x0 0x0
			>;
		exynos,hs-clk = <1362>;
		exynos,esc-clk = <20>;
		exynos,cmd_underrun_cnt = <10475>;
	};
	1080x2340@48ns {
		exynos,pmsk = <
			0x5 0x59 0x0 0xAC00 /* p m s k */
			0x0 0x0 0x0 0x0
			0x0 0x0 0x0 0x0
			0x0 0x0
			>;
		exynos,hs-clk = <1362>;
		exynos,esc-clk = <20>;
		exynos,cmd_underrun_cnt = <13987>;
	};
	1080x2340@30ns {
		exynos,pmsk = <
			0x5 0x59 0x0 0xAC00 /* p m s k */
			0x0 0x0 0x0 0x0
			0x0 0x0 0x0 0x0
			0x0 0x0
			>;
		exynos,hs-clk = <1362>;
		exynos,esc-clk = <20>;
		exynos,cmd_underrun_cnt = <24522>;
	};
};

/ {
	fragment@panel_display_mode {
		target-path = "/";
		__overlay__ {
			mu1s_panel_display_modes:
			mu1s_panel_display_modes {
				native-mode = <&mu1s_panel_display_mode_1080x2340_120hs>;
				exposed-mode = <
					&mu1s_panel_display_mode_1080x2340_120hs
					/*
					&mu1s_panel_display_mode_1080x2340_60hs_120hs
					&mu1s_panel_display_mode_1080x2340_30hs_120hs
					&mu1s_panel_display_mode_1080x2340_24hs_120hs
					&mu1s_panel_display_mode_1080x2340_10hs_120hs
					&mu1s_panel_display_mode_1080x2340_96hs
					&mu1s_panel_display_mode_1080x2340_48hs_96hs
					&mu1s_panel_display_mode_1080x2340_60hs
					&mu1s_panel_display_mode_1080x2340_30hs_60hs
					&mu1s_panel_display_mode_1080x2340_48hs
					&mu1s_panel_display_mode_1080x2340_24hs_48hs
					&mu1s_panel_display_mode_1080x2340_10hs_48hs
					&mu1s_panel_display_mode_1080x2340_60ns
					*/
					&mu1s_panel_display_mode_1080x2340_30ns
				>;

				/* fhd */
				mu1s_panel_display_mode_1080x2340_120hs:
				mu1s_panel_display_mode_1080x2340_120hs {
					id = PANEL_DISPLAY_MODE_1080x2340_120HS;
					width = <1080>;
					height = <2340>;
					/* timing parameters */
					refresh_rate = <120>;			/* logical refresh rate */
					refresh_mode = <REFRESH_MODE_HS>;
					panel_refresh_rate = <120>;		/* panel internal refresh rate */
					panel_refresh_mode = <PANEL_REFRESH_MODE_HS>;
					panel_te_st = <0>;				/* te rising */
					panel_te_ed = <0>;				/* te falling */
					panel_te_sw_skip_count = <0>;	/* s/w te modulation */
					panel_te_hw_skip_count = <0>;	/* h/w te modulation */
					panel_h_porch = <0 0 0>;
					panel_v_porch = <28 0 0>;	/* panel vbp:16, vfp:12, but for ap vblank set vbp:16+12, vfp:0 */
					/* dsc parameters */
					dsc_en = <1>;			/* 0:Disable, 1:Enable */
					dsc_cnt = <2>;			/* used DSC count */
					dsc_slice_num = <2>;	/* count of dsc slice */
					dsc_slice_w = <540>;	/* width of dsc slice */
					dsc_slice_h = <117>;	/* height of dsc slice */
					/* dsi parameters */
					cmd_lp_ref = <3419>;
				};

				mu1s_panel_display_mode_1080x2340_60hs_120hs:
				mu1s_panel_display_mode_1080x2340_60hs_120hs {
					id = PANEL_DISPLAY_MODE_1080x2340_60HS_120HS_TE_HW_SKIP_1;
					width = <1080>;
					height = <2340>;
					/* timing parameters */
					refresh_rate = <60>;			/* logical refresh rate */
					refresh_mode = <REFRESH_MODE_PASSIVE_HS>;
					panel_refresh_rate = <120>;		/* panel internal refresh rate */
					panel_refresh_mode = <PANEL_REFRESH_MODE_HS>;
					panel_te_st = <0>;				/* te rising */
					panel_te_ed = <0>;				/* te falling */
					panel_te_sw_skip_count = <0>;	/* s/w te modulation */
					panel_te_hw_skip_count = <1>;	/* h/w te modulation */
					panel_h_porch = <0 0 0>;
					panel_v_porch = <28 0 0>;	/* panel vbp:16, vfp:12, but for ap vblank set vbp:16+12, vfp:0 */
					/* dsc parameters */
					dsc_en = <1>;			/* 0:Disable, 1:Enable */
					dsc_cnt = <2>;			/* used DSC count */
					dsc_slice_num = <2>;	/* count of dsc slice */
					dsc_slice_w = <540>;	/* width of dsc slice */
					dsc_slice_h = <117>;	/* height of dsc slice */
					/* dsi parameters */
					cmd_lp_ref = <3419>;
				};

				mu1s_panel_display_mode_1080x2340_30hs_120hs:
				mu1s_panel_display_mode_1080x2340_30hs_120hs {
					id = PANEL_DISPLAY_MODE_1080x2340_30HS_120HS_TE_HW_SKIP_3;
					width = <1080>;
					height = <2340>;
					/* timing parameters */
					refresh_rate = <30>;			/* logical refresh rate */
					refresh_mode = <REFRESH_MODE_PASSIVE_HS>;
					panel_refresh_rate = <120>;		/* panel internal refresh rate */
					panel_refresh_mode = <PANEL_REFRESH_MODE_HS>;
					panel_te_st = <0>;				/* te rising */
					panel_te_ed = <0>;				/* te falling */
					panel_te_sw_skip_count = <0>;	/* s/w te modulation */
					panel_te_hw_skip_count = <3>;	/* h/w te modulation */
					panel_h_porch = <0 0 0>;
					panel_v_porch = <28 0 0>;	/* panel vbp:16, vfp:12, but for ap vblank set vbp:16+12, vfp:0 */
					/* dsc parameters */
					dsc_en = <1>;			/* 0:Disable, 1:Enable */
					dsc_cnt = <2>;			/* used DSC count */
					dsc_slice_num = <2>;	/* count of dsc slice */
					dsc_slice_w = <540>;	/* width of dsc slice */
					dsc_slice_h = <117>;	/* height of dsc slice */
					/* dsi parameters */
					cmd_lp_ref = <3419>;
				};

				mu1s_panel_display_mode_1080x2340_24hs_120hs:
				mu1s_panel_display_mode_1080x2340_24hs_120hs {
					id = PANEL_DISPLAY_MODE_1080x2340_24HS_120HS_TE_HW_SKIP_4;
					width = <1080>;
					height = <2340>;
					/* timing parameters */
					refresh_rate = <24>;			/* logical refresh rate */
					refresh_mode = <REFRESH_MODE_PASSIVE_HS>;
					panel_refresh_rate = <120>;		/* panel internal refresh rate */
					panel_refresh_mode = <PANEL_REFRESH_MODE_HS>;
					panel_te_st = <0>;				/* te rising */
					panel_te_ed = <0>;				/* te falling */
					panel_te_sw_skip_count = <0>;	/* s/w te modulation */
					panel_te_hw_skip_count = <4>;	/* h/w te modulation */
					panel_h_porch = <0 0 0>;
					panel_v_porch = <28 0 0>;	/* panel vbp:16, vfp:12, but for ap vblank set vbp:16+12, vfp:0 */
					/* dsc parameters */
					dsc_en = <1>;			/* 0:Disable, 1:Enable */
					dsc_cnt = <2>;			/* used DSC count */
					dsc_slice_num = <2>;	/* count of dsc slice */
					dsc_slice_w = <540>;	/* width of dsc slice */
					dsc_slice_h = <117>;	/* height of dsc slice */
					/* dsi parameters */
					cmd_lp_ref = <3419>;
				};

				mu1s_panel_display_mode_1080x2340_10hs_120hs:
				mu1s_panel_display_mode_1080x2340_10hs_120hs {
					id = PANEL_DISPLAY_MODE_1080x2340_10HS_120HS_TE_HW_SKIP_11;
					width = <1080>;
					height = <2340>;
					/* timing parameters */
					refresh_rate = <10>;			/* logical refresh rate */
					refresh_mode = <REFRESH_MODE_PASSIVE_HS>;
					panel_refresh_rate = <120>;		/* panel internal refresh rate */
					panel_refresh_mode = <PANEL_REFRESH_MODE_HS>;
					panel_te_st = <0>;				/* te rising */
					panel_te_ed = <0>;				/* te falling */
					panel_te_sw_skip_count = <0>;	/* s/w te modulation */
					panel_te_hw_skip_count = <11>;	/* h/w te modulation */
					panel_h_porch = <0 0 0>;
					panel_v_porch = <28 0 0>;	/* panel vbp:16, vfp:12, but for ap vblank set vbp:16+12, vfp:0 */
					/* dsc parameters */
					dsc_en = <1>;			/* 0:Disable, 1:Enable */
					dsc_cnt = <2>;			/* used DSC count */
					dsc_slice_num = <2>;	/* count of dsc slice */
					dsc_slice_w = <540>;	/* width of dsc slice */
					dsc_slice_h = <117>;	/* height of dsc slice */
					/* dsi parameters */
					cmd_lp_ref = <3419>;
				};

				mu1s_panel_display_mode_1080x2340_96hs:
				mu1s_panel_display_mode_1080x2340_96hs {
					id = PANEL_DISPLAY_MODE_1080x2340_96HS;
					width = <1080>;
					height = <2340>;
					/* timing parameters */
					refresh_rate = <96>;			/* logical refresh rate */
					refresh_mode = <REFRESH_MODE_HS>;
					panel_refresh_rate = <96>;		/* panel internal refresh rate */
					panel_refresh_mode = <PANEL_REFRESH_MODE_HS>;
					panel_te_st = <0>;				/* te rising */
					panel_te_ed = <0>;				/* te falling */
					panel_te_sw_skip_count = <0>;	/* s/w te modulation */
					panel_te_hw_skip_count = <0>;	/* h/w te modulation */
					panel_h_porch = <0 0 0>;
					panel_v_porch = <620 0 0>;	/* panel vbp:16, vfp:604, but for ap vblank set vbp:620, vfp:0 */
					/* dsc parameters */
					dsc_en = <1>;			/* 0:Disable, 1:Enable */
					dsc_cnt = <2>;			/* used DSC count */
					dsc_slice_num = <2>;	/* count of dsc slice */
					dsc_slice_w = <540>;	/* width of dsc slice */
					dsc_slice_h = <117>;	/* height of dsc slice */
					/* dsi parameters */
					cmd_lp_ref = <5175>;
				};

				mu1s_panel_display_mode_1080x2340_48hs_96hs:
				mu1s_panel_display_mode_1080x2340_48hs_96hs {
					id = PANEL_DISPLAY_MODE_1080x2340_48HS_96HS_TE_HW_SKIP_1;
					width = <1080>;
					height = <2340>;
					/* timing parameters */
					refresh_rate = <48>;			/* logical refresh rate */
					refresh_mode = <REFRESH_MODE_PASSIVE_HS>;
					panel_refresh_rate = <96>;		/* panel internal refresh rate */
					panel_refresh_mode = <PANEL_REFRESH_MODE_HS>;
					panel_te_st = <0>;				/* te rising */
					panel_te_ed = <0>;				/* te falling */
					panel_te_sw_skip_count = <0>;	/* s/w te modulation */
					panel_te_hw_skip_count = <1>;	/* h/w te modulation */
					panel_h_porch = <0 0 0>;
					panel_v_porch = <620 0 0>;	/* panel vbp:16, vfp:604, but for ap vblank set vbp:620, vfp:0 */
					/* dsc parameters */
					dsc_en = <1>;			/* 0:Disable, 1:Enable */
					dsc_cnt = <2>;			/* used DSC count */
					dsc_slice_num = <2>;	/* count of dsc slice */
					dsc_slice_w = <540>;	/* width of dsc slice */
					dsc_slice_h = <117>;	/* height of dsc slice */
					/* dsi parameters */
					cmd_lp_ref = <5175>;
				};

				mu1s_panel_display_mode_1080x2340_60hs:
				mu1s_panel_display_mode_1080x2340_60hs {
					id = PANEL_DISPLAY_MODE_1080x2340_60HS;
					width = <1080>;
					height = <2340>;
					/* timing parameters */
					refresh_rate = <60>;			/* logical refresh rate */
					refresh_mode = <REFRESH_MODE_HS>;
					panel_refresh_rate = <60>;		/* panel internal refresh rate */
					panel_refresh_mode = <PANEL_REFRESH_MODE_HS>;
					panel_te_st = <0>;				/* te rising */
					panel_te_ed = <0>;				/* te falling */
					panel_te_sw_skip_count = <0>;	/* s/w te modulation */
					panel_te_hw_skip_count = <0>;	/* h/w te modulation */
					panel_h_porch = <0 0 0>;
					panel_v_porch = <2396 0 0>;	/* panel vbp:16, vfp:2380, but for ap vblank set vbp:2396, vfp:0 */
					/* dsc parameters */
					dsc_en = <1>;			/* 0:Disable, 1:Enable */
					dsc_cnt = <2>;			/* used DSC count */
					dsc_slice_num = <2>;	/* count of dsc slice */
					dsc_slice_w = <540>;	/* width of dsc slice */
					dsc_slice_h = <117>;	/* height of dsc slice */
					/* dsi parameters */
					cmd_lp_ref = <10442>;
				};

				mu1s_panel_display_mode_1080x2340_30hs_60hs:
				mu1s_panel_display_mode_1080x2340_30hs_60hs {
					id = PANEL_DISPLAY_MODE_1080x2340_30HS_60HS_TE_HW_SKIP_1;
					width = <1080>;
					height = <2340>;
					/* timing parameters */
					refresh_rate = <30>;			/* logical refresh rate */
					refresh_mode = <REFRESH_MODE_HS>;
					panel_refresh_rate = <60>;		/* panel internal refresh rate */
					panel_refresh_mode = <PANEL_REFRESH_MODE_HS>;
					panel_te_st = <0>;				/* te rising */
					panel_te_ed = <0>;				/* te falling */
					panel_te_sw_skip_count = <0>;	/* s/w te modulation */
					panel_te_hw_skip_count = <1>;	/* h/w te modulation */
					panel_h_porch = <0 0 0>;
					panel_v_porch = <1200 1196 0>;	/* panel vbp:16, vfp:2380, but for ap vblank set vbp:16+1184, vfp:2380-1184 */
					/* dsc parameters */
					dsc_en = <1>;			/* 0:Disable, 1:Enable */
					dsc_cnt = <2>;			/* used DSC count */
					dsc_slice_num = <2>;	/* count of dsc slice */
					dsc_slice_w = <540>;	/* width of dsc slice */
					dsc_slice_h = <117>;	/* height of dsc slice */
					/* dsi parameters */
					cmd_lp_ref = <6931>;	/* underrun count for hsclk=1362, bts.fps=80 */
				};

				mu1s_panel_display_mode_1080x2340_48hs:
				mu1s_panel_display_mode_1080x2340_48hs {
					id = PANEL_DISPLAY_MODE_1080x2340_48HS;
					width = <1080>;
					height = <2340>;
					/* timing parameters */
					refresh_rate = <48>;			/* logical refresh rate */
					refresh_mode = <REFRESH_MODE_HS>;
					panel_refresh_rate = <48>;		/* panel internal refresh rate */
					panel_refresh_mode = <PANEL_REFRESH_MODE_HS>;
					panel_te_st = <0>;				/* te rising */
					panel_te_ed = <0>;				/* te falling */
					panel_te_sw_skip_count = <0>;	/* s/w te modulation */
					panel_te_hw_skip_count = <0>;	/* h/w te modulation */
					panel_h_porch = <0 0 0>;
					panel_v_porch = <3576 0 0>;	/* panel vbp:16, vfp:3564, but for ap vblank set vbp:16+3564, vfp:0 */
					/* dsc parameters */
					dsc_en = <1>;			/* 0:Disable, 1:Enable */
					dsc_cnt = <2>;			/* used DSC count */
					dsc_slice_num = <2>;	/* count of dsc slice */
					dsc_slice_w = <540>;	/* width of dsc slice */
					dsc_slice_h = <117>;	/* height of dsc slice */
					/* dsi parameters */
					cmd_lp_ref = <13954>;
				};

				mu1s_panel_display_mode_1080x2340_24hs_48hs:
				mu1s_panel_display_mode_1080x2340_24hs_48hs {
					id = PANEL_DISPLAY_MODE_1080x2340_24HS_48HS_TE_HW_SKIP_1;
					width = <1080>;
					height = <2340>;
					/* timing parameters */
					refresh_rate = <24>;			/* logical refresh rate */
					refresh_mode = <REFRESH_MODE_HS>;
					panel_refresh_rate = <48>;		/* panel internal refresh rate */
					panel_refresh_mode = <PANEL_REFRESH_MODE_HS>;
					panel_te_st = <0>;				/* te rising */
					panel_te_ed = <0>;				/* te falling */
					panel_te_sw_skip_count = <0>;	/* s/w te modulation */
					panel_te_hw_skip_count = <1>;	/* h/w te modulation */
					panel_h_porch = <0 0 0>;
					panel_v_porch = <1496 2084 0>;	/* panel vbp:16, vfp:3564, but for ap vblank set vbp:16+1480, vfp:3564-1480 */
					/* dsc parameters */
					dsc_en = <1>;			/* 0:Disable, 1:Enable */
					dsc_cnt = <2>;			/* used DSC count */
					dsc_slice_num = <2>;	/* count of dsc slice */
					dsc_slice_w = <540>;	/* width of dsc slice */
					dsc_slice_h = <117>;	/* height of dsc slice */
					/* dsi parameters */
					cmd_lp_ref = <7785>;	/* underrun count for hsclk=1362, bts.fps=74 */
				};

				mu1s_panel_display_mode_1080x2340_10hs_48hs:
				mu1s_panel_display_mode_1080x2340_10hs_48hs {
					id = PANEL_DISPLAY_MODE_1080x2340_10HS_48HS_TE_HW_SKIP_4;
					width = <1080>;
					height = <2340>;
					/* timing parameters */
					refresh_rate = <10>;			/* logical refresh rate */
					refresh_mode = <REFRESH_MODE_HS>;
					panel_refresh_rate = <48>;		/* panel internal refresh rate */
					panel_refresh_mode = <PANEL_REFRESH_MODE_HS>;
					panel_te_st = <0>;				/* te rising */
					panel_te_ed = <0>;				/* te falling */
					panel_te_sw_skip_count = <0>;	/* s/w te modulation */
					panel_te_hw_skip_count = <4>;	/* h/w te modulation */
					panel_h_porch = <0 0 0>;
					panel_v_porch = <1496 2084 0>;	/* panel vbp:16, vfp:3564, but for ap vblank set vbp:16+1480, vfp:3564-1480 */
					/* dsc parameters */
					dsc_en = <1>;			/* 0:Disable, 1:Enable */
					dsc_cnt = <2>;			/* used DSC count */
					dsc_slice_num = <2>;	/* count of dsc slice */
					dsc_slice_w = <540>;	/* width of dsc slice */
					dsc_slice_h = <117>;	/* height of dsc slice */
					/* dsi parameters */
					cmd_lp_ref = <7785>;	/* underrun count for hsclk=1362, bts.fps=74 */
				};

				mu1s_panel_display_mode_1080x2340_60ns:
				mu1s_panel_display_mode_1080x2340_60ns {
					id = PANEL_DISPLAY_MODE_1080x2340_60NS;
					width = <1080>;
					height = <2340>;
					/* timing parameters */
					refresh_rate = <60>;			/* logical refresh rate */
					refresh_mode = <REFRESH_MODE_NS>;
					panel_refresh_rate = <60>;		/* panel internal refresh rate */
					panel_refresh_mode = <PANEL_REFRESH_MODE_NS>;
					panel_te_st = <0>;				/* te rising */
					panel_te_ed = <0>;				/* te falling */
					panel_te_sw_skip_count = <0>;	/* s/w te modulation */
					panel_te_hw_skip_count = <0>;	/* h/w te modulation */
					panel_h_porch = <0 0 0>;
					panel_v_porch = <28 0 0>;	/* panel vbp:16, vfp:12, but for ap vblank set vbp:16+12, vfp:0 */
					/* dsc parameters */
					dsc_en = <1>;			/* 0:Disable, 1:Enable */
					dsc_cnt = <2>;			/* used DSC count */
					dsc_slice_num = <2>;	/* count of dsc slice */
					dsc_slice_w = <540>;	/* width of dsc slice */
					dsc_slice_h = <117>;	/* height of dsc slice */
					/* dsi parameters */
					cmd_lp_ref = <10442>;
				};

				mu1s_panel_display_mode_1080x2340_48ns:
				mu1s_panel_display_mode_1080x2340_48ns {
					id = PANEL_DISPLAY_MODE_1080x2340_48NS;
					width = <1080>;
					height = <2340>;
					/* timing parameters */
					refresh_rate = <48>;			/* logical refresh rate */
					refresh_mode = <REFRESH_MODE_NS>;
					panel_refresh_rate = <48>;		/* panel internal refresh rate */
					panel_refresh_mode = <PANEL_REFRESH_MODE_NS>;
					panel_te_st = <0>;				/* te rising */
					panel_te_ed = <0>;				/* te falling */
					panel_te_sw_skip_count = <0>;	/* s/w te modulation */
					panel_te_hw_skip_count = <0>;	/* h/w te modulation */
					panel_h_porch = <0 0 0>;
					panel_v_porch = <620 0 0>;	/* panel vbp:16, vfp:604, but for ap vblank set vbp:620, vfp:0 */
					/* dsc parameters */
					dsc_en = <1>;			/* 0:Disable, 1:Enable */
					dsc_cnt = <2>;			/* used DSC count */
					dsc_slice_num = <2>;	/* count of dsc slice */
					dsc_slice_w = <540>;	/* width of dsc slice */
					dsc_slice_h = <117>;	/* height of dsc slice */
					/* dsi parameters */
					cmd_lp_ref = <13954>;
				};

				mu1s_panel_display_mode_1080x2340_30ns:
				mu1s_panel_display_mode_1080x2340_30ns {
					id = PANEL_DISPLAY_MODE_1080x2340_30NS;
					width = <1080>;
					height = <2340>;
					/* timing parameters */
					refresh_rate = <30>;			/* logical refresh rate */
					refresh_mode = <REFRESH_MODE_NS>;
					panel_refresh_rate = <30>;		/* panel internal refresh rate */
					panel_refresh_mode = <PANEL_REFRESH_MODE_NS>;
					panel_te_st = <0>;				/* te rising */
					panel_te_ed = <0>;				/* te falling */
					panel_te_sw_skip_count = <0>;	/* s/w te modulation */
					panel_te_hw_skip_count = <0>;	/* h/w te modulation */
					panel_h_porch = <0 0 0>;
					panel_v_porch = <28 0 0>;	/* panel vbp:16, vfp:12, but for ap vblank set vbp:16+12, vfp:0 */
					/* dsc parameters */
					dsc_en = <1>;			/* 0:Disable, 1:Enable */
					dsc_cnt = <2>;			/* used DSC count */
					dsc_slice_num = <2>;	/* count of dsc slice */
					dsc_slice_w = <540>;	/* width of dsc slice */
					dsc_slice_h = <117>;	/* height of dsc slice */
					/* dsi parameters */
					cmd_lp_ref = <24489>;
					doze_mode;
					panel_lp_mode;
				};
			};
		};
	};
};

/ {
	fragment@panel_drv {
		target-path = "/";
		__overlay__ {
			mafpc_0: mafpc_0 {
					 compatible = "samsung,panel-mafpc";
					 status = "okay";
			};

			panel_drv_0: panel_drv_0 {
				status = "okay";
				compatible = "samsung,panel-drv";
				panel,id = <0>;

				s6e3fac_mu1s_power_ctrl: s6e3fac_mu1s_power_ctrl {
					actions {
						fac_mu1s_vci_on: vci-on {
							type = <PCTRL_REGULATOR_ENABLE>;
							reg = <&ddi_vci>;
						};
						fac_mu1s_vdd3_on: vdd3-on {
							type = <PCTRL_REGULATOR_ENABLE>;
							reg = <&ddi_vdd3>;
						};
						fac_mu1s_vddr_on: vddr-on {
							type = <PCTRL_REGULATOR_ENABLE>;
							reg = <&ddr_vddr>;
						};
						fac_mu1s_vddr_off: vddr-off {
							type = <PCTRL_REGULATOR_DISABLE>;
							reg = <&ddr_vddr>;
						};
						fac_mu1s_vci_off: vci-off {
							type = <PCTRL_REGULATOR_DISABLE>;
							reg = <&ddi_vci>;
						};
						fac_mu1s_vdd3_off: vdd3-off {
							type = <PCTRL_REGULATOR_DISABLE>;
							reg = <&ddi_vdd3>;
						};
						fac_mu1s_delay_1ms: delay-1ms {
							type = <PCTRL_DELAY_MSLEEP>;
							value = <1>;
						};
						fac_mu1s_delay_5ms: delay-5ms {
							type = <PCTRL_DELAY_MSLEEP>;
							value = <5>;
						};
						fac_mu1s_delay_10ms: delay-10ms {
							type = <PCTRL_DELAY_MSLEEP>;
							value = <10>;
						};
						fac_mu1s_reset_high: reset-high {
							type = <PCTRL_GPIO_ENABLE>;
							gpio = <&disp_reset>;
						};
						fac_mu1s_reset_low: reset-low {
							type = <PCTRL_GPIO_DISABLE>;
							gpio = <&disp_reset>;
						};
					};
					sequences {
						panel_boot_on = <&fac_mu1s_vci_on &fac_mu1s_vdd3_on &fac_mu1s_vddr_on>;
						panel_power_on = <&fac_mu1s_vci_on &fac_mu1s_vdd3_on &fac_mu1s_vddr_on &fac_mu1s_delay_10ms &fac_mu1s_reset_high &fac_mu1s_delay_5ms>;
						panel_power_off = <&fac_mu1s_reset_low &fac_mu1s_delay_1ms &fac_mu1s_vddr_off &fac_mu1s_delay_1ms &fac_mu1s_vdd3_off &fac_mu1s_vci_off>;
					};
				};

				s6e3fac_mu1s_ap:s6e3fac_mu1s_ap {
					/* S.LSI */
					SLSI,size = <70 151>;
					SLSI,hdr_num = <3>;			/* max: 4 */
					SLSI,hdr_type = <2 3 4 0>;		/* 1: DOLBY_VISION, 2: HDR10, 3: HLG */
					SLSI,hdr_max_luma = <4500000>;	/* 450 */
					SLSI,hdr_max_avg_luma = <1200000>;	/* 120 */
					SLSI,hdr_min_luma = <5>;		/* 0.0005 */
				};

				panels {
					s6e3fac_mu1s: s6e3fac_mu1s {
						ap-vendor-setting = <&s6e3fac_mu1s_ap>;
						display-mode = <&mu1s_panel_display_modes>;
						power-ctrl = <&s6e3fac_mu1s_power_ctrl>;
						freq-hop = <&mu1s_freq_hop_table>;
						dqe-suffix = "s6e3fac_mu1s";
						id-mask = <
							PANEL_ID(0x810220) PANEL_MASK(0xFFFFF0) /* DM1 */
							PANEL_ID(0x811620) PANEL_MASK(0xFFFFF0) /* DM2 */
						>;
					};
				};
			};
		};
	};
};


/* #include "../samsung_debug_6_1.dtsi" */           /* From samsung_debug_6_1.py */
/* SAMSUNG s5e9945 board device tree source
 *
 * Copyright (c) 2021 Samsung Electronics Co., Ltd.
 *		http://www.samsung.com
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 as
 * published by the Free Software Foundation.
 */

/ {
	fragment@sec_debug {
		target-path = "/";
		__overlay__ {
			sec_debug {
				compatible = "samsung,sec_debug";
				status = "okay";
				memory-region = <&sec_debug_next>;
				bdev_path = "/dev/block/by-name/debug";
			};
		};
	};

	fragment@sec_debug_built {
		target-path = "/";
		__overlay__ {
			sec_debug_built {
				compatible = "samsung,sec_debug_built";
				status = "okay";
				memory-region = <&sec_debug_next>;
			};
		};
	};

	fragment@sec_debug_test {
		target-path = "/";
		__overlay__ {
			sec_debug_test_device {
				compatible = "samsung,sec_debug_test";
				status = "okay";
			};
		};
	};

	fragment@sec_debug_reset_reason {
		target-path = "/";
		__overlay__ {
			sec_debug_reset_reason: sec_debug_reset_reason {
				compatible = "samsung,sec_debug_reset_reason";
				power_off_src = "OVP", "OI", "LDO_OI", "RSV3",
						"RSV4", "RSV5", "RSV6", "RSV7",
						"SUB_OFF", "TSD", "TIMEOUT", "LDO_SYS_OK",
						"PWRHOLD", "WTSR_TOUT", "SMPL_TOUT", "UVLOB";
				power_on_src =  "PWRON", "JIGONB", "ACOKB", "MRST",
						"ALARM", "INST_ACOK", "SMPL", "WTSR";
				rst_stat = "RSVD0", "RSVD1", "RSVD2", "RSVD3",
					"RSVD4", "RSVD5", "RSVD6", "RSVD7",
					"RSVD8", "RSVD9", "RSVD10", "RSVD11",
					"RSVD12", "RSVD13", "RSVD14", "RSVD15",
					"PINRESET", "DNC_CPU_WDTRESET", "SSP_CPU_WDTRESET", "OIS_CPU_WDTRESET",
					"APM_CPU0_WDTRESET", "APM_CPU1_WDTRESET", "VTS_CPU_WDTRESET", "CHUB_WDTRESET",
					"CLUSTER0_WDTRESET", "CLUSTER2_WDTRESET", "AUD_CPU0_WDTRESET", "SSS_CPU_WDTRESET",
					"DBGC_CPU_WDTRESET", "WRESET", "SWRESET", "PORESET";
			};
		};
	};
};

&reserved_memory {
	sec_debug_next: sec_debug_next {
		reg = <0x0 0x91200000 0x00200000>;
		no-map;
	};
};

/* #include "../common/input_booster_s5e9945.dtsi" *//* From input_booster_s5e9945.py */
/*
 * Samsung Mobile Input-Booster device tree
 *
 * Copyright (c) 2018 Samsung Electronics Co., Ltd.
 *		http://www.samsung.com
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 as
 * published by the Free Software Foundation.
 */

&smd {
	input_booster {
		status = "okay";
		compatible = "input_booster";
		resValcount = "3";
		max_resource_count = "7";
		max_cluster_count = "3";
		#address-cells = <1>;
		#size-cells = <0>;

		/* Each Cpu Cluster Start Cpu */
		cpu_cluster_policy = "7,4,0";
		/* < CLUSTER2, CLUSTER1, CLUSTER0, MIF, INT, HMP, UCC> */
		ib_release_values = "0,0,0,0,0,0,0";
		/* Select Allowed Resource Index Group */
		allowed_resources = "0,3,5";
		
		/* Mode Number 
		 *	DEFAULT_MODE = 0;
		 *	DISABLE_MODE = 1;
		 *	SIP_MODE = 2;
		 *	GAME_MODE = 3;
		*/

		booster@1 {
			booster,label = "Disable_Mode";
			booster,mode = "1";
			booster_key@1 {
				input_booster,label = "Touch_Disable";
				input_booster,type = <2>;	/* BOOSTER_DEVICE_TOUCH */
				/* Time table */
				input_booster,head_time = <0>;
				input_booster,tail_time = <0>;
				input_booster,resource {
					compatible = "resource";
					resource@1 {
						resource,label = "CPU";
						resource,id = "0";
						resource,value = <0 0>;
					};
				};
			};
		};

		booster@2 {
			booster,label = "Sip_Mode";
			booster,mode = "2";
			booster_key@1 {
				input_booster,label = "sip_touch";
				input_booster,type = <2>;	/* BOOSTER_DEVICE_TOUCH */
				/* Time table */
				input_booster,head_time = <200>;
				input_booster,tail_time = <0>;
				input_booster,resource {
					compatible = "resource";
					resource@1 {
						resource,label = "CPU";
						resource,id = "0";
						resource,value = <1152000 0>;
					};

					resource@4 {
						resource,label = "mif";
						resource,id = "3";
						resource,value = <0 0>;
					};

					resource@6 {
						resource,label = "level";
						resource,id = "5";
						resource,value = <1 0>;
					};
				};
			};
		};

		booster@3 {
			booster,label = "Game_Mode";
			booster,mode = "3";
			booster_key@1 {
				input_booster,label = "GAME_MT";
				input_booster,type = <3>;	/* BOOSTER_DEVICE_MULTITOUCH */
				/* Time table */
				input_booster,head_time = <0>;
				input_booster,tail_time = <0>;
				input_booster,resource {
					compatible = "resource";
					resource@1 {
						resource,label = "CPU";
						resource,id = "0";
						resource,value = <0 0>;
					};

					resource@4 {
						resource,label = "mif";
						resource,id = "3";
						resource,value = <0 0>;
					};

					resource@6 {
						resource,label = "level";
						resource,id = "5";
						resource,value = <0 0>;
					};
				};
			};
			booster_key@2 {
				input_booster,label = "GAME_TOUCH";
				input_booster,type = <2>;	/* BOOSTER_DEVICE_TOUCH */

				/* Time table */
				input_booster,head_time = <0>;
				input_booster,tail_time = <0>;

				/* Input Booster Resource Frequency */
				inputbooster,resource {
					compatible = "resource";
					resource@1 {
						resource,label = "CPU";
						resource,id = "0";
						resource,value = <0 0>;
					};

					resource@4 {
						resource,label = "mif";
						resource,id = "3";
						resource,value = <0 0>;
					};

					resource@6 {
						resource,label = "level";
						resource,id = "5";
						resource,value = <0 0>;
					};
				};
			};
		};

		booster@4 {
			booster,label = "input_booster";
			booster,mode = "0";

			booster_key@1 {
				input_booster,label = "key";
				input_booster,type = <0>;	/* BOOSTER_DEVICE_KEY */

				/* Time table */
				input_booster,head_time = <500>;
				input_booster,tail_time = <0>;

				/* resource Table Sequentially identified with index
				 * CLUSTER2's ID & Index : 0 (or UFC)
				 * CLUSTER1's ID & Index : 1
				 * CLUSTER0's ID & Index : 2
				 * MIF's ID & Index      : 3
				 * INT's ID & Index      : 4
				 * HMP's ID & Index      : 5
				 * UCC's ID & Index      : 6
				 */

				/* Input Booster Resource Frequency */
				inputbooster,resource {
					compatible = "resource";
					resource@1 {
						resource,label = "cluster2";
						resource,id = "0";
						resource,value = <0 0>;
					};

					resource@4 {
						resource,label = "mif";
						resource,id = "3";
						resource,value = <0 0>;
					};

					resource@6 {
						resource,label = "level";
						resource,id = "5";
						resource,value = <1 0>;
					};
				};
			};

			booster_key@2 {
				input_booster,label = "touchkey";
				input_booster,type = <1>;	/* BOOSTER_DEVICE_TOUCHKEY */

				/* Time table */
				input_booster,head_time = <200>;
				input_booster,tail_time = <0>;

				/* Input Booster Resource Frequency */
				inputbooster,resource {
					compatible = "resource";
					resource@1 {
						resource,label = "cluster2";
						resource,id = "0";
						resource,value = <0 0>;
					};

					resource@4 {
						resource,label = "mif";
						resource,id = "3";
						resource,value = <0 0>;
					};

					resource@6 {
						resource,label = "level";
						resource,id = "5";
						resource,value = <1 0>;
					};
				};
			};

			booster_key@3 {
				input_booster,label = "touch";
				input_booster,type = <2>;	/* BOOSTER_DEVICE_TOUCH */

				/* Time table */
				input_booster,head_time = <130>;
				input_booster,tail_time = <500>;

				/* Input Booster Resource Frequency */
				inputbooster,resource {
					compatible = "resource";
					resource@1 {
						resource,label = "cluster2";
						resource,id = "0";
						resource,value = <0 0>;
					};

					resource@4 {
						resource,label = "mif";
						resource,id = "3";
						resource,value = <0 0>;
					};

					resource@6 {
						resource,label = "level";
						resource,id = "5";
						resource,value = <1 1>;
					};
				};
			};

			booster_key@4 {
				input_booster,label = "multitouch";
				input_booster,type = <3>;	/* BOOSTER_DEVICE_MULTITOUCH */

				/* Time table */
				input_booster,head_time = <1000>;
				input_booster,tail_time = <500>;

				/* Input Booster Resource Frequency */
				inputbooster,resource {
					compatible = "resource";
					resource@1 {
						resource,label = "cluster2";
						resource,id = "0";
						resource,value = <0 0>;
					};

					resource@4 {
						resource,label = "mif";
						resource,id = "3";
						resource,value = <0 0>;
					};

					resource@6 {
						resource,label = "level";
						resource,id = "5";
						resource,value = <1 1>;
					};
				};
			};

			booster_key@5 {
				input_booster,label = "keyboard";
				input_booster,type = <4>;	/* BOOSTER_DEVICE_KEYBOARD */

				/* Time table */
				input_booster,head_time = <130>;
				input_booster,tail_time = <0>;

				/* Input Booster Resource Frequency */
				inputbooster,resource {
					compatible = "resource";
					resource@1 {
						resource,label = "cluster2";
						resource,id = "0";
						resource,value = <0 0>;
					};

					resource@4 {
						resource,label = "mif";
						resource,id = "3";
						resource,value = <0 0>;
					};

					resource@6 {
						resource,label = "level";
						resource,id = "5";
						resource,value = <1 0>;
					};
				};
			};

			booster_key@6 {
				input_booster,label = "MOUSE";
				input_booster,type = <5>;	/* BOOSTER_DEVICE_MOUSE */

				/* Time table */
				input_booster,head_time = <130>;
				input_booster,tail_time = <500>;

				/* Input Booster Resource Frequency */
				inputbooster,resource {
					compatible = "resource";
					resource@1 {
						resource,label = "cluster2";
						resource,id = "0";
						resource,value = <0 0>;
					};

					resource@4 {
						resource,label = "mif";
						resource,id = "3";
						resource,value = <0 0>;
					};

					resource@6 {
						resource,label = "level";
						resource,id = "5";
						resource,value = <1 1>;
					};
				};
			};

			booster_key@7 {
				input_booster,label = "mouse_wheel";
				input_booster,type = <6>;	/* BOOSTER_DEVICE_MOUSE */

				/* Time table */
				input_booster,head_time = <130>;
				input_booster,tail_time = <0>;

				/* Input Booster Resource Frequency */
				inputbooster,resource {
					compatible = "resource";
					resource@1 {
						resource,label = "cluster2";
						resource,id = "0";
						resource,value = <0 0>;
					};

					resource@4 {
						resource,label = "mif";
						resource,id = "3";
						resource,value = <0 0>;
					};

					resource@6 {
						resource,label = "level";
						resource,id = "5";
						resource,value = <1 0>;
					};
				};
			};

			booster_key@8 {
				input_booster,label = "pen_hover";
				input_booster,type = <7>;	/* BOOSTER_DEVICE_MOUSE */

				/* Time table */
				input_booster,head_time = <130>;
				input_booster,tail_time = <500>;

				/* Input Booster Resource Frequency */
				inputbooster,resource {
					compatible = "resource";
					resource@1 {
						resource,label = "cluster2";
						resource,id = "0";
						resource,value = <0 0>;
					};

					resource@4 {
						resource,label = "mif";
						resource,id = "3";
						resource,value = <0 0>;
					};

					resource@6 {
						resource,label = "level";
						resource,id = "5";
						resource,value = <1 1>;
					};
				};
			};

			booster_key@9 {
				input_booster,label = "pen";
				input_booster,type = <8>;	/* BOOSTER_DEVICE_MOUSE */

				/* Time table */
				input_booster,head_time = <200>;
				input_booster,tail_time = <600>;

				/* Input Booster Resource Frequency */
				inputbooster,resource {
					compatible = "resource";
					resource@1 {
						resource,label = "cluster2";
						resource,id = "0";
						resource,value = <0 0>;
					};

					resource@4 {
						resource,label = "mif";
						resource,id = "3";
						resource,value = <0 0>;
					};

					resource@6 {
						resource,label = "level";
						resource,id = "5";
						resource,value = <1 1>;
					};
				};
			};
			/* If you need to add new key type, add it this position */
		};
	};
};

/* #include "../samsung_6_1.dtsi" */                 /* From samsung_6_1.py */
/* SAMSUNG board device tree source
 *
 * Copyright (c) 2021 Samsung Electronics Co., Ltd.
 *		http://www.samsung.com
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 as
 * published by the Free Software Foundation.
 */

/ {
	fragment@model {
		target-path = "/";
		__overlay__ {
			sec-reboot {
				compatible = "samsung,sec-reboot";
				samsung,syscon-phandle = <&pmu_system_controller>;
				shutdown-offset = <0x3F90>; /* PS_HOLD_CONTROL */
				shutdown-trigger = <0x100>; /* PS_HOLD_DATA_BIT */
				magic-inform = <0x00B8>; /* INFORM2 */
				panic-inform = <0x00BC>; /* INFORM3 */
			};
		};
	};
};

/* #include "../sec_pinctrl_wrapper_v3.dtsi" */      /* From sec_pinctrl_wrapper_v3.py */
#define ___count_args(_0, _1, _2, _3, _4, _5, _6, _7, _8, x, ...) x

#define __count_args(...)					\
	___count_args(__VA_ARGS__, 7, 6, 5, 4, 3, 2, 1, 0)

#define PIN_AP_FUNC_INPUT		0x0
#define PIN_AP_FUNC_OUTPUT		0x1
#define PIN_AP_FUNC_OUTPUT_HIGH		0x1
#define PIN_AP_FUNC_OUTPUT_LOW		0x1
#define PIN_AP_FUNC_INPUT_WAKEUP	0xf

#define PIN_AP_VAL_FUNC_INPUT		0x0
#define PIN_AP_VAL_FUNC_OUTPUT		0x0
#define PIN_AP_VAL_FUNC_OUTPUT_HIGH	0x1
#define PIN_AP_VAL_FUNC_OUTPUT_LOW	0x0
#define PIN_AP_VAL_FUNC_INPUT_WAKEUP	0x0


#define PIN_PM_FUNC_INPUT		pmic-gpio,input-enable
#define PIN_PM_FUNC_OUTPUT		pmic-gpio,output-enable
#define PIN_PM_FUNC_OUTPUT_HIGH		pmic-gpio,output-high
#define PIN_PM_FUNC_OUTPUT_LOW		pmic-gpio,output-low

#define PIN_AP_FUNC_PWM			0x2
#define PIN_AP_FUNC_I2C			0x2

#define PIN_PULL_NONE	0
#define PIN_PULL_DOWN	1
#define PIN_PULL_UP	3

#define PIN_PM_PULL_NONE	pmic-gpio,pull-disable
#define PIN_PM_PULL_DOWN	pmic-gpio,pull-down
#define PIN_PM_PULL_UP		pmic-gpio,pull-up

/*
 * Typical GPIO
 * 0x0 | 2 mA
 * 0x1 | 4 mA
 * 0x2 | 8 mA
 * 0x3 | 12 mA
 */

#define PIN_AP_DRV_LV1	0x0
#define PIN_AP_DRV_LV2	0x1
#define PIN_AP_DRV_LV3	0x1
#define PIN_AP_DRV_LV4	0x2
#define PIN_AP_DRV_LV5	0x2
#define PIN_AP_DRV_LV6	0x3
#define PIN_AP_DRV_LV7	0x3
#define PIN_AP_DRV_LV8	0x3

#define PIN_PM_DRV_LV1	0x0
#define PIN_PM_DRV_LV2	0x1
#define PIN_PM_DRV_LV3	0x2
#define PIN_PM_DRV_LV4	0x3
#define PIN_PM_DRV_LV5	0x4
#define PIN_PM_DRV_LV6	0x5
#define PIN_PM_DRV_LV7	0x5
#define PIN_PM_DRV_LV8	0x5

#define PIN_EXPAND(pin) #pin

#define GPIO_KEY_WAKEUP		gpio-key,wakeup
#define GPIO_KEY_NONE		gpio-key,none
#define GPIO_KEY_CAN_DISABLE	linux,can-disable

#define SEC_GPIO(src, handle, type, num)	SEC_ ##src## _GPIO(type, num)
#define SEC_AP_GPIO(type, num)	PIN_EXPAND(type##-num)
#define SEC_PM_GPIO(type, num)	PIN_EXPAND(type ##num)

#define SEC_GPIO_REF(src, handle, type, num)	SEC_ ##src## _GPIO_REF(handle, num)
#define SEC_AP_GPIO_REF(handle, num)	&handle num
#define SEC_PM_GPIO_REF(handle, num)	&handle num
#define SEC_GPIO_PHANDLE_ACTIVE(src, type, num)	SEC_GPIO_PHANDLE(type, num, active)
#define SEC_GPIO_PHANDLE_SLEEP(src, type, num)	SEC_GPIO_PHANDLE(type, num, sleep)
#define SEC_GPIO_PHANDLE(type, num, mode)	type##_##num##_##mode

#define SEC_GPIO_NUM(src, handle, type, num)	num

#define SEC_GPIO_TYPE(src, handle, type, num)	&handle

#define GPIO_CONFIG(src, handle, type, num, func)			GPIO_ ##src## _CONFIG(type, num, func)
#define GPIO_CONFIG_PUD(src, handle, type, num, func, pull)		GPIO_ ##src## _CONFIG_PUD(type, num, func, pull)
#define GPIO_CONFIG_PUD_DRV(src, handle, type, num, func, pull, drv)	GPIO_ ##src## _CONFIG_PUD_DRV(type, num, func, pull, drv)

#define GPIO_AP_CONFIG(_type, _num, _func)		\
	samsung,pins = SEC_AP_GPIO(_type, _num);	\
	samsung,pin-function = <PIN_AP_ ##_func>;	\
	samsung,pin-val = <PIN_AP_VAL_ ##_func>

#define GPIO_AP_CONFIG_PUD(_type, _num, _func, _pull)	\
	samsung,pins = SEC_AP_GPIO(_type, _num);	\
	samsung,pin-function = <PIN_AP_ ##_func>;	\
	samsung,pin-val = <PIN_AP_VAL_ ##_func>;		\
	samsung,pin-pud = <PIN_ ##_pull>

#define GPIO_AP_CONFIG_PUD_DRV(_type, _num, _func, _pull, _drv)	\
	samsung,pins = SEC_AP_GPIO(_type, _num);		\
	samsung,pin-function = <PIN_AP_ ##_func>;		\
	samsung,pin-val = <PIN_AP_VAL_ ##_func>;			\
	samsung,pin-pud = <PIN_ ##_pull>;			\
	samsung,pin-drv = <PIN_AP_ ##_drv>

#define GPIO_PM_CONFIG(_type, _num, _func)		\
	pins = SEC_PM_GPIO(_type, _num);			\
	PIN_PM_ ##_func				

#define GPIO_PM_CONFIG_PUD(_type, _num, _func, _pull)	\
	pins = SEC_PM_GPIO(_type, _num);		\
	PIN_PM_ ##_func;				\
	PIN_PM_ ##_pull

#define GPIO_PM_CONFIG_PUD_DRV(_type, _num, _func, _pull, _drv)	\
	pins = SEC_PM_GPIO(_type, _num);			\
	PIN_PM_ ##_func;					\
	PIN_PM_ ##_pull;					\
	pmic-gpio,drive-strength = <PIN_PM_ ##_drv>

#define SEC_ADC(type, num) <&type num>
#define SEC_ADC_OPT(type, num) ,<&type num>

#define GPIO_KEY_CONFIG(_code, _gpio, _wakeup, _interval)	\
	label = PIN_EXPAND(_code);							\
	linux,code = <_code>;						\
	gpios = <_gpio 0xf>;						\
	GPIO_KEY_ ##_wakeup;						\
	debounce-interval = <_interval>

#define SEC_INTERFACE_REF(type, num)	&type num


/* #include "../vibrator_vib_info.dtsi" */           /* From vibrator_vib_info.py */

&smd {
	vib_info: vibrator_info {
		status = "okay";
		compatible = "samsung,vib-info";
		functions = "INTENSITY", "HAPTIC_ENGINE", "INDEX_HAPTIC_PATTERN", "CAPABILITY_EXTERNAL_CONTROL", "PRIMITIVE_EFFECT_COMPOSE";
#if 1
		samsung,intensities = <0 2000 4000 6000 8000 10000>;
#else
		samsung,intensities = <>;
#endif

#if 1
		samsung,haptic_intensities = <0 3000 4000 6000 8000 10000>;
#else
		samsung,haptic_intensities = <>;
#endif
	};
};

/* #include "../sensorhub_s5e9945.dtsi" */           /* From sensorhub_s5e9945.py */
&contexthub_0 {
	multi-os = "disabled";
};

/ {
	fragment@model {
		target-path = "/";
		__overlay__ {
			shub {
				compatible = "shub";
			};
		};
	};
};

/* /home/dpi/qb5_8814/workspace/P4_1716/android/kernel/kmodule/sensorhub/lsi/s5e9945/dts/sensorhub_s5e9945.e1s.dtsi */
/ {
	fragment@model {
		target-path = "/";
		__overlay__ {
			shub {
				acc-lsm6dsvtr-position = <5>;
				mag-ak09918c-position = <4>;
				mag-ak09918c-array = /bits/ 8 <61 100 216 111 226 185 0 139 217 53 186 195 215 179 248 179 7 124 126 65 201 36 73 237 8 5 96>;
				mag-ak09918c-cover-array = /bits/ 8 <216 99 63 167 146 156 255 222 214 52 75 105 32 254 248 49 6 175 143 150 200 37 196 222 9 110 231>;
				light-position = /bits/ 32 <34 19 14 82 3 0>;
				fcd-axis = <1>;
				fcd-threshold = <(-1000)>;
				brightness-array-len = <11>;
				brightness-array = /bits/ 32 <19 48 54 58 63 67 70 73 75 77 100>;
				model-name = "S921";
			};
		};
	};
};
/* #include "../kq_mesh.dtsi" */                     /* From kq_mesh.py */
&smd {
	kq-mesh {
		compatible = "samsung,kq-mesh";
		status = "okay";

		features {
			user_nad {
				user_nad,copy_area_len = <2>;
				/* address-cells=<2>, .align PAGE_SIZE */
				user_nad,copy_area_address_arr = <0x8 0x80100000 0x8 0x92800000>;
				/* size-cells=<1>, .align PAGE_SIZE */
				user_nad,copy_area_size_arr = <0x0D700000 0x0CE00000>;
			};
		};
	};
};

/* #include "../sec_vibrator_inputff.dtsi" */        /* From sec_vibrator_inputff.py */

&smd {
	sec_vib_inputff {
		status = "okay";
		compatible = "sec_vib_inputff";

		haptic,normal_ratio = <100>;
		haptic,overdrive_ratio = <100>;
#if 0
		haptic,fold_string = "";

		haptic,tent_open_ratio = <100>;
		haptic,tent_close_ratio = <100>;

		/* Fold open & close ratio required for vertial motor,
		 * may not be required for Harizontal motor
		 */
		haptic,fold_open_ratio = <100>;
		haptic,fold_close_ratio = <100>;
#endif
		haptic,high_temp_ref = <48>;
		haptic,high_temp_ratio = <70>;
		haptic,f0_cal_way = "MANUAL";
	};
};


/* #include "../usb_vendor_notify.dtsi" */           /* From usb_vendor_notify.py */
&smd {
	usb_vendor_notify: usb_vendor_notify {
		compatible = "samsung,usb_vendor_notify";
	};

	usb_vendor_receiver: usb_vendor_receiver {
		compatible = "samsung,usb_vendor_receiver";
		notify = <&usb_vendor_notify>;
	};
};

/* #include "../abc_spec_manager_type1.dtsi" */      /* From abc_spec_manager_type1.py */
&smd {
	sec_abc {
		compatible = "samsung,sec_abc";
		status = "okay";
		abc_spec_type1 {
			module_list = "gpu", "gpu_qc", "gpu_qc", "camera", "camera", "vib", "tsp", "tsp_sub", "mm", "camera", "camera", "camera", "camera", "camera";
			name_list = "gpu_fault", "gpu_fault", "gpu_page_fault", "mipi_overflow", "i2c_fail", "int_gnd_short", "tsp_int_fault", "tsp_int_fault", "venus_hung", "mipi_error_rw1", "mipi_error_rs1", "mipi_error_rt1", "mipi_error_fw1", "mipi_error_rt2";
#ifndef CONFIG_SEC_FACTORY
			threshold_cnt = <20>, <2>, <20>, <1>, <1>, <25>, <10>, <10>, <10>, <1>, <1>, <1>, <1>, <1>;
			threshold_time = <1200>, <1200>, <1200>, <0>, <0>, <5>, <5>, <5>, <3>, <0>, <0>, <0>, <0>, <0>;
#else
			threshold_cnt = <20>, <2>, <20>, <4>, <4>, <25>, <10>, <10>, <10>, <4>, <4>, <4>, <4>, <4>;
			threshold_time = <1200>, <1200>, <1200>, <120>, <120>, <5>, <5>, <5>, <3>, <120>, <120>, <120>, <120>, <120>;
#endif
		};
	};
};

/* #include "../display_s6e3fae_e1s.dtsi" */         /* From display_s6e3fae_e1s.py */
/*
 * Samsung Exynos SoC series Panel driver
 *
 * Copyright (c) 2020 Samsung Electronics Co., Ltd
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 as
 * published by the Free Software Foundation.
 */

#include <dt-bindings/display/panel-display.h>
#include <dt-bindings/display/exynos-display.h>
#include "../display_s6e3fae_e1s_adaptive_mipi.dtsi"

&dsim_modes {
	/* FHD */
	1080x2340@120hs {
		exynos,pmsk = <
			0x5 0x59 0x0 0xAC00
			0x0 0x0 0x0 0x0
			0x0 0x0 0x0 0x0
			0x0 0x0
			>;
		exynos,hs-clk = <1362>;
		exynos,esc-clk = <20>;
		exynos,cmd_underrun_cnt = <3452>;
	};
	1080x2340@80hs {
		exynos,pmsk = <
			0x5 0x59 0x0 0xAC00
			0x0 0x0 0x0 0x0
			0x0 0x0 0x0 0x0
			0x0 0x0
			>;
		exynos,hs-clk = <1362>;
		exynos,esc-clk = <20>;
		exynos,cmd_underrun_cnt = <3452>;
	};
	1080x2340@60hs {
		exynos,pmsk = <
			0x5 0x59 0x0 0xAC00
			0x0 0x0 0x0 0x0
			0x0 0x0 0x0 0x0
			0x0 0x0
			>;
		exynos,hs-clk = <1362>;
		exynos,esc-clk = <20>;
		exynos,cmd_underrun_cnt = <3452>;
	};
	1080x2340@48hs {
		exynos,pmsk = <
			0x5 0x59 0x0 0xAC00
			0x0 0x0 0x0 0x0
			0x0 0x0 0x0 0x0
			0x0 0x0
			>;
		exynos,hs-clk = <1362>;
		exynos,esc-clk = <20>;
		exynos,cmd_underrun_cnt = <3452>;
	};
	1080x2340@30hs {
		exynos,pmsk = <
			0x5 0x59 0x0 0xAC00
			0x0 0x0 0x0 0x0
			0x0 0x0 0x0 0x0
			0x0 0x0
			>;
		exynos,hs-clk = <1362>;
		exynos,esc-clk = <20>;
		exynos,cmd_underrun_cnt = <3452>;
	};
	1080x2340@24hs {
		exynos,pmsk = <
			0x5 0x59 0x0 0xAC00
			0x0 0x0 0x0 0x0
			0x0 0x0 0x0 0x0
			0x0 0x0
			>;
		exynos,hs-clk = <1362>;
		exynos,esc-clk = <20>;
		exynos,cmd_underrun_cnt = <3452>;
	};
	1080x2340@10hs {
		exynos,pmsk = <
			0x5 0x59 0x0 0xAC00
			0x0 0x0 0x0 0x0
			0x0 0x0 0x0 0x0
			0x0 0x0
			>;
		exynos,hs-clk = <1362>;
		exynos,esc-clk = <20>;
		exynos,cmd_underrun_cnt = <3452>;
	};
	1080x2340@30ns {
		exynos,pmsk = <
			0x5 0x59 0x0 0xAC00
			0x0 0x0 0x0 0x0
			0x0 0x0 0x0 0x0
			0x0 0x0
			>;
		exynos,hs-clk = <1362>;
		exynos,esc-clk = <20>;
		exynos,cmd_underrun_cnt = <24522>;
	};
};

&drmdsim_0 {
	hs_pll_timing = <&dsim_hs_pll_timing>;
};

/ {
	fragment@panel_display_modes {
		target-path = "/";
		__overlay__ {
			e1s_panel_display_modes:
			e1s_panel_display_modes {
				native-mode = <&e1s_panel_display_mode_1080x2340_120hs>;
				exposed-mode = <
					&e1s_panel_display_mode_1080x2340_120hs
					&e1s_panel_display_mode_1080x2340_80hs
					&e1s_panel_display_mode_1080x2340_60hs
					&e1s_panel_display_mode_1080x2340_48hs
					&e1s_panel_display_mode_1080x2340_30hs
					&e1s_panel_display_mode_1080x2340_24hs
					&e1s_panel_display_mode_1080x2340_10hs
					&e1s_panel_display_mode_1080x2340_30hs_lp
					&e1s_panel_display_mode_1080x2340_30ns_lp
				>;

				/* fhd */
				e1s_panel_display_mode_1080x2340_120hs:
				e1s_panel_display_mode_1080x2340_120hs {
					id = PANEL_DISPLAY_MODE_1080x2340_120HS;
					width = <1080>;
					height = <2340>;
					/* timing parameters */
					refresh_rate = <120>;			/* logical refresh rate */
					refresh_mode = <REFRESH_MODE_HS>;
					panel_refresh_rate = <120>;		/* panel internal refresh rate */
					panel_refresh_mode = <PANEL_REFRESH_MODE_HS>;
					panel_te_st = <0>;				/* te rising */
					panel_te_ed = <0>;				/* te falling */
					panel_te_sw_skip_count = <0>;	/* s/w te modulation */
					panel_te_hw_skip_count = <0>;	/* h/w te modulation */
					panel_h_porch = <0 0 0>;
					panel_v_porch = <64 0 0>;	/* panel vbp:48, vfp:16, but for ap vblank set vbp:48+16, vfp:0 */
					/* dsc parameters */
					dsc_en = <1>;			/* 0:Disable, 1:Enable */
					dsc_cnt = <2>;			/* used DSC count */
					dsc_slice_num = <2>;	/* count of dsc slice */
					dsc_slice_w = <540>;	/* width of dsc slice */
					dsc_slice_h = <60>;	/* height of dsc slice */
					/* dsi parameters */
					cmd_lp_ref = <3730>;
					/*qos parameters */
					disp_qos_fps = <120>;
				};

				e1s_panel_display_mode_1080x2340_80hs:
				e1s_panel_display_mode_1080x2340_80hs {
					id = PANEL_DISPLAY_MODE_1080x2340_80HS;
					width = <1080>;
					height = <2340>;
					/* timing parameters */
					refresh_rate = <80>;			/* logical refresh rate */
					refresh_mode = <REFRESH_MODE_HS>;
					panel_refresh_rate = <80>;		/* panel internal refresh rate */
					panel_refresh_mode = <PANEL_REFRESH_MODE_HS>;
					panel_te_st = <0>;				/* te rising */
					panel_te_ed = <0>;				/* te falling */
					panel_te_sw_skip_count = <0>;	/* s/w te modulation */
					panel_te_hw_skip_count = <0>;	/* h/w te modulation */
					panel_h_porch = <0 0 0>;
					panel_v_porch = <64 0 0>;	/* panel vbp:48, vfp:16, but for ap vblank set vbp:48+16, vfp:0 */
					/* dsc parameters */
					dsc_en = <1>;			/* 0:Disable, 1:Enable */
					dsc_cnt = <2>;			/* used DSC count */
					dsc_slice_num = <2>;	/* count of dsc slice */
					dsc_slice_w = <540>;	/* width of dsc slice */
					dsc_slice_h = <60>;	/* height of dsc slice */
					/* dsi parameters */
					cmd_lp_ref = <3730>;
					/*qos parameters */
					disp_qos_fps = <120>;
				};

				e1s_panel_display_mode_1080x2340_60hs:
				e1s_panel_display_mode_1080x2340_60hs {
					id = PANEL_DISPLAY_MODE_1080x2340_60HS;
					width = <1080>;
					height = <2340>;
					/* timing parameters */
					refresh_rate = <60>;			/* logical refresh rate */
					refresh_mode = <REFRESH_MODE_HS>;
					panel_refresh_rate = <60>;		/* panel internal refresh rate */
					panel_refresh_mode = <PANEL_REFRESH_MODE_HS>;
					panel_te_st = <0>;				/* te rising */
					panel_te_ed = <0>;				/* te falling */
					panel_te_sw_skip_count = <0>;	/* s/w te modulation */
					panel_te_hw_skip_count = <0>;	/* h/w te modulation */
					panel_h_porch = <0 0 0>;
					panel_v_porch = <64 0 0>;	/* panel vbp:48, vfp:16, but for ap vblank set vbp:48+16, vfp:0 */
					/* dsc parameters */
					dsc_en = <1>;			/* 0:Disable, 1:Enable */
					dsc_cnt = <2>;			/* used DSC count */
					dsc_slice_num = <2>;	/* count of dsc slice */
					dsc_slice_w = <540>;	/* width of dsc slice */
					dsc_slice_h = <60>;	/* height of dsc slice */
					/* dsi parameters */
					cmd_lp_ref = <3730>;
					/*qos parameters */
					disp_qos_fps = <120>;
				};

				e1s_panel_display_mode_1080x2340_48hs:
				e1s_panel_display_mode_1080x2340_48hs {
					id = PANEL_DISPLAY_MODE_1080x2340_48HS;
					width = <1080>;
					height = <2340>;
					/* timing parameters */
					refresh_rate = <48>;			/* logical refresh rate */
					refresh_mode = <REFRESH_MODE_HS>;
					panel_refresh_rate = <48>;		/* panel internal refresh rate */
					panel_refresh_mode = <PANEL_REFRESH_MODE_HS>;
					panel_te_st = <0>;				/* te rising */
					panel_te_ed = <0>;				/* te falling */
					panel_te_sw_skip_count = <0>;	/* s/w te modulation */
					panel_te_hw_skip_count = <0>;	/* h/w te modulation */
					panel_h_porch = <0 0 0>;
					panel_v_porch = <64 0 0>;	/* panel vbp:48, vfp:16, but for ap vblank set vbp:48+16, vfp:0 */
					/* dsc parameters */
					dsc_en = <1>;			/* 0:Disable, 1:Enable */
					dsc_cnt = <2>;			/* used DSC count */
					dsc_slice_num = <2>;	/* count of dsc slice */
					dsc_slice_w = <540>;	/* width of dsc slice */
					dsc_slice_h = <60>;	/* height of dsc slice */
					/* dsi parameters */
					cmd_lp_ref = <3730>;
					/*qos parameters */
					disp_qos_fps = <120>;
				};

				e1s_panel_display_mode_1080x2340_30hs:
				e1s_panel_display_mode_1080x2340_30hs {
					id = PANEL_DISPLAY_MODE_1080x2340_30HS;
					width = <1080>;
					height = <2340>;
					/* timing parameters */
					refresh_rate = <30>;			/* logical refresh rate */
					refresh_mode = <REFRESH_MODE_HS>;
					panel_refresh_rate = <30>;		/* panel internal refresh rate */
					panel_refresh_mode = <PANEL_REFRESH_MODE_HS>;
					panel_te_st = <0>;				/* te rising */
					panel_te_ed = <0>;				/* te falling */
					panel_te_sw_skip_count = <0>;	/* s/w te modulation */
					panel_te_hw_skip_count = <0>;	/* h/w te modulation */
					panel_h_porch = <0 0 0>;
					panel_v_porch = <64 0 0>;	/* panel vbp:48, vfp:16, but for ap vblank set vbp:48+16, vfp:0 */
					/* dsc parameters */
					dsc_en = <1>;			/* 0:Disable, 1:Enable */
					dsc_cnt = <2>;			/* used DSC count */
					dsc_slice_num = <2>;	/* count of dsc slice */
					dsc_slice_w = <540>;	/* width of dsc slice */
					dsc_slice_h = <60>;	/* height of dsc slice */
					/* dsi parameters */
					cmd_lp_ref = <3730>;
					/*qos parameters */
					disp_qos_fps = <120>;
				};

				e1s_panel_display_mode_1080x2340_24hs:
				e1s_panel_display_mode_1080x2340_24hs {
					id = PANEL_DISPLAY_MODE_1080x2340_24HS;
					width = <1080>;
					height = <2340>;
					/* timing parameters */
					refresh_rate = <24>;			/* logical refresh rate */
					refresh_mode = <REFRESH_MODE_HS>;
					panel_refresh_rate = <24>;		/* panel internal refresh rate */
					panel_refresh_mode = <PANEL_REFRESH_MODE_HS>;
					panel_te_st = <0>;				/* te rising */
					panel_te_ed = <0>;				/* te falling */
					panel_te_sw_skip_count = <0>;	/* s/w te modulation */
					panel_te_hw_skip_count = <0>;	/* h/w te modulation */
					panel_h_porch = <0 0 0>;
					panel_v_porch = <64 0 0>;	/* panel vbp:48, vfp:16, but for ap vblank set vbp:48+16, vfp:0 */
					/* dsc parameters */
					dsc_en = <1>;			/* 0:Disable, 1:Enable */
					dsc_cnt = <2>;			/* used DSC count */
					dsc_slice_num = <2>;	/* count of dsc slice */
					dsc_slice_w = <540>;	/* width of dsc slice */
					dsc_slice_h = <60>;	/* height of dsc slice */
					/* dsi parameters */
					cmd_lp_ref = <3730>;
					/*qos parameters */
					disp_qos_fps = <120>;
				};

				e1s_panel_display_mode_1080x2340_10hs:
				e1s_panel_display_mode_1080x2340_10hs {
					id = PANEL_DISPLAY_MODE_1080x2340_10HS;
					width = <1080>;
					height = <2340>;
					/* timing parameters */
					refresh_rate = <10>;			/* logical refresh rate */
					refresh_mode = <REFRESH_MODE_HS>;
					panel_refresh_rate = <10>;		/* panel internal refresh rate */
					panel_refresh_mode = <PANEL_REFRESH_MODE_HS>;
					panel_te_st = <0>;				/* te rising */
					panel_te_ed = <0>;				/* te falling */
					panel_te_sw_skip_count = <0>;	/* s/w te modulation */
					panel_te_hw_skip_count = <11>;	/* h/w te modulation */
					panel_h_porch = <0 0 0>;
					panel_v_porch = <64 0 0>;	/* panel vbp:48, vfp:16, but for ap vblank set vbp:48+16, vfp:0 */
					/* dsc parameters */
					dsc_en = <1>;			/* 0:Disable, 1:Enable */
					dsc_cnt = <2>;			/* used DSC count */
					dsc_slice_num = <2>;	/* count of dsc slice */
					dsc_slice_w = <540>;	/* width of dsc slice */
					dsc_slice_h = <60>;	/* height of dsc slice */
					/* dsi parameters */
					cmd_lp_ref = <3730>;
					/*qos parameters */
					disp_qos_fps = <120>;
				};

				e1s_panel_display_mode_1080x2340_30hs_lp:
				e1s_panel_display_mode_1080x2340_30hs_lp {
					id = PANEL_DISPLAY_MODE_1080x2340_30HS;
					width = <1080>;
					height = <2340>;
					/* timing parameters */
					refresh_rate = <30>;			/* logical refresh rate */
					refresh_mode = <REFRESH_MODE_HS>;
					panel_refresh_rate = <30>;		/* panel internal refresh rate */
					panel_refresh_mode = <PANEL_REFRESH_MODE_HS>;
					panel_te_st = <0>;				/* te rising */
					panel_te_ed = <0>;				/* te falling */
					panel_te_sw_skip_count = <0>;	/* s/w te modulation */
					panel_te_hw_skip_count = <0>;	/* h/w te modulation */
					panel_h_porch = <0 0 0>;
					panel_v_porch = <64 0 1>;	/* panel vbp:48, vfp:16, but for ap vblank set vbp:48+16, vfp:0 */
					/* dsc parameters */
					dsc_en = <1>;			/* 0:Disable, 1:Enable */
					dsc_cnt = <2>;			/* used DSC count */
					dsc_slice_num = <2>;	/* count of dsc slice */
					dsc_slice_w = <540>;	/* width of dsc slice */
					dsc_slice_h = <60>;	/* height of dsc slice */
					/* dsi parameters */
					cmd_lp_ref = <3730>;
					/*qos parameters */
					disp_qos_fps = <120>;
					doze_mode;
				};

				e1s_panel_display_mode_1080x2340_30ns_lp:
				e1s_panel_display_mode_1080x2340_30ns_lp {
					id = PANEL_DISPLAY_MODE_1080x2340_30NS;
					width = <1080>;
					height = <2340>;
					/* timing parameters */
					refresh_rate = <30>;			/* logical refresh rate */
					refresh_mode = <REFRESH_MODE_NS>;
					panel_refresh_rate = <30>;		/* panel internal refresh rate */
					panel_refresh_mode = <PANEL_REFRESH_MODE_NS>;
					panel_te_st = <0>;				/* te rising */
					panel_te_ed = <0>;				/* te falling */
					panel_te_sw_skip_count = <0>;	/* s/w te modulation */
					panel_te_hw_skip_count = <0>;	/* h/w te modulation */
					panel_h_porch = <0 0 0>;
					panel_v_porch = <64 0 0>;	/* panel vbp:48, vfp:16, but for ap vblank set vbp:48+16, vfp:0 */
					/* dsc parameters */
					dsc_en = <1>;			/* 0:Disable, 1:Enable */
					dsc_cnt = <2>;			/* used DSC count */
					dsc_slice_num = <2>;	/* count of dsc slice */
					dsc_slice_w = <540>;	/* width of dsc slice */
					dsc_slice_h = <60>;	/* height of dsc slice */
					/* dsi parameters */
					cmd_lp_ref = <24522>;
					/*qos parameters */
					disp_qos_fps = <30>;
					doze_mode;
					panel_lp_mode;
				};
			};
		};
	};
};

/ {
	fragment@panel_drv {
		target-path = "/";
		__overlay__ {
			mafpc_0: mafpc_0 {
					 compatible = "samsung,panel-mafpc";
					 status = "okay";
			};

			panel_drv_0: panel_drv_0 {
				status = "okay";
				compatible = "samsung,panel-drv";
				panel,id = <0>;

				s6e3fae_e1s_power_ctrl:
				s6e3fae_e1s_power_ctrl {
					actions {
						fae_e1s_vci_on: vci-on {
							type = <PCTRL_REGULATOR_ENABLE>;
							reg = <&ddi_vci>;
						};
						fae_e1s_vdd3_on: vdd3-on {
							type = <PCTRL_REGULATOR_ENABLE>;
							reg = <&ddi_vdd3>;
						};
						fae_e1s_vddr_on: vddr-on {
							type = <PCTRL_REGULATOR_ENABLE>;
							reg = <&ddr_vddr>;
						};
						fae_e1s_vddr_off: vddr-off {
							type = <PCTRL_REGULATOR_DISABLE>;
							reg = <&ddr_vddr>;
						};
						fae_e1s_vci_off: vci-off {
							type = <PCTRL_REGULATOR_DISABLE>;
							reg = <&ddi_vci>;
						};
						fae_e1s_vdd3_off: vdd3-off {
							type = <PCTRL_REGULATOR_DISABLE>;
							reg = <&ddi_vdd3>;
						};
						fae_e1s_vddr_set_1p40: vddr-1p40 {
							type = <PCTRL_REGULATOR_SET_VOLTAGE>;
							reg = <&ddr_vddr>;
							value = <1400000>;
						};
						fae_e1s_vddr_set_1p50: vddr-1p50 {
							type = <PCTRL_REGULATOR_SET_VOLTAGE>;
							reg = <&ddr_vddr>;
							value = <1500000>;
						};
						fae_e1s_vddr_set_default: vddr-default {
							type = <PCTRL_REGULATOR_SET_VOLTAGE>;
							reg = <&ddr_vddr>;
							value = <1600000>;
						};
						fae_e1s_delay_1ms: delay-1ms {
							type = <PCTRL_DELAY_MSLEEP>;
							value = <1>;
						};
						fae_e1s_delay_2ms: delay-2ms {
							type = <PCTRL_DELAY_MSLEEP>;
							value = <2>;
						};
						fae_e1s_delay_10ms: delay-10ms {
							type = <PCTRL_DELAY_MSLEEP>;
							value = <10>;
						};
						fae_e1s_delay_11ms: delay-11ms {
							type = <PCTRL_DELAY_MSLEEP>;
							value = <11>;
						};
						fae_e1s_delay_50ms: delay-50ms {
							type = <PCTRL_DELAY_MSLEEP>;
							value = <50>;
						};
						fae_e1s_delay_200ms: delay-200ms {
							type = <PCTRL_DELAY_MSLEEP>;
							value = <200>;
						};
						fae_e1s_reset_high: reset-high {
							type = <PCTRL_GPIO_ENABLE>;
							gpio = <&disp_reset>;
						};
						fae_e1s_reset_low: reset-low {
							type = <PCTRL_GPIO_DISABLE>;
							gpio = <&disp_reset>;
						};
						fae_e1s_fd_on: fd-on {
							type = <PCTRL_REGULATOR_ENABLE>;
							reg = <&fd_elvdd>;
						};
						fae_e1s_fd_off: fd-off {
							type = <PCTRL_REGULATOR_DISABLE>;
							reg = <&fd_elvdd>;
						};
					};
					sequences {
						panel_boot_on = <&fae_e1s_vdd3_on &fae_e1s_vddr_on &fae_e1s_vddr_set_1p40 &fae_e1s_vci_on &fae_e1s_fd_on>;
						panel_power_on = <&fae_e1s_vdd3_on &fae_e1s_delay_1ms &fae_e1s_vddr_on &fae_e1s_delay_2ms &fae_e1s_vddr_set_1p40 &fae_e1s_delay_1ms &fae_e1s_vci_on &fae_e1s_delay_11ms &fae_e1s_reset_high &fae_e1s_delay_10ms>;
						panel_power_off = <&fae_e1s_reset_low &fae_e1s_delay_1ms &fae_e1s_vci_off &fae_e1s_delay_1ms &fae_e1s_vddr_off &fae_e1s_vddr_set_default &fae_e1s_delay_1ms &fae_e1s_vdd3_off &fae_e1s_delay_50ms>;
						panel_recovery_power_off = <&fae_e1s_reset_low &fae_e1s_delay_1ms &fae_e1s_vci_off &fae_e1s_delay_1ms &fae_e1s_vddr_off &fae_e1s_vddr_set_default &fae_e1s_delay_1ms &fae_e1s_vdd3_off &fae_e1s_delay_200ms>;
						panel_power_aolce_on = <&fae_e1s_vddr_set_1p50>;
						panel_power_aolce_off = <&fae_e1s_vddr_set_1p40>;
						panel_fd_enable = <&fae_e1s_fd_on>;
						panel_fd_disable = <&fae_e1s_fd_off>;
					};
				};

				s6e3fae_e1s_ap:s6e3fae_e1s_ap {
					/* S.LSI */
					SLSI,size = <66 142>;
					SLSI,hdr_formats = <(HDR_FORMAT_HDR10 | HDR_FORMAT_HLG | HDR_FORMAT_HDR10P)>;
					SLSI,hdr_max_luma = <4500000>;	/* 450 */
					SLSI,hdr_max_avg_luma = <1200000>;	/* 120 */
					SLSI,hdr_min_luma = <5>;		/* 0.0005 */
				};

				panels {
					s6e3fae_e1s: s6e3fae_e1s {
						ap-vendor-setting = <&s6e3fae_e1s_ap>;
						display-mode = <&e1s_panel_display_modes>;
						power-ctrl = <&s6e3fae_e1s_power_ctrl>;
						dqe-suffix = "s6e3fae_e1";
						adaptive-mipi = <&s6e3fae_e1s_adaptive_mipi_info>;
						sdp-adaptive-mipi = <&s6e3fae_e1s_sdp_adaptive_mipi_info>;
						id-mask = <
							PANEL_ID(0x000000) PANEL_MASK(0x000000)
						>;
					};
				};
			};
		};
	};
};


/* #include "../display_panel_manager.dtsi" */       /* From display_panel_manager.py */
/*
 * Samsung Exynos SoC series Panel driver
 *
 * Copyright (c) 2020 Samsung Electronics Co., Ltd
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 as
 * published by the Free Software Foundation.
 */

#include <dt-bindings/display/panel-display.h>

/ {
	fragment@panel_drv {
		target-path = "/";
		__overlay__ {
			panel_drv_0: panel_drv_0 {
				status = "okay";
				compatible = "samsung,panel-drv";
				panel,id = <0>;

				panel-lut {
#if 1
					panel_0 = <&s6e3fac_mu1s>;
#endif
#if 1
					panel_1 = <&s6e3fae_e1s>;
#endif
#if 0
					panel_2 = <&${panel_name_2}>;
#endif
#if 0
					panel_3 = <&${panel_name_3}>;
#endif
#if 0
					panel_4 = <&${panel_name_4}>;
#endif
#if 0
					panel_5 = <&${panel_name_5}>;
#endif
#if 0
					panel_6 = <&${panel_name_6}>;
#endif
#if 0
					panel_7 = <&${panel_name_7}>;
#endif
#if 0
					panel_8 = <&${panel_name_8}>;
#endif
#if 0
					panel_9 = <&${panel_name_9}>;
#endif
				};
			};
		};
	};
};


/* #include "../ap_slsi_s5e9945.dtsi" */             /* From ap_slsi_s5e9945.py */
#include <dt-bindings/clock/s5e9945.h>
#include "../../exynos/board/erd/erd9945-pmic.dtsi"

/* #include "../usb_notifier.dtsi" */                /* From usb_notifier.py */

&smd {
	usb_notifier {
		compatible = "samsung,usb-notifier";
		udc = <&udc>;
		status = "okay";
#if 1
		support_reverse_bypass_en;
#endif
	};
};


/* #include "../abc_common.dtsi" */                  /* From abc_common.py */
&smd {
	abc_hub {
		compatible = "samsung,abc_hub";
		status = "okay";
		bootc {
			bootc,time_spec_user = <100000>; /* user binary user build */
			bootc,time_spec_eng = <150000>; /* user binary eng build */
			bootc,time_spec_fac = <100000>; /* factory binary */
		};
	};
};

/* #include "../stk6d2x.dtsi" */                     /* From stk6d2x.py */
#include <dt-bindings/clock/s5e9945.h>
#if !defined(CONFIG_SEC_FACTORY_INTERPOSER)
&hsi2c_32 {
	status = "okay";
	clock-frequency = <1000000>;

	stk@47 {
		status = "okay";
		compatible = "stk,stk6d2x";

#if 0
		reg = <0x47 0x0 0x10>;
		als_rear,i3c = <1>;
#else
		reg = <0x47>;
#endif

#if 1
		als_rear,use_ext_clk;
		clocks = <&clock DOUT_DIV_CLKCMU_CIS_CLK6>, <&clock GATE_DFTMUX_CMU_QCH_CIS_CLK6>;
		clock-names = "div_clk", "mux_clk";

		pinctrl-names = "default", "sleep", "active";
		pinctrl-0 = <&sensor_mclk6_out>;
		pinctrl-1 = <&sensor_mclk6_out>;
		pinctrl-2 = <&sensor_mclk6_fn>;
#endif
		stk,als_scale = <1000>;
		//stk,als_is_dri;
#if 0
		vdd_1p8-supply	= < &${flicker_ldo_vdd} >;
#endif
#if 0
		vbus_1p8-supply	= < &${flicker_ldo_vbus} >;
#endif
	};
};
#endif


/* /home/dpi/qb5_8814/workspace/P4_1716/android/kernel/kmodule/camera/lsi/optics/stk6d2x/stk6d2x.e1s.02.dtsi */
#if !defined(CONFIG_SEC_FACTORY_INTERPOSER)
&hsi2c_32 {
	stk@47 {
		vdd_1p8-supply	= < &_ldo10_reg >;
	};
};
#endif
/* #include "../pmic_S2MPS27.dtsi" */                /* From pmic_S2MPS27.py */
#if 1800000 && 1800000
&l1_reg {
	regulator-name = "vdd_ldo1";
	regulator-min-microvolt = <1800000>;
	regulator-max-microvolt = <1800000>;
	 
	regulator-always-on;regulator-boot-on;
};
#endif

#if 0 && 0
&l2_reg {
	regulator-name = "vdd_ldo2";
	regulator-min-microvolt = <0>;
	regulator-max-microvolt = <0>;
	 
	
};
#endif

#if 0 && 0
&l3_reg {
	regulator-name = "vdd_ldo3";
	regulator-min-microvolt = <0>;
	regulator-max-microvolt = <0>;
	 
	
};
#endif

#if 0 && 0
&l4_reg {
	regulator-name = "vdd_ldo4";
	regulator-min-microvolt = <0>;
	regulator-max-microvolt = <0>;
	 
	
};
#endif

#if 0 && 0
&l5_reg {
	regulator-name = "vdd_ldo5";
	regulator-min-microvolt = <0>;
	regulator-max-microvolt = <0>;
	 
	
};
#endif

#if 0 && 0
&l6_reg {
	regulator-name = "vdd_ldo6";
	regulator-min-microvolt = <0>;
	regulator-max-microvolt = <0>;
	 
	
};
#endif

#if 0 && 0
&l7_reg {
	regulator-name = "vdd_ldo7";
	regulator-min-microvolt = <0>;
	regulator-max-microvolt = <0>;
	 
	
};
#endif

#if 0 && 0
&l8_reg {
	regulator-name = "vdd_ldo8";
	regulator-min-microvolt = <0>;
	regulator-max-microvolt = <0>;
	 
	
};
#endif

#if 3000000 && 3000000
&l9_reg {
	regulator-name = "vdd_ldo9";
	regulator-min-microvolt = <3000000>;
	regulator-max-microvolt = <3000000>;
	 
	/delete-property/ regulator-always-on;regulator-boot-on;
};
#endif

#if 3000000 && 3000000
&l10_reg {
	regulator-name = "vdd_ldo10";
	regulator-min-microvolt = <3000000>;
	regulator-max-microvolt = <3000000>;
	 
	regulator-boot-on;/delete-property/ regulator-always-on;
};
#endif

#if 0 && 0
&l11_reg {
	regulator-name = "vdd_ldo11";
	regulator-min-microvolt = <0>;
	regulator-max-microvolt = <0>;
	 
	
};
#endif

#if 1800000 && 1800000
&l12_reg {
	regulator-name = "vdd_ldo12";
	regulator-min-microvolt = <1800000>;
	regulator-max-microvolt = <1800000>;
	 
	/delete-property/ regulator-always-on;/delete-property/ regulator-boot-on;
};
#endif

#if 0 && 0
&l13_reg {
	regulator-name = "vdd_ldo13";
	regulator-min-microvolt = <0>;
	regulator-max-microvolt = <0>;
	 
	/delete-property/ regulator-always-on;/delete-property/ regulator-boot-on;
};
#endif

#if 1800000 && 1800000
&l14_reg {
	regulator-name = "vdd_ldo14";
	regulator-min-microvolt = <1800000>;
	regulator-max-microvolt = <1800000>;
	 regulator-ramp-delay = <12000>;regulator-initial-mode = <1>;
	regulator-always-on;
};
#endif

#if 0 && 0
&l15_reg {
	regulator-name = "vdd_ldo15";
	regulator-min-microvolt = <0>;
	regulator-max-microvolt = <0>;
	 
	
};
#endif

#if 0 && 0
&l16_reg {
	regulator-name = "vdd_ldo16";
	regulator-min-microvolt = <0>;
	regulator-max-microvolt = <0>;
	 
	
};
#endif

#if 1800000 && 1800000
&l17_reg {
	regulator-name = "vdd_ldo17";
	regulator-min-microvolt = <1800000>;
	regulator-max-microvolt = <1800000>;
	 
	regulator-boot-on;/delete-property/ regulator-always-on;
};
#endif

#if 1800000 && 1800000
&l18_reg {
	regulator-name = "vdd_ldo18";
	regulator-min-microvolt = <1800000>;
	regulator-max-microvolt = <1800000>;
	 
	/delete-property/ regulator-always-on;regulator-boot-on;
};
#endif

/* #include "../vibrator_cs40l26.dtsi" */            /* From vibrator_cs40l26.py */
#define USE_VIBRATOR_i2c

&pinctrl_0 {
	motor_int_default: motor-int {
		GPIO_CONFIG_PUD(AP,gpa3,gpa3,7, FUNC_INPUT_WAKEUP, PULL_NONE);
	};
};

&pinctrl_7 {
	motor_rst_default: motor-rst {
		GPIO_CONFIG_PUD_DRV(AP,gpp2,gpp2,2, FUNC_OUTPUT, PULL_NONE, DRV_LV1);
		samsung,pin-con-pdn = <3>;
		samsung,pin-pud-pdn = <0>;
	};
};

#if defined(USE_VIBRATOR_i3c)
&${vib_i3c} {
	status = "okay";
	i2c-scl-hz = <1000000>;
	cs40l26a: cs40l26a@40 {
		reg = <0x40 0x0 0x10>;
	};
};
#elif defined(USE_VIBRATOR_i2c)
&hsi2c_4 {
	status = "okay";
	clock-frequency = <1000000>;
	cs40l26a: cs40l26a@40 {
		reg = <0x40>;
	};
};
#endif


#include "../cs40l26.dtsi"

/* #include "../abc_cond.dtsi" */                    /* From abc_cond.py */
#if 1
&pinctrl_0 {
	sub_detect_conn_setting: sub-detect-conn-setting {
		samsung,pins = SEC_GPIO(AP,gpa2,gpa2,5);
		samsung,pin-function = <0xf>;
		samsung,pin-pud = <0>;
		samsung,pin-drv = <0>;
	};
};
#endif

#if 0
&${gpio_sub_connect_conn_parent2} {
	sub_detect_conn_setting2: sub-detect-conn-setting2 {
		samsung,pins = SEC_GPIO(${gpio_sub_connect_conn2});
		samsung,pin-function = <0xf>;
		samsung,pin-pud = <0>;
		samsung,pin-drv = <0>;
	};
};
#endif

#if 0
&${gpio_cam_connect_conn_parent} {
	cam_detect_conn_setting: cam-detect-conn-setting {
		samsung,pins = SEC_GPIO(${gpio_cam_connect_conn});
		samsung,pin-function = <0xf>;
		samsung,pin-pud = <0>;
		samsung,pin-drv = <0>;
	};
};
#endif

&smd {
	sec_abc_detect_conn {
		compatible = "samsung,sec_abc_detect_conn";
		status = "okay";
#if 1 && 0 && 0
		sec,det_conn_gpios = <SEC_GPIO_REF(AP,gpa2,gpa2,5) 0
							SEC_GPIO_REF(${gpio_sub_connect_conn2}) 0
							SEC_GPIO_REF(${gpio_cam_connect_conn}) 0>;
		sec,det_conn_name = "SUB_CONNECT", "SUB_CONNECT2", "CAM_CONNECT";
		sec,det_conn_irq_type = <3>; /* BOTH EDGE */
		pinctrl-0 = <&sub_detect_conn_setting &sub_detect_conn_setting2 &cam_detect_conn_setting>;
#elif 1 && 0
		sec,det_conn_gpios = <SEC_GPIO_REF(AP,gpa2,gpa2,5) 0
							SEC_GPIO_REF(${gpio_cam_connect_conn}) 0>;
		sec,det_conn_name = "SUB_CONNECT", "CAM_CONNECT";
		sec,det_conn_irq_type = <3>; /* BOTH EDGE */
		pinctrl-0 = <&sub_detect_conn_setting &cam_detect_conn_setting>;
#elif 1 && 0
		sec,det_conn_gpios = <SEC_GPIO_REF(AP,gpa2,gpa2,5) 0
							SEC_GPIO_REF(${gpio_sub_connect_conn2}) 0>;
		sec,det_conn_name = "SUB_CONNECT", "SUB_CONNECT2";
		sec,det_conn_irq_type = <3>; /* BOTH EDGE */
		pinctrl-0 = <&sub_detect_conn_setting &sub_detect_conn_setting2>;
#elif 1
		sec,det_conn_gpios = <SEC_GPIO_REF(AP,gpa2,gpa2,5) 0>;
		sec,det_conn_name = "SUB_CONNECT";
		sec,det_conn_irq_type = <3>; /* BOTH EDGE */
		pinctrl-0 = <&sub_detect_conn_setting>;
#elif 0
		sec,det_conn_gpios = <SEC_GPIO_REF(${gpio_cam_connect_conn}) 0>;
		sec,det_conn_name = "CAM_CONNECT";
		sec,det_conn_irq_type = <3>; /* BOTH EDGE */
		pinctrl-0 = <&cam_detect_conn_setting>;
#endif
		pinctrl-names = "default";
	};
};

/* #include "../s2dos05.dtsi" */                     /* From s2dos05.py */
&pinctrl_0 {
	s2dos05_irq: s2dos05_irq {
		GPIO_CONFIG_PUD(AP,gpa2,gpa2,6, FUNC_INPUT, PULL_NONE);
	};
};

&hsi2c_0 {
	#address-cells = <1>;
	#size-cells = <0>;
	status = "okay";
	s2dos05_pmic@60 {
		compatible = "samsung,s2dos05pmic";
		reg = <0x60>;
		s2dos05,wakeup;
		pinctrl-names = "default";
		pinctrl-0 = <&s2dos05_irq>;
		sec_disp_pmic_name = "disp_pmic";
		s2dos05,s2dos05_int = <SEC_GPIO_REF(AP,gpa2,gpa2,6) 0>;
#if defined(CONFIG_SEC_FACTORY)
		adc_mode = <2>;
#else
		adc_mode = <0>; /* 0 : disable, 1 : current meter, 2 : power meter */
#endif
		adc_sync_mode = <2>; /* 1 : sync mode, 2 : async mode */
		regulators {
			s2dos05_buck1: s2dos05-buck1 {
				regulator-name = "s2dos05-buck1";
				regulator-min-microvolt	= <850000>;
				regulator-max-microvolt	= <2100000>;
				regulator-boot-on;
				 
			};
			s2dos05_l1: s2dos05-ldo1 {
				regulator-name = "s2dos05-l1";
				regulator-min-microvolt = <1500000>;
				regulator-max-microvolt = <2000000>;
				
				 
			};
			s2dos05_l2: s2dos05-ldo2 {
				regulator-name = "s2dos05-l2";
				regulator-min-microvolt = <1800000>;
				regulator-max-microvolt = <1800000>;
				
				 
			};
			s2dos05_l3: s2dos05-ldo3 {
				regulator-name = "s2dos05-l3";
				regulator-min-microvolt = <3000000>;
				regulator-max-microvolt = <3000000>;
				
				 
			};
			s2dos05_l4: s2dos05-ldo4 {
				regulator-name = "s2dos05-l4";
				regulator-min-microvolt = <2700000>;
				regulator-max-microvolt = <3775000>;
				
				 
			};
			s2dos05_elvss: s2dos05-elvss-ssd {
				regulator-name = "elvss_ssd";
				regulator-min-microamp = <0>;
				regulator-max-microamp = <8000>;
			};
			s2dos05_aee_fd: s2dos05-avdd-elvdd-elvss-fd {
				regulator-name = "avdd_elvdd_elvss_fd";
			};
		};
	};
};

/* #include "../hall_ic.dtsi" */                     /* From hall_ic.py */
/*
 * Hall ic device tree source
 *
 * Copyright (c) 2017 Samsung Electronics Co., Ltd.
 *		http://www.samsung.com
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 as
 * published by the Free Software Foundation.
 */

&smd {
	hall_ic: hall_ic {
		status = "okay";
		compatible = "hall_ic";
		pinctrl-names = "default";
		pinctrl-0 = <
#if 1
		&hall_irq
#endif
#if 0
		&certify_hall_irq
#endif
#if 0
		&hall_wacom_irq
#endif
#if 0
		&folder_hall_irq
#endif
		>;
#if 1
		hall_ic,debounce-interval = <50>;
#endif
#if 1
		hall: hall {
			name = "hall";
			event = <0x15>;
			gpios = <SEC_GPIO_REF(AP,gpa1,gpa1,3) 1>;
		};
#endif
#if 0
		certify_hall: certify_hall {
			name = "certify_hall";
			event = <0x1b>;
			gpios = <SEC_GPIO_REF(${certify_hall_gpio}) 1>;
		};
#endif
#if 0
		hall_wacom: hall_wacom {
			name = "hall_wacom";
			event = <0x1e>;
			gpios = <SEC_GPIO_REF(${wacom_hall_gpio}) 1>;
		};
#endif
#if 0
		flip: flip {
			name = "flip";
			event = <0x00>;
			gpios = <SEC_GPIO_REF(${folder_hall_gpio}) 1>;
		};
#endif
	};

#if 0
	hall_logical {
		status = "okay";
		compatible = "hall_logical";
	};
#endif
};

#if 1
&pinctrl_0 {
	hall_irq: hall_irq {
		GPIO_CONFIG_PUD_DRV(AP,gpa1,gpa1,3, FUNC_INPUT_WAKEUP, PULL_NONE, DRV_LV1);
#if 0
		power-source = <1>;
#endif
	};
};
#endif

#if 0
&${certify_hall_parent} {
	certify_hall_irq: certify_hall_irq {
		GPIO_CONFIG_PUD_DRV(${certify_hall_gpio}, FUNC_INPUT_WAKEUP, PULL_NONE, DRV_LV1);
#if 0
		power-source = <1>;
#endif
	};
};
#endif

#if 0
&${wacom_hall_parent} {
	hall_wacom_irq: hall_wacom_irq {
		GPIO_CONFIG_PUD_DRV(${wacom_hall_gpio}, FUNC_INPUT_WAKEUP, PULL_NONE, DRV_LV1);
#if 0
		power-source = <1>;
#endif
	};
};
#endif

#if 0
&${folder_hall_parent} {
	folder_hall_irq: folder_hall_irq {
		GPIO_CONFIG_PUD_DRV(${folder_hall_gpio}, FUNC_INPUT_WAKEUP, PULL_NONE, DRV_LV1);
	};
};
#endif

/* #include "../tusb2e11.dtsi" */                    /* From tusb2e11.py */
/*
 * Copyright (c) 2019 Samsung Electronics Co., Ltd.
 *		http://www.samsung.com
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 as
 * published by the Free Software Foundation.
 */

#if 0
&${repeater_parent} {
	eusb_ctrl: eusb_ctrl_sel {
		GPIO_CONFIG_PUD_DRV(${repeater_gpio}, FUNC_OUTPUT_LOW, PULL_DOWN, DRV_LV1);
	};
};
#endif

&hsi2c_34 {
	#address-cells = <1>;
	#size-cells = <0>;
	status = "okay";
	tusb2e11-repeater@3E {
		compatible = "tusb2e11-repeater";
		reg = <0x3E>;
		status = "okay";
#if 0
		pinctrl-name = "default";
		pinctrl-0 = <&eusb_ctrl>;
		eusb,gpio_eusb_ctrl = <SEC_GPIO_REF(${repeater_gpio}) 1>;
#endif
		repeater_tune_param {
			repeater_tune_cnt = /bits/ 8 <0x5>;
			/* 0xffffffff means using default value */
			repeater_tune1 {
				tune_name = "usb2_tx_adjust_port1";
				tune_value = /bits/ 8 <0x70 0x5d>;
			};

			repeater_tune2 {
				tune_name = "usb2_hs_rx_pre_emphasus_p1";
				tune_value = /bits/ 8 <0x71 0x2e>;
			};

			repeater_tune3 {
				tune_name = "usb2_disconnect_squelch_port1";
				tune_value = /bits/ 8 <0x73 0x86>;
			};

			repeater_tune4 {
				tune_name = "eusb_rx_adjust_port1";
				tune_value = /bits/ 8 <0x79 0x40>;
			};

			repeater_tune5 {
				tune_name = "E_SOP_EOP";
				tune_value = /bits/ 8 <0x76 0x27>;
			};
		};
	};
};


/* #include "../pmic_S2MPS28.dtsi" */                /* From pmic_S2MPS28.py */
#if 1
#if 0 && 0
&s1_l1_reg {
	-name = "vdd_ldo1s1";
	-min-microvolt = <0>;
	regulator-max-microvolt = <0>;
	 
	
};
#endif

#if 0 && 0
&s1_l2_reg {
	regulator-name = "vdd_ldo2s1";
	regulator-min-microvolt = <0>;
	regulator-max-microvolt = <0>;
	 
	
};
#endif

#if 0 && 0
&s1_l3_reg {
	regulator-name = "vdd_ldo3s1";
	regulator-min-microvolt = <0>;
	regulator-max-microvolt = <0>;
	 
	
};
#endif

#if 0 && 0
&s1_l4_reg {
	regulator-name = "vdd_ldo4s1";
	regulator-min-microvolt = <0>;
	regulator-max-microvolt = <0>;
	 
	
};
#endif

#if 0 && 0
&s1_l5_reg {
	regulator-name = "vdd_ldo5s1";
	regulator-min-microvolt = <0>;
	regulator-max-microvolt = <0>;
	 
	
};
#endif
#endif /* s2mps28_1_interface */

#if 1
#if 0 && 0
&s2_l1_reg {
	regulator-name = "vdd_ldo1s2";
	regulator-min-microvolt = <0>;
	regulator-max-microvolt = <0>;
	 
	
};
#endif

#if 0 && 0
&s2_l2_reg {
	regulator-name = "vdd_ldo2s2";
	regulator-min-microvolt = <0>;
	regulator-max-microvolt = <0>;
	 
	
};
#endif

#if 0 && 0
&s2_l3_reg {
	regulator-name = "vdd_ldo3s2";
	regulator-min-microvolt = <0>;
	regulator-max-microvolt = <0>;
	 
	
};
#endif

#if 0 && 0
&s2_l4_reg {
	regulator-name = "vdd_ldo4s2";
	regulator-min-microvolt = <0>;
	regulator-max-microvolt = <0>;
	 
	
};
#endif

#if 0 && 0
&s2_l5_reg {
	regulator-name = "vdd_ldo5s2";
	regulator-min-microvolt = <0>;
	regulator-max-microvolt = <0>;
	 
	
};
#endif
#endif /* s2mps28_2_interface */

#if 1
#if 0 && 0
&s3_l1_reg {
	regulator-name = "vdd_ldo1s3";
	regulator-min-microvolt = <0>;
	regulator-max-microvolt = <0>;
	 
	
};
#endif

#if 0 && 0
&s3_l2_reg {
	regulator-name = "vdd_ldo2s3";
	regulator-min-microvolt = <0>;
	regulator-max-microvolt = <0>;
	 
	
};
#endif

#if 0 && 0
&s3_l3_reg {
	regulator-name = "vdd_ldo3s3";
	regulator-min-microvolt = <0>;
	regulator-max-microvolt = <0>;
	 
	
};
#endif

#if 0 && 0
&s3_l4_reg {
	regulator-name = "vdd_ldo4s3";
	regulator-min-microvolt = <0>;
	regulator-max-microvolt = <0>;
	 
	
};
#endif

#if 0 && 0
&s3_l5_reg {
	regulator-name = "vdd_ldo5s3";
	regulator-min-microvolt = <0>;
	regulator-max-microvolt = <0>;
	 
	
};
#endif
#endif /* s2mps28_3_interface */

#if 1
#if 0 && 0
&s4_l1_reg {
	regulator-name = "vdd_ldo1s4";
	regulator-min-microvolt = <0>;
	regulator-max-microvolt = <0>;
	 
	
};
#endif

#if 0 && 0
&s4_l2_reg {
	regulator-name = "vdd_ldo2s4";
	regulator-min-microvolt = <0>;
	regulator-max-microvolt = <0>;
	 
	
};
#endif

#if 0 && 0
&s4_l3_reg {
	regulator-name = "vdd_ldo3s4";
	regulator-min-microvolt = <0>;
	regulator-max-microvolt = <0>;
	 
	
};
#endif

#if 0 && 0
&s4_l4_reg {
	regulator-name = "vdd_ldo4s4";
	regulator-min-microvolt = <0>;
	regulator-max-microvolt = <0>;
	 
	
};
#endif

#if 0 && 0
&s4_l5_reg {
	regulator-name = "vdd_ldo5s4";
	regulator-min-microvolt = <0>;
	regulator-max-microvolt = <0>;
	 
	
};
#endif
#endif /* s2mps28_4_interface */

#if 1
#if 0 && 0
&s5_l1_reg {
	regulator-name = "vdd_ldo1s5";
	regulator-min-microvolt = <0>;
	regulator-max-microvolt = <0>;
	 
	
};
#endif

#if 0 && 0
&s5_l2_reg {
	regulator-name = "vdd_ldo2s5";
	regulator-min-microvolt = <0>;
	regulator-max-microvolt = <0>;
	 
	
};
#endif

#if 0 && 0
&s5_l3_reg {
	regulator-name = "vdd_ldo3s5";
	regulator-min-microvolt = <0>;
	regulator-max-microvolt = <0>;
	 
	
};
#endif

#if 0 && 0
&s5_l4_reg {
	regulator-name = "vdd_ldo4s5";
	regulator-min-microvolt = <0>;
	regulator-max-microvolt = <0>;
	 
	
};
#endif

#if 0 && 0
&s5_l5_reg {
	regulator-name = "vdd_ldo5s5";
	regulator-min-microvolt = <0>;
	regulator-max-microvolt = <0>;
	 
	
};
#endif
#endif /* s2mps28_5_interface */

/* #include "../pmic_S2MPM07.dtsi" */                /* From pmic_S2MPM07.py */
&acpm_mfd_bus6 {
	status = "okay";
	#address-cells = <1>;
	#size-cells = <0>;

	s2mpm07_mfd: s2mpm07mfd@3f {
		compatible = "samsung,s2mpm07mfd";
		acpm-ipc-channel = <2>;
		s2mpm07,wakeup = "enabled";
		reg = <0x7f>;

		/* s2mpm07-gpio */
		s2mpm07_gpio: s2mpm07-gpio {
			gpio-controller;
			#gpio-cells = <2>;
			samsung,npins = <8>;
			status = "okay";
		};

		regulators {
			r_b1_reg: BUCK1 {
				regulator-name = "buck1r";
				regulator-min-microvolt = <400000>;
				regulator-max-microvolt = <1300000>;
				regulator-ramp-delay = <6000>;regulator-initial-mode = <3>;
				
			};

			r_b_sr1_reg: BUCK_SR1 {
				regulator-name = "buck_sr1r";
				regulator-min-microvolt = <600000>;
				regulator-max-microvolt = <1350000>;
				regulator-ramp-delay = <6000>;
				regulator-initial-mode = <3>;
				regulator-always-on;
			};
/*
			r_l1_reg: LDO1 {
				regulator-name = "vdd_ldo1r";
				regulator-min-microvolt = <400000>;
				regulator-max-microvolt = <1300000>;
				regulator-ramp-delay = <12000>;
				regulator-initial-mode = <3>;
				regulator-always-on;
			};

			r_l2_reg: LDO2 {
				regulator-name = "vdd_ldo2r";
				regulator-min-microvolt = <400000>;
				regulator-max-microvolt = <1300000>;
				regulator-ramp-delay = <12000>;
				regulator-initial-mode = <3>;
				regulator-always-on;
			};

			r_l3_reg: LDO3 {
				regulator-name = "vdd_ldo3r";
				regulator-min-microvolt = <400000>;
				regulator-max-microvolt = <1300000>;
				regulator-ramp-delay = <12000>;
				regulator-initial-mode = <3>;
				regulator-always-on;
			};

			r_l4_reg: LDO4 {
				regulator-name = "vdd_ldo4r";
				regulator-min-microvolt = <400000>;
				regulator-max-microvolt = <1300000>;
				regulator-ramp-delay = <12000>;
				regulator-initial-mode = <3>;
				regulator-always-on;
			};

			r_l5_reg: LDO5 {
				regulator-name = "vdd_ldo5r";
				regulator-min-microvolt = <400000>;
				regulator-max-microvolt = <1300000>;
				regulator-ramp-delay = <12000>;
				regulator-initial-mode = <3>;
				regulator-always-on;

			};

			r_l6_reg: LDO6 {
				regulator-name = "vdd_ldo6r";
				regulator-min-microvolt = <1600000>;
				regulator-max-microvolt = <1900000>;
				regulator-ramp-delay = <12000>;
				regulator-initial-mode = <3>;
				regulator-always-on;
			};

			r_l7_reg: LDO7 {
				regulator-name = "vdd_ldo7r";
				regulator-min-microvolt = <400000>;
				regulator-max-microvolt = <1300000>;
				regulator-ramp-delay = <12000>;
				regulator-initial-mode = <3>;
				regulator-always-on;
			};

			r_l8_reg: LDO8 {
				regulator-name = "vdd_ldo8r";
				regulator-min-microvolt = <400000>;
				regulator-max-microvolt = <1300000>;
				regulator-ramp-delay = <12000>;
				regulator-initial-mode = <3>;
				regulator-always-on;
			};

			r_l9_reg: LDO9 {
				regulator-name = "vdd_ldo9r";
				regulator-min-microvolt = <400000>;
				regulator-max-microvolt = <1300000>;
				regulator-ramp-delay = <12000>;regulator-initial-mode = <3>;
				
			};

			r_l10_reg: LDO10 {
				regulator-name = "vdd_ldo10r";
				regulator-min-microvolt = <1600000>;
				regulator-max-microvolt = <1900000>;
				regulator-ramp-delay = <12000>;
				regulator-initial-mode = <3>;
				regulator-always-on;
			};

			r_l11_reg: LDO11 {
				regulator-name = "vdd_ldo11r";
				regulator-min-microvolt = <1600000>;
				regulator-max-microvolt = <3375000>;
				regulator-ramp-delay = <12000>;regulator-initial-mode = <3>;
				
			};

			r_l12_reg: LDO12 {
				regulator-name = "vdd_ldo12r";
				regulator-min-microvolt = <400000>;
				regulator-max-microvolt = <1300000>;
				regulator-ramp-delay = <12000>;
				regulator-initial-mode = <3>;
				regulator-always-on;
			};

			r_l13_reg: LDO13 {
				regulator-name = "vdd_ldo13r";
				regulator-min-microvolt = <400000>;
				regulator-max-microvolt = <1300000>;
				regulator-ramp-delay = <12000>;
				regulator-initial-mode = <3>;
				regulator-always-on;
			};

			r_l14_reg: LDO14 {
				regulator-name = "vdd_ldo14r";
				regulator-min-microvolt = <400000>;
				regulator-max-microvolt = <1300000>;
				regulator-ramp-delay = <12000>;
				regulator-initial-mode = <3>;
				regulator-always-on;
			};

			r_l15_reg: LDO15 {
				regulator-name = "vdd_ldo15r";
				regulator-min-microvolt = <400000>;
				regulator-max-microvolt = <1300000>;
				regulator-ramp-delay = <12000>;
				regulator-initial-mode = <3>;
				regulator-always-on;
			};

			r_l16_reg: LDO16 {
				regulator-name = "vdd_ldo16r";
				regulator-min-microvolt = <1600000>;
				regulator-max-microvolt = <1900000>;
				regulator-ramp-delay = <12000>;
				regulator-initial-mode = <3>;
				regulator-always-on;
			};

			r_l17_reg: LDO17 {
				regulator-name = "vdd_ldo17r";
				regulator-min-microvolt = <1600000>;
				regulator-max-microvolt = <1900000>;
				regulator-ramp-delay = <12000>;
				regulator-initial-mode = <3>;
				regulator-always-on;
			};
*/
			r_l18_reg: LDO18 {
				regulator-name = "VDD_TELECAM_AF_2P8";
				regulator-min-microvolt = <2800000>;
				regulator-max-microvolt = <2800000>;
				regulator-ramp-delay = <12000>;regulator-initial-mode = <3>;
				
			};

			r_l19_reg: LDO19 {
				regulator-name = "VDD_TELECAM_OIS_2P8";
				regulator-min-microvolt = <2800000>;
				regulator-max-microvolt = <2800000>;
				regulator-ramp-delay = <12000>;regulator-initial-mode = <3>;
				
			};
/*
			r_l20_reg: LDO20 {
				regulator-name = "vdd_ldo20r";
				regulator-min-microvolt = <1800000>;
				regulator-max-microvolt = <3375000>;
				regulator-ramp-delay = <12000>;
				regulator-initial-mode = <3>;
				regulator-always-on;
			};

			r_l21_reg: LDO21 {
				regulator-name = "vdd_ldo21r";
				regulator-min-microvolt = <1800000>;
				regulator-max-microvolt = <3375000>;
				regulator-ramp-delay = <12000>;
				regulator-initial-mode = <3>;
				regulator-always-on;
			};
*/
		}; /* end of regulators */
	}; /* end of s2mpm07mfd@00 */
}; /* end of acpm_mfd_bus@11a20000 */

/* #include "../pmic_S2MPA05.dtsi" */                /* From pmic_S2MPA05.py */
/* USE_AS_AP_SUB_PMIC */
#if !(1)
#if 1800000 && 1800000
&s_l1_reg {
	regulator-name = "VDD_WIDE_TELE_OIS_1P8";
	regulator-min-microvolt = <1800000>;
	regulator-max-microvolt = <1800000>;
	  regulator-ramp-delay = <12000>; regulator-initial-mode = <3>;
	
};
#endif

#if 0 && 0
&s_l2_reg {
	regulator-name = "vdd_ldo2s";
	regulator-min-microvolt = <0>;
	regulator-max-microvolt = <0>;
	 
	
};
#endif

#if 0 && 0
&s_l3_reg {
	regulator-name = "vdd_ldo3s";
	regulator-min-microvolt = <0>;
	regulator-max-microvolt = <0>;
	 
	
};
#endif

#if 0 && 0
&s_l4_reg {
	regulator-name = "vdd_ldo4s";
	regulator-min-microvolt = <0>;
	regulator-max-microvolt = <0>;
	 
	
};
#endif
#else
/* USE_AS_CAMERA_PMIC */
#if 1800000 && 1800000
&e_l1_reg {
	regulator-name = "VDD_WIDE_TELE_OIS_1P8";
	regulator-min-microvolt = <1800000>;
	regulator-max-microvolt = <1800000>;
	  regulator-ramp-delay = <12000>; regulator-initial-mode = <3>;
	
};
#endif

#if 0 && 0
&e_l2_reg {
	regulator-name = "vdd_ldo2s";
	regulator-min-microvolt = <0>;
	regulator-max-microvolt = <0>;
	 
	
};
#endif

#if 0 && 0
&e_l3_reg {
	regulator-name = "vdd_ldo3s";
	regulator-min-microvolt = <0>;
	regulator-max-microvolt = <0>;
	 
	
};
#endif

#if 0 && 0
&e_l4_reg {
	regulator-name = "vdd_ldo4s";
	regulator-min-microvolt = <0>;
	regulator-max-microvolt = <0>;
	 
	
};
#endif
#endif

/* #include "../pca9481_charger.dtsi" */             /* From pca9481_charger.py */
&hsi2c_16 {
	status = "okay";

	pca9481_charger: pca9481@57 {
		compatible = "nxp,pca9481";
		reg = <0x57>;

		pca9481,input-current-limit = <3000000>; /* 3.0A */
		pca9481,charging-current = <6000000>; /* 6.0A */
		pca9481,input-itopoff = <500000>; /* 500mA */
		pca9481,sense-resistance = <2>; /* 5mOhm */
		pca9481,sense-config = <0>;	/* Bottom side */
		pca9481,switching-frequency = <1000>; /* 1000kHz */
		pca9481,ntc0-threshold = <1110000>; /* 1.11V */
		pca9481,ntc1-threshold = <495000>;	/* 0.495V */
		pca9481,ntc-en = <0>; /* Disable NTC protection function */
		pca9481,chg-mode = <1>; /* 2:1 direct charging mode */
		pca9481,cv-polling = <2000>; /* 2000ms */
		pca9481,step1-cv=<4200000>; /* 4200mV */
	};
};

/* /home/dpi/qb5_8814/workspace/P4_1716/android/kernel/kmodule/battery/stable/eureka/charger/pca9481/pca9481_charger.e1s.dtsi */
&pca9481_charger {
	pca9481,input-itopoff = <350000>; /* 350mA */
	pca9481,fpdo_dc_input-itopoff = <1900000>; /* 1900mA */
	pca9481,fpdo_dc_vnow-topoff = <4140000>; /* 4140mV */
	nxp,switching-frequency-low = <300>;
	pca9481,switching-frequency = <300>; /* 300kHz */
};

/* /home/dpi/qb5_8814/workspace/P4_1716/android/kernel/kmodule/battery/stable/eureka/charger/pca9481/pca9481_charger.e1s.00.dtsi */
&pca9481_charger {
	pca9481,switching-frequency = <1000>; /* 1000kHz */
};

/* #include "../ptn3222.dtsi" */                     /* From ptn3222.py */
/*
 * Copyright (c) 2023 Samsung Electronics Co., Ltd.
 *		http://www.samsung.com
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 as
 * published by the Free Software Foundation.
 */

&hsi2c_34 {
	#address-cells = <1>;
	#size-cells = <0>;
	status = "okay";
	ptn3222-repeater@4F {
		compatible = "ptn3222-repeater";
		reg = <0x4F>;
		status = "okay";
		repeater_tune_param {
			repeater_tune_cnt = /bits/ 8 <0x5>;
			repeater_tune1 {
				tune_name = "usb2_rx_control";
				tune_value = /bits/ 8 <0x06 0x30>;
			};
			repeater_tune2 {
				tune_name = "usb2_tx_control1";
				tune_value = /bits/ 8 <0x07 0x21>;
			};
			repeater_tune3 {
				tune_name = "usb2_tx_control2";
				tune_value = /bits/ 8 <0x08 0x62>;
			};
			repeater_tune4 {
				tune_name = "usb2_termination";
				tune_value = /bits/ 8 <0x09 0x02>;
			};
			repeater_tune5 {
				tune_name = "usb2_disconnect_threshold";
				tune_value = /bits/ 8 <0x0a 0x00>;
			};
			repeater_tune6 {
				tune_name = "squelch_delay_control";
				tune_value = /bits/ 8 <0x17 0x5d>;
			};
			repeater_tune7 {
				tune_name = "RSV";
				tune_value = /bits/ 8 <0xff 0xff>;
			};
			repeater_tune8 {
				tune_name = "RSV";
				tune_value = /bits/ 8 <0xff 0xff>;
			};
		};
	};
};


/* #include "../max77775.dtsi" */                    /* From max77775.py */
/*
 * Copyright (c) 2019 Samsung Electronics Co., Ltd.
 *		http://www.samsung.com
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 as
 * published by the Free Software Foundation.
 */

&pinctrl_0 {
	if_pmic_irq: if_pmic_irq {
		GPIO_CONFIG_PUD_DRV(AP,gpa0,gpa0,0, FUNC_INPUT_WAKEUP, PULL_NONE, DRV_LV1);
#if 0
		power-source = <0>;
#endif
	};
};

&hsi2c_16 {
	#address-cells = <1>;
	#size-cells = <0>;
	status = "okay";
	max77775: max77775@66 {
		status = "okay";
		compatible = "maxim,max77775";
		reg = <0x66>;
		pinctrl-names = "default";
		pinctrl-0 = <&if_pmic_irq>;
		max77775,irq-gpio = <SEC_GPIO_REF(AP,gpa0,gpa0,0) 1>;
		max77775,rev = <0x02>;
#if 1
		max77775,fw_product_id = <0x02>;
#else
		max77775,fw_product_id = <0x01>;
#endif
#if 1
		max77775,extra_fw_enable = <0>;
#else
		max77775,extra_fw_enable = <0>;
#endif
		max77775,support-audio;
#if 2
		max77775,bc1p2_retry_count = <2>;
#endif
		/* same samples as MD15 */ 
		max77775,snkcap_data = [04 2c 91 01 36 c8 d0 02 00 c8 90 41 8b 2e 21 dc c0];
	};
};

&max77775 {
	max77775_pdic {
		status = "okay";
		compatible = "maxim,max77775_pdic";
		support_pd_role_swap;
	};
};

/* #include "../max77775_fuelgauge.dtsi" */          /* From max77775_fuelgauge.py */
&smd {
	max77775_fuelgauge: max77775-fuelgauge {
			    /* for 4500mAh battery */
			    status = "okay";
			    fuelgauge,fuel_alert_soc = <1>;
			    fuelgauge,jig_gpio = <SEC_GPIO_REF(AP,gpa4,gpa4,1) 0>; /* IFC_SENSE_INT_AP */
			    fuelgauge,jig_low_active;
			    fuelgauge,capacity_max = <1000>;
			    fuelgauge,capacity_max_margin = <300>;
			    fuelgauge,capacity_min = <0>;
			    fuelgauge,capacity_calculation_type = <28>;
			    fuelgauge,repeated_fuelalert;
			    fuelgauge,using_temp_compensation;
			    fuelgauge,low_temp_limit = <100>;
			    fuelgauge,vempty_recover_time = <180>; /* 3 mins */
			    fuelgauge,using_hw_vempty;
			    fuelgauge,sw_v_empty_voltage = <3200>;
			    fuelgauge,sw_v_empty_voltage_cisd = <3100>;
			    fuelgauge,sw_v_empty_recover_voltage = <3480>;
			    fuelgauge,fg_resistor = <2>;
#if 1
			    fuelgauge,bat_id_gpio = <
#if 0
					SEC_GPIO_REF(${bat_id_gpio_2}) 0 /* BAT_ID_GPIO 1 */
#endif
					SEC_GPIO_REF(PM,s2mps28_2_gpio,gpio_s,3) 0 /* BAT_ID_GPIO 0 */
					>;
#endif
#if 0
			    fuelgauge,sub_bat_id_gpio = <
#if 0
					SEC_GPIO_REF(${sub_bat_id_gpio_2}) 0 /* SUB_BAT_ID_GPIO 1 */
#endif
					SEC_GPIO_REF(${sub_bat_id_gpio}) 0 /* SUB_BAT_ID_GPIO 0 */
					>;
#endif
		    };
};

/* /home/dpi/qb5_8814/workspace/P4_1716/android/kernel/kmodule/battery/stable/eureka/fuelgauge/max77775/e1s/max77775_fuelgauge.dtsi */
&max77775_fuelgauge {
	fuelgauge,capacity_calculation_type = <0x5C>;
	fuelgauge,lost_soc_trig_soc = <1000>; /* 100.0% */
	fuelgauge,lost_soc_trig_d_soc = <20>; /* 2% */
	fuelgauge,lost_soc_trig_scale = <2>; /* 2x */
	fuelgauge,lost_soc_guarantee_soc = <30>; /* 3.0% */
	fuelgauge,lost_soc_min_vol = <3200>; /* 3200mV */
	fuelgauge,fg_resistor = <5>; /* 2 milliohm */
	fuelgauge,scale_to_102;

	battery_params {
		/*
		 * BAT_ID_1/BAT_ID_2
		 * 0: SDI, 1: ATL
		 */
		/* 1 : ATL battery data */
		battery1,v_empty = <0xA561>; /* Empty: 3400mV, Recover: 4000mV */
		battery1,v_empty_origin = <0x7D54>; /* Empty: 2500mV, Recover: 3360mV */
		battery1,capacity = <0x0610>;
					/* fullcapnom dPacc dQacc RCOMP0 TempCo */
		battery1,fg_reset_wa_data = <0x0610 0x3200 0x0184 0x04E0 0x0D02>;

		battery1,data_ver = <0x3>;

		battery1,selected_reg = <
			0x02 0x7F80	/* default */
			0x12 0x3400	/* QResidual00 */
			0x1E 0x01F1	/* ICHGTerm */
			0x21 0x6200	/* default */
			0x22 0x1880	/* QResidual10 */
			0x2A 0x023E	/* RelaxCFG */
			0x2C 0xE3E1	/* TGAIN */
			0x2D 0x290E	/* TOFF */
			0x2E 0x0400	/* CGAIN */
			0x2F 0x0001	/* COFF */
			0x32 0x0B00	/* QResidual20 */
			0x33 0xFFFF	/* default */
			0x37 0x05E0	/* default */
			0x42 0x0800	/* QResidual30 */
			0xB4 0x7F80	/* default */
			0xB8 0x0000	/* default */
			0xB9 0x006B	/* default */
			0xBA 0x090C	/* default */
			>;

		/* 0 : SDI battery data */
		battery0,v_empty = <0xA561>; /* Empty: 3400mV, Recover: 4000mV */
		battery0,v_empty_origin = <0x7D54>; /* Empty: 2500mV, Recover: 3360mV */
		battery0,capacity = <0x0617>;
					/* fullcapnom dPacc dQacc RCOMP0 TempCo */
		battery0,fg_reset_wa_data = <0x0616 0x3200 0x0185 0x0440 0x0B02>;

		battery0,data_ver = <0x3>;

		battery0,selected_reg = <
			0x02 0x7F80	/* default */
			0x12 0x3100	/* QResidual00 */
			0x1E 0x01F1	/* ICHGTerm */
			0x21 0x6200	/* default */
			0x22 0x1580	/* QResidual10 */
			0x2A 0x023E	/* RelaxCFG */
			0x2C 0xE3E1	/* TGAIN */
			0x2D 0x290E	/* TOFF */
			0x2E 0x0400	/* CGAIN */
			0x2F 0x0001	/* COFF */
			0x32 0x0780	/* QResidual20 */
			0x33 0xFFFF	/* default */
			0x37 0x05E0	/* default */
			0x42 0x0680	/* QResidual30 */
			0xB4 0x7F80	/* default */
			0xB8 0x0000	/* default */
			0xB9 0x006B	/* default */
			0xBA 0x090C	/* default */
			>;
	};
};

/* #include "../sensorhub_shub.dtsi" */              /* From sensorhub_shub.py */
#if 1
&l14_reg {
	regulator-name = "VDD_SENSOR_1P8";
};
#endif
#if 0
&${gpio_sensor_ldo_en_parent} {
	shub_sensor_ldo_en: shub-sensor-ldo-en {
		samsung,pins = SEC_GPIO(${gpio_sensor_ldo_en});
		samsung,pin-function = <1>;
		samsung,pin-pud = <0>;
		samsung,pin-con-pdn = <3>;
		samsung,pin-pud-pdn = <0>;
	};
};
#endif
/ {
	fragment@model {
		target-path = "/";
		__overlay__ {
			shub {
#if 0
    			pinctrl-names = "default";
				pinctrl-0 = <&shub_sensor_ldo_en>;
#endif
#if 1
				sensor-vdd-regulator = "VDD_SENSOR_1P8";
#endif

#if 0
				mag-check-nfc = <SEC_GPIO_REF(${gpio_nfc_check}) 0>;
#endif

#if 0
				pogo-int = <SEC_GPIO_REF(${gpio_pogo_int}) 0>;
#endif

#if 0
				sensor-ldo-en = <SEC_GPIO_REF(${gpio_sensor_ldo_en}) 0>;
#endif
			};
		};
	};
};

/* #include "../fingerprint_qfs4008.dtsi" */         /* From fingerprint_qfs4008.py */
&pinctrl_0 {
	btp_ipc: btp-ipc {
		samsung,pins = SEC_GPIO(AP,gpa0,gpa0,6);
		samsung,pin-function = <0xf>;
		samsung,pin-pud = <1>;
		samsung,pin-drv = <3>;
	};
};

&pinctrl_0 {
	btp_wuhb: btp-wuhb {
		samsung,pins = SEC_GPIO(AP,gpa0,gpa0,1);
		samsung,pin-function = <0xf>;
		samsung,pin-pud = <1>;
		samsung,pin-drv = <3>;
	};
};

&pinctrl_7 {
	spi_fp_bus: spi-fp-bus {
		samsung,pins = SEC_GPIO(AP,gpp11,gpp11,3), SEC_GPIO(AP,gpp11,gpp11,0), SEC_GPIO(AP,gpp11,gpp11,1), SEC_GPIO(AP,gpp11,gpp11,2);
		samsung,pin-function = <2>;
		samsung,pin-pud = <0>;
		samsung,pin-drv = <3>;
	};

	spi_fp_inactive: spi-fp-inactive {
		samsung,pins = SEC_GPIO(AP,gpp11,gpp11,0), SEC_GPIO(AP,gpp11,gpp11,1), SEC_GPIO(AP,gpp11,gpp11,2);
		samsung,pin-function = <0>;
		samsung,pin-pud = <1>;
		samsung,pin-drv = <3>;
	};

	spi_cs_fp_inactive: spi-cs-fp-inactive {
		samsung,pins = SEC_GPIO(AP,gpp11,gpp11,3);
		samsung,pin-function = <1>;
		samsung,pin-pud = <3>;
		samsung,pin-drv = <3>;
		samsung,pin-val = <1>;
	};
};

&l13_reg {
	regulator-name = "VDD_BTP_1P8";
	regulator-min-microvolt = <1800000>;
	regulator-max-microvolt = <1810000>;
};

#if 0
&${fps_regul_vdd_3p0} {
	regulator-name = "VDD_BTP_3P0";
	regulator-min-microvolt = <3000000>;
	regulator-max-microvolt = <3010000>;
};
#endif

&smd {
	qfs4008 {
		compatible = "qcom,qfs4008";
#if !defined(CONFIG_SEC_FACTORY) && 1
		clocks = <&clock GATE_PERIC2_CMU_PERIC2_QCH>, <&clock DOUT_DIV_CLK_PERIC2_USI11>;
		clock-names = "gate_spi_clk", "ipclk_spi";
#endif
		qcom,ipc-gpio = <SEC_GPIO_REF(AP,gpa0,gpa0,6) 0>;
		qcom,wuhb-gpio = <SEC_GPIO_REF(AP,gpa0,gpa0,1) 0>;
		qcom,btp-regulator-1p8 = "VDD_BTP_1P8";
		qcom,btp-regulator-3p0 = "VDD_BTP_3P0";
		qcom,position = "30.87,0.00,7.50,8.25,14.80,14.80,13.00,13.00,5.00";
		qcom,modelinfo = "S92X";
		qcom,chipid = "QFS4008";
		pinctrl-names = "default", "pins_poweron", "pins_poweroff";
		pinctrl-0 = <&btp_ipc &btp_wuhb>;
		pinctrl-1 = <&spi_fp_bus>;
		pinctrl-2 = <&spi_fp_inactive &spi_cs_fp_inactive>;
	};
};

#if defined(CONFIG_SEC_FACTORY) || !1
&spi_11 {
	status = "okay";
	pinctrl-names = "";
	swap-mode = <0>;
	dma-mode;

	qbtspi@0 {
		compatible = "qcom,qfsspi";
		reg = <0>;
		spi-max-frequency = <33333333>;

		gpio-controller;
		#gpio-cells = <2>;
		controller-data {
			samsung,spi-feedback-delay = <2>;
			samsung,spi-chip-select-mode = <0>;
		};
	};
};
#endif
/* #include "../input_stm_spi.dtsi" */               /* From input_stm_spi.py */
&pinctrl_0 {
	tsp_int_active: tsp_int_active {
		GPIO_CONFIG_PUD_DRV(AP,gpa1,gpa1,2, FUNC_INPUT_WAKEUP, PULL_NONE, DRV_LV1);
	};

	tsp_int_sleep: tsp_int_sleep {
		GPIO_CONFIG_PUD_DRV(AP,gpa1,gpa1,2, FUNC_INPUT_WAKEUP, PULL_NONE, DRV_LV1);
	};
};

&spi_9 {
	#address-cells = <1>;
	#size-cells = <0>;
	status = "ok";
	dmas = <>;
	tsp_stm_spi: touchscreen@0 {
		status = "ok";
		compatible = "stm,stm_ts_spi";
		reg = <0>;
		spi-max-frequency = <10000000>;
		pinctrl-names = "on_state", "off_state";
		pinctrl-0 = <&tsp_int_active>;
		pinctrl-1 = <&tsp_int_sleep>;
		tsp_io_ldo-supply = <&l18_reg>;
		tsp_avdd_ldo-supply = <&l9_reg>;
		sec,irq_gpio = <SEC_GPIO_REF(AP,gpa1,gpa1,2) 0>;
		sec,gpio_spi_cs = <SEC_GPIO_REF(AP,gpp9,gpp9,3) 0>;
		/* This part is for firmware */
		sec,project_name = "e1s";
		sec,ss_touch_num = <1>;

		sec,area-size = <133 266 341>; /* indicator: 24dp navigator:48dp edge:60px dpi=320 */
		sec,max_coords = <4096 4096>; /* x y */
		enable_settings_aot;
		support_dex_mode;
		support_mis_calibration_test;
		support_ear_detect_mode;
		support_open_short_test;
		support_rawdata_map_num = <5>;
		sec,enable_sysinput_enabled;

		controller-data {
			cs-gpio = <SEC_GPIO_REF(AP,gpp9,gpp9,3) 0>;
			samsung,spi-feedback-delay = <0>;
		};
	};
};


/* /home/dpi/qb5_8814/workspace/P4_1716/android/kernel/kmodule/input/sec_input_2023/touchscreen/stm/common/dts_spi/input-lsi-tsp-stm.e1s.dtsi */
&pinctrl_6 {
	tsp_spi_sleep: tsp_spi_sleep {
		samsung,pins = "gpp9-3", "gpp9-2", "gpp9-1", "gpp9-0";
		samsung,pin-function = <0>;
		samsung,pin-pud = <1>;
		samsung,pin-drv = <0>;
		samsung,pin-con-pdn = <2>;
		samsung,pin-pud-pdn = <1>;
	};

	spi_bus: spi_bus {
		samsung,pins = "gpp9-3", "gpp9-2", "gpp9-1", "gpp9-0";
		samsung,pin-function = <2>;
		samsung,pin-pud = <0>;
		samsung,pin-drv = <0>;
		samsung,pin-con-pdn = <3>;
		samsung,pin-pud-pdn = <0>;
	};
};

&usi_9 {
	usi_v2_mode = "spi";
	status = "okay";
};

&spi_9 {
	pinctrl-0 = <&spi_bus>;
};

&tsp_stm_spi {
	pinctrl-0 = <&tsp_int_active>;
	pinctrl-1 = <&tsp_int_sleep &tsp_spi_sleep>;

	sync-reportrate-120;
	support_fod;
	support_gesture_uevent;
	sec,support_rawdata;
	sec,support_rawdata_motion_palm;
	sec,probe_queue_delay = <500>;
	sec,dump_ic_ver = <1>;
	sec,firmware_name = "tsp_stm/fts2ba61y_e1s.bin";
	sec,tclm_level = <1>;
	sec,afe_base = <0x0000>;
	work_queue_probe_enabled;
};

/* /home/dpi/qb5_8814/workspace/P4_1716/android/kernel/kmodule/input/sec_input_2023/touchscreen/stm/common/dts_spi/input-lsi-tsp-stm.e1s.07.dtsi */
&tsp_stm_spi {
	sec,firmware_name = "tsp_stm/fts2ba61c_e1.bin";
	sec,tclm_level = <2>;
	sec,afe_base = <0x0005>;
};


/* #include "../display_common_oled_board.dtsi" */   /* From display_common_oled_board.py */
/*
 * Samsung Exynos SoC series Panel driver
 *
 * Copyright (c) 2020 Samsung Electronics Co., Ltd
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 as
 * published by the Free Software Foundation.
 */

#if 1
#define ERR_FG_Falling_edge
#endif

#if defined(ERR_FG_1)
#define ERR_FG_TRUE
#endif

&pinctrl_7 {
	disp_rst_default: disp-rst-default {
		samsung,pins = SEC_GPIO(AP,gpc7,gpc7,0);
		samsung,pin-function = <1>;	// OUT
		samsung,pin-pud = <0>;		// NP
		samsung,pin-con-pdn = <3>;	// PREV in sleep
		samsung,pin-pud-pdn = <0>;	// NP in sleep
	};
};

#if 1
&pinctrl_0 {
	disp_det_default: disp_det_default {
		GPIO_CONFIG_PUD(AP,gpa3,gpa3,5, FUNC_INPUT, PULL_DOWN);
	};
};
#endif

#if defined(ERR_FG_Rising_edge) || defined(ERR_FG_TRUE)
&pinctrl_0 {
	err_fg_default: err_fg_default {
		GPIO_CONFIG_PUD(AP,gpa2,gpa2,2, FUNC_INPUT, PULL_DOWN);
	};
};
#endif

#if defined(ERR_FG_Falling_edge)
&pinctrl_0 {
	err_fg_default: err_fg_default {
		GPIO_CONFIG_PUD(AP,gpa2,gpa2,2, FUNC_INPUT, PULL_UP);
	};
};
#endif

#if 1
&pinctrl_0 {
	conn_det_default: conn_det_default {
		samsung,pins = SEC_GPIO(AP,gpa0,gpa0,7);
		samsung,pin-funciton = <0>;			// IN
		samsung,pin-pud = <0>;				// NP
		samsung,pin-con-pdn = <2>;			// IN
		samsung,pin-pud-pdn = <0>;			// NP in sleep
	};
};
#endif
#if 1
&pinctrl_6 {
	disp_te_default: disp_te_default {
		samsung,pins = SEC_GPIO(AP,gpg2,gpg2,0);
		samsung,pin-funciton = <0xf>;			// INT
		samsung,pin-pud = <1>;					// PD
		samsung,pin-con-pdn = <3>;				// PREV in sleep
		samsung,pin-pud-pdn = <0>;				// NP in sleep
	};
};
#endif
#if 0
&${pcd_parent} {
	pcd_default: pcd_default {
		GPIO_CONFIG_PUD(${pcd_gpio}, FUNC_INPUT, PULL_DOWN);
	};
};
#endif

#if 0
&${avdd_en_parent} {
	avdd_en_default: avdd_en_default {
		samsung,pins = SEC_GPIO(${avdd_en_gpio});
		samsung,pin-function = <1>;	// OUT
		samsung,pin-pud = <0>;		// NP
		samsung,pin-con-pdn = <3>;	// PREV in sleep
		samsung,pin-pud-pdn = <0>;	// NP in sleep
	};
};
#endif

#if 0
&${poc_spi_parent} {
	poc_spi_sleep_state_np: poc_spi_sleep_state_np {
		samsung,pins = SEC_GPIO(${poc_spi_cs}), SEC_GPIO(${poc_spi_clk});
		samsung,pin-functions = <0>;	// GPIO
		samsung,pin-pud = <0>;		// NP
		samsung,pin-drv = <0>;
		samsung,pin-con-pdn = <2>;	// INPUT in sleep
		samsung,pin-pud-pdn = <0>;	// NP in sleep
	};
	poc_spi_sleep_state_pd: poc_spi_sleep_state_pd {
		samsung,pins = SEC_GPIO(${poc_spi_mosi}), SEC_GPIO(${poc_spi_miso});
		samsung,pin-functions = <0>;	// GPIO
		samsung,pin-pud = <1>;		// PD
		samsung,pin-drv = <0>;
		samsung,pin-con-pdn = <2>;	// INPUT in sleep
		samsung,pin-pud-pdn = <1>;	// PD in sleep
	};
};
#endif

#if 0
&${lcd_vendor_check_parent} {
	lcd_vendor_check_default: lcd_vendor_check_default {
		GPIO_CONFIG_PUD(${lcd_vendor_check_gpio}, FUNC_INPUT, PULL_NONE);
	};
};
#endif

#if 1
&l10_reg {
	regulator-boot-on;
};
#endif

#if 1
&l17_reg {
	regulator-boot-on;
};
#endif

#if 1
&s2dos05_buck1 {
	regulator-boot-on;
};
#endif

/ {
	fragment@panel_drv {
		target-path = "/";
		__overlay__ {
			panel_drv_0: panel_drv_0 {
				pinctrl-names = "default";
				pinctrl-0 = <
							&disp_rst_default
#if defined(ERR_FG_Rising_edge) || defined(ERR_FG_Falling_edge) || defined(ERR_FG_TRUE)
							&err_fg_default
#endif
#if 1
							&disp_det_default
#endif
#if 1
							&conn_det_default
#endif
#if 1
							&disp_te_default
#endif
#if 0
							&avdd_en_default
#endif
#if 0
							&poc_spi_sleep_state_np
							&poc_spi_sleep_state_pd
#endif
#if 0
							&lcd_vendor_check_default
#endif
				>;

				gpios {
					disp_reset: disp-reset {
						gpios = <SEC_GPIO_REF(AP,gpc7,gpc7,0) 1>;	/* ACTIVE_LOW */
						dir = <0>;  /* OUT */
						irq-type = <0x0>;   /* NONE */
					};
#if 1
					disp_det: disp-det {
						gpios = <SEC_GPIO_REF(AP,gpa3,gpa3,5) 1>;  /* 0:OK, 1:NOK(active) */
						dir = <1>;  /* IN */
						irq-type = <0x2>;   /* FALLING EDGE */
						irq-pend {
							reg = <0x0 0x15850A34 0x0>;
							bit = <0x2>;
						};
					};
#endif
#if defined(ERR_FG_Rising_edge) || defined(ERR_FG_TRUE)
					err_fg: err-fg {
						gpios = <SEC_GPIO_REF(AP,gpa2,gpa2,2) 0>;		/* 0:NOK(active) 1:OK */
						dir = <1>;				/* IN */
						irq-type = <0x00002001>;	/* RISING EDGE | ONE_SHOT */
					};

#endif
#if defined(ERR_FG_Falling_edge)
					err_fg: err-fg {
						gpios = <SEC_GPIO_REF(AP,gpa2,gpa2,2) 0>;		/* 0:NOK(active) 1:OK */
						dir = <1>;				/* IN */
						irq-type = <2>;	/* Falling EDGE | ONE_SHOT */
					};
#endif
#if 1
					conn_det: conn-det {
						gpios = <SEC_GPIO_REF(AP,gpa0,gpa0,7) 0>;
						dir = <1>;
						irq-type = <0x00002001>;	//RISING EDGE | ONE_SHOT
					};
#endif
#if 0
					pcd: pcd {
						gpios = <SEC_GPIO_REF(${pcd_gpio}) 1>;		/* 0:NOK(active) 1:OK */
						dir = <1>;				/* IN */
						irq-type = <0x2>;   /* FALLING EDGE */
					};
#endif
#if 1
					disp_te: disp-te {
						gpios = <SEC_GPIO_REF(AP,gpg2,gpg2,0) 0>;		/* 0:NOK(active) 1:OK */
						dir = <1>;				/* IN */
						irq-type = <0x0>;   /* NONE */
					};
#endif
#if 0
					avdd_en: avdd-en {
						gpios = <SEC_GPIO_REF(${avdd_en_gpio}) 0>;
						dir = <0>;
						irq-type = <0x0>;   /* NONE */
					};
#endif
				};

				regulators {
#if 1
					ddi_vci: ddi-vci {
						regulator = <&l10_reg>;
						type = <REGULATOR_TYPE_PWR>;
						def-voltage = <3000000>;
					};
#endif
#if 1
					ddi_vdd3: ddi-vdd3 {
						regulator = <&l17_reg>;
						type = <REGULATOR_TYPE_PWR>;
						def-voltage = <1800000>;
					};
#endif
#if 1
					ddr_vddr: ddr-vddr {
						regulator = <&s2dos05_buck1>;
						type = <REGULATOR_TYPE_PWR>;
						def-voltage = <1600000>;
					};
#endif
#if 1
					fd_elvdd: fd-elvdd {
						regulator = <&s2dos05_aee_fd>;
						type = <REGULATOR_TYPE_PWR>;
					};
#endif
#if 0
					ssd_elvss: ssd-elvss {
						regulator = <&${ssd_elvss_reg}>;
						type = <REGULATOR_TYPE_SSD>;
					};
#endif
#if 0
					dpmic_elvdd_elvss: dpmic-elvdd-elvss {
						regulator = <&${dpmic_elvdd_elvss_reg}>;
						type = <REGULATOR_TYPE_PWR>;
					};
#endif
				};
			};
		};
	};
};

/* #include "../mst.dtsi" */                         /* From mst.py */
/* Copyright (c) 2020, Samsung Electronics Corporation. All rights reserved.
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 and
 * only version 2 as published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 */

#if !(0)
&s2mps28_2_gpio {
	mst_pwr_en: sec-mst,mst-pwr-gpio {
		GPIO_CONFIG_PUD(PM,s2mps28_2_gpio,gpio_s,2, FUNC_OUTPUT_LOW, PULL_DOWN);
#if defined(CONFIG_ARCH_EXYNOS) || defined(CONFIG_ARCH_EXYNOS9)
		samsung,pin-con-pdn = <0>;
		samsung,pin-pud-pdn = <1>;
#endif
	};
};
#endif

#if 0
&pinctrl_1 {
	mst_en: sec-mst,mst-en-gpio {
		GPIO_CONFIG_PUD(AP,gpm9,gpm9,0, FUNC_OUTPUT_LOW, PULL_DOWN);
#if defined(CONFIG_ARCH_EXYNOS) || defined(CONFIG_ARCH_EXYNOS9)
		samsung,pin-con-pdn = <0>;
		samsung,pin-pud-pdn = <1>;
#endif
	};
};

&pinctrl_1 {
	mst_data: sec-mst,mst-data-gpio {
		GPIO_CONFIG_PUD(AP,gpm9,gpm9,1, FUNC_OUTPUT_LOW, PULL_DOWN);
#if defined(CONFIG_ARCH_EXYNOS) || defined(CONFIG_ARCH_EXYNOS9)
		samsung,pin-con-pdn = <0>;
		samsung,pin-pud-pdn = <1>;
#endif
	};
};
#endif

#if 0
&${mst_support_parent} {
	mst_support_gpio: sec-mst,mst-support-gpio {
		GPIO_CONFIG_PUD(${mst_support}, FUNC_INPUT, PULL_NONE);
#if defined(CONFIG_ARCH_EXYNOS) || defined(CONFIG_ARCH_EXYNOS9)
		samsung,pin-con-pdn = <2>;
		samsung,pin-pud-pdn = <0>;
#endif
	};
};
#endif

&smd {
	sec_mst: sec-mst{
		compatible = "sec-mst";
#if !(0)
		sec-mst,mst-pwr-gpio = <SEC_GPIO_REF(PM,s2mps28_2_gpio,gpio_s,2) 0>;
#endif
#if 0
		sec-mst,mst-en-gpio = <SEC_GPIO_REF(AP,gpm9,gpm9,0) 0>;
		sec-mst,mst-data-gpio = <SEC_GPIO_REF(AP,gpm9,gpm9,1) 0>;
#endif
#if 0
		sec-mst,mst-support-gpio = <SEC_GPIO_REF(${mst_support}) 0>;
#endif

		pinctrl-names = "default";
#if !(0) || 0 || 0
		pinctrl-0 = <
#if !(0)
				&mst_pwr_en 
#endif
#if 0
				&mst_en &mst_data
#endif
#if 0
				&mst_support_gpio
#endif
				>;
#endif
	};
};

/* /home/dpi/qb5_8814/workspace/P4_1716/android/kernel/kmodule/mst/mst.e[123][sq].dtsi */
&sec_mst {
	sec-mst,mst-use-uno-power;
};

/* #include "../nfc_lsi_nfc_2.dtsi" */               /* From nfc_lsi_nfc_2.py */
/*
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 and
 * only version 2 as published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 */

#if 1
#if 0
&${ese_check_parent} {
	ese_check_default: ese_check_default {
		GPIO_CONFIG_PUD_DRV(${ese_check}, FUNC_INPUT, PULL_NONE, DRV_LV3);
		samsung,pin-con-pdn = <2>; /* PIN_PDN_INPUT */
		samsung,pin-pud-pdn = <PIN_PULL_NONE>;
	};
};
#endif

&pinctrl_7 {
	ese_spi_bus_suspend: ese_spi_bus_suspend {
		samsung,pins = SEC_GPIO(AP,gpp1,gpp1,0), SEC_GPIO(AP,gpp1,gpp1,1), SEC_GPIO(AP,gpp1,gpp1,2);
		samsung,pin-function = <0>; /* INPUT */
		samsung,pin-pud = <PIN_PULL_DOWN>; /* DOWN */
		samsung,pin-drv = <PIN_AP_DRV_LV1>;
		samsung,pin-con-pdn = <2>; /* PIN_PDN_INPUT */
		samsung,pin-pud-pdn = <PIN_PULL_DOWN>;
	};

	ese_spi_cs_suspend: ese_spi_cs_suspend {
		samsung,pins = SEC_GPIO(AP,gpp1,gpp1,3);
		samsung,pin-function = <1>; /* OUTPUT */
		samsung,pin-pud = <PIN_PULL_NONE>; /* NONE */
		samsung,pin-drv = <PIN_AP_DRV_LV1>;
		samsung,pin-val = <1>;
		samsung,pin-con-pdn = <1>; /*OUT1*/
		samsung,pin-pud-pdn = <PIN_PULL_NONE>;
	};

	ese_spi_bus: ese_spi_bus {
		samsung,pins = SEC_GPIO(AP,gpp1,gpp1,0), SEC_GPIO(AP,gpp1,gpp1,1), SEC_GPIO(AP,gpp1,gpp1,2);
		samsung,pin-function = <2>;
		samsung,pin-pud = <PIN_PULL_NONE>;
		samsung,pin-drv = <PIN_AP_DRV_LV1>;
	};

	ese_spi_cs: ese_spi_cs {
		samsung,pins = SEC_GPIO(AP,gpp1,gpp1,3);
		samsung,pin-function = <1>;
		samsung,pin-pud = <PIN_PULL_NONE>;
		samsung,pin-drv = <PIN_AP_DRV_LV1>;
	};
};

&spi_1 {
	status = "ok";
	pinctrl-names = "ese_active", "ese_suspend";
	pinctrl-0 = <&ese_spi_bus &ese_spi_cs>;
	pinctrl-1 = <&ese_spi_bus_suspend &ese_spi_cs_suspend>;

	ese_spi@0 {
#if defined(CONFIG_SEC_FACTORY_INTERPOSER) && 1
		status = "disabled";
#else
		status = "ok";
#endif
		compatible = "ese_p3";
		reg = <0>;
		spi-max-frequency = <7000000>;
#if 0
		check_ese = <SEC_GPIO_REF(${ese_check}) 0>;
		pinctrl-names = "default";
		pinctrl-0 = <&ese_check_default>;
#endif
		gpio-controller;
		#gpio-cells = <2>;
#if 0
		p3-vdd-supply = <&${ese_pvdd_ldo}>;
#endif
		ese_p3,cs-gpio = <SEC_GPIO_REF(AP,gpp1,gpp1,3) 0>;
		controller-data {
			samsung,spi-feedback-delay = <0>;
			samsung,spi-chip-select-mode = <0>;
		};
	};
};

#if 0
	regulator-name = "ese_pvdd";
};
#endif

#if 0
/ {
	fragment@ese_platform {
		target-path = "/";
		__overlay__ {
			ese_platform {
#if defined(CONFIG_SEC_FACTORY_INTERPOSER) && 1
				status = "disabled";
#else
				status = "ok";
#endif
				compatible = "p3_platform";
			};
		};
	};
};
#endif
#endif

&pinctrl_1 {
	nfc_i2c_pull_none: nfc_i2c_pull_none {
		samsung,pins = SEC_GPIO(AP,gpm4,gpm4,0), SEC_GPIO(AP,gpm4,gpm4,1);
		samsung,pin-function = <2>;
		samsung,pin-con-pdn = <2>; /* PIN_PDN_INPUT */
		samsung,pin-pud = <PIN_PULL_NONE>;
		samsung,pin-pud-pdn = <PIN_PULL_NONE>;
	};

#if 0
	nfc_i2c_no_change: nfc_i2c_no_change {
		samsung,pins = SEC_GPIO(AP,gpm4,gpm4,0), SEC_GPIO(AP,gpm4,gpm4,1);
		samsung,pin-function = <2>;
		samsung,pin-con-pdn = <2>; /* PIN_PDN_INPUT */
	};
	nfc_i2c_pull_up: nfc_i2c_pull_up {
		samsung,pins = SEC_GPIO(AP,gpm4,gpm4,0), SEC_GPIO(AP,gpm4,gpm4,1);
		samsung,pin-function = <2>;
		samsung,pin-con-pdn = <2>; /* PIN_PDN_INPUT */
		samsung,pin-pud = <PIN_PULL_UP>;
		samsung,pin-pud-pdn = <PIN_PULL_UP>;
	};
#endif
};

#if 0
&${xclkout_parent} {
	xclkout: xclkout {
		samsung,pins = SEC_GPIO(${xclkout_gpio});
		samsung,pin-function = <2>;
		samsung,pin-pud = <PIN_PULL_NONE>;
	};

	xclkout_nc: xclkout_nc {
		samsung,pins = SEC_GPIO(${xclkout_gpio});
		samsung,pin-function = <0>;
		samsung,pin-pud = <PIN_PULL_DOWN>;
	};
};
#endif

&pinctrl_3 {
	nfc_firm: nfc_firm {
		GPIO_CONFIG_PUD_DRV(AP,gpf1,gpf1,1, FUNC_OUTPUT_LOW, PULL_NONE, DRV_LV3);
		samsung,pin-con-pdn = <3>; /* PIN_PDN_PREV */
		samsung,pin-pud-pdn = <PIN_PULL_NONE>;
	};

	nfc_firm_nc: nfc_firm_nc {
		GPIO_CONFIG_PUD_DRV(AP,gpf1,gpf1,1, FUNC_INPUT, PULL_DOWN, DRV_LV3);
	};
};

&s2mps28_2_gpio {
	nfc_en: nfc_en {
		GPIO_CONFIG_PUD_DRV(PM,s2mps28_2_gpio,gpio_s,4, FUNC_OUTPUT_LOW, PULL_NONE, DRV_LV3);
		samsung,pin-con-pdn = <3>; /* PIN_PDN_PREV */
		samsung,pin-pud-pdn = <PIN_PULL_NONE>;
	};

	nfc_en_nc: nfc_en_nc {
		GPIO_CONFIG_PUD_DRV(PM,s2mps28_2_gpio,gpio_s,4, FUNC_INPUT, PULL_DOWN, DRV_LV3);
	};
};

&pinctrl_0 {
	nfc_clk_req: nfc_clk_req {
		samsung,pins = SEC_GPIO(AP,gpa4,gpa4,0);
		samsung,pin-function = <2>;
		samsung,pin-pud = <PIN_PULL_DOWN>;
	};

	nfc_clk_req_nc: nfc_clk_req_nc {
		samsung,pins = SEC_GPIO(AP,gpa4,gpa4,0);
		samsung,pin-function = <0>;
		samsung,pin-pud = <PIN_PULL_DOWN>;
	};
};

#if 0
&${nfc_check_parent} {
	nfc_check: nfc_check {
		GPIO_CONFIG_PUD_DRV(${nfc_check}, FUNC_INPUT, PULL_NONE, DRV_LV3);
		samsung,pin-con-pdn = <2>; /* PIN_PDN_INPUT */
		samsung,pin-pud-pdn = <PIN_PULL_NONE>;
	};
};
#endif

&hsi2c_39 {
	#address-cells = <1>;
	#size-cells = <0>;

	status = "ok";
	clock-frequency = <400000>; /* for HSI2C */
	samsung,i2c-max-bus-freq = <400000>; /* for Normal HW I2C */
	samsung,reset-before-trans;
#if 0
	pinctrl-names = "default", "i2c_pull_up";
	pinctrl-0 = <&nfc_i2c_no_change>;
	pinctrl-1 = <&nfc_i2c_pull_up>;
#else
	pinctrl-names = "default";
	pinctrl-0 = <&nfc_i2c_pull_none>;
#endif
	sec_nfc: sec-nfc@27 {
#if defined(CONFIG_SEC_FACTORY_INTERPOSER) && 1
		status = "disabled";
#else
		status = "ok";
#endif
		compatible = "sec-nfc";
		reg = <0x27>;

		interrupts = <SEC_GPIO_NUM(AP,gpa2,gpa2,3) 0 0>;
		interrupt-parent = <SEC_GPIO_TYPE(AP,gpa2,gpa2,3)>;

		sec-nfc,ven-gpio = <SEC_GPIO_REF(PM,s2mps28_2_gpio,gpio_s,4) 0>;
		sec-nfc,firm-gpio = <SEC_GPIO_REF(AP,gpf1,gpf1,1) 0>;
		sec-nfc,irq-gpio = <SEC_GPIO_REF(AP,gpa2,gpa2,3) 0>;
#if 0
		sec-nfc,check_nfc = <SEC_GPIO_REF(${nfc_check}) 0>;
#endif
		sec-nfc,clk_req-gpio = <SEC_GPIO_REF(AP,gpa4,gpa4,0) 0xf>;
#if 1
		sec-nfc,coldreset-gpio = <SEC_GPIO_REF(AP,gpf1,gpf1,0) 0>;
#endif
		nfc_pvdd-supply = <&l12_reg>;

		sec-nfc,ldo_control;

#if 0
		sec-nfc,irq_all_trigger;
#endif
#if 0
		clocks = <&clock OSC_NFC>;
		clock-names = "oscclk_nfc";
		sec-nfc,nfc_ap_clk;
#endif
		sec-nfc,nfc_ic_type = "SEN6";

		pinctrl-names = "default", "nfc_nc";
		pinctrl-0 = <&nfc_en &nfc_firm &nfc_clk_req
#if 0
				&nfc_check
#endif
#if 0
				&xclkout
#endif
				>;
		pinctrl-1 = <&nfc_en_nc &nfc_firm_nc &nfc_clk_req_nc
#if 0
				&xclkout_nc
#endif
				>;
	};
};

&l12_reg {
	regulator-name = "nfc_pvdd";
};


/* #include "../sec_direct_charger.dtsi" */          /* From sec_direct_charger.py */

&smd {
	sec-direct-charger {
		status = "okay";
		compatible = "samsung,sec-direct-charger";

		charger,battery_name = "battery";
		charger,main_charger = "max77775-charger";
		charger,direct_charger = "pca9481-charger";

		charger,dchg_min_current = <2000>;

		charger,ta_alert_wa;
	};
};


/* /home/dpi/qb5_8814/workspace/P4_1716/android/kernel/kmodule/battery/stable/eureka/common/sec_direct_charger/dts/e1s/sec_direct_charger.dtsi */
&smd {
	sec-direct-charger {
		charger,end_soc = <100>;
		charger,fpdo_dc_max_vbat = <3900>;
	};

	pass-through {
		start_delay = <5000>; /* msec */
		init_delay = <5000>; /* msec */
		min_cap = <200>; /* 0.1 % */
		fixed_sc_cap = <900>; /* 0.1 % */
		max_icl = <3000>; /* mA */
		vfloat = <4450>; /* mV */
	};
};

/* #include "../cps4038_charger.dtsi" */             /* From cps4038_charger.py */
#include <dt-bindings/battery/sec-battery.h>

&smd {
	sb_tx: sb-tx {
	       aov {
		       high_freq = <144>;
	       };
       };
};

&pinctrl_0 {
	cps_irq_default: cps_irq_default {
		GPIO_CONFIG_PUD_DRV(AP,gpa2,gpa2,4, FUNC_INPUT_WAKEUP, PULL_NONE, DRV_LV1);
	};
};

&pinctrl_0 {
	cps_det_default: cps_det_default {
		GPIO_CONFIG_PUD(AP,gpa1,gpa1,5, FUNC_INPUT_WAKEUP, PULL_NONE);
	};
};

&s2mps28_2_gpio {
	cps_en_default: cps_en_default {
		GPIO_CONFIG_PUD(PM,s2mps28_2_gpio,gpio_s,5, FUNC_OUTPUT_LOW, PULL_NONE);
	};
};

#if 1
&pinctrl_0 {
	cps_pdrc_default: cps_pdrc_default {
		GPIO_CONFIG_PUD(AP,gpa3,gpa3,2, FUNC_INPUT_WAKEUP, PULL_NONE);
	};
};
#endif

#if 1
&pinctrl_1 {
	cps_ping_nen_default: cps_ping_nen_default {
		GPIO_CONFIG_PUD(AP,gpm13,gpm13,0, FUNC_OUTPUT_HIGH, PULL_NONE);
	};
};
#endif

#if 1
&pinctrl_1 {
	cps_pdet_b_default: cps_pdet_b_default {
		GPIO_CONFIG_PUD(AP,gpm13,gpm13,1, FUNC_INPUT_WAKEUP, PULL_NONE);
	};
};
#endif

#if 1
&pinctrl_0 {
	cps_mag_det_default: cps_mag_det_default {
		GPIO_CONFIG_PUD(AP,gpa2,gpa2,7, FUNC_OUTPUT_HIGH, PULL_NONE);
	};
};
#endif

&hsi2c_45 {
	#address-cells = <1>;
	#size-cells = <0>;
	status = "okay";
	clock-frequency = <100000>;

	cps4038_charger: cps4038-charger@38 {
		compatible = "cps,cps4038-charger";
		reg = <0x38>;
		status = "okay";

		pinctrl-names = "default";
		pinctrl-0 = <&cps_irq_default &cps_det_default &cps_en_default &cps_pdrc_default
#if 1
			&cps_ping_nen_default
#endif
#if 1
			&cps_pdet_b_default
#endif
#if 1
			&cps_mag_det_default
#endif
			>;

		battery,wpc_int = <SEC_GPIO_REF(AP,gpa2,gpa2,4) 1>; /* MFC_AP_INT */
		battery,wpc_det = <SEC_GPIO_REF(AP,gpa1,gpa1,5) 0>; /* WPC_DET */
#if 0
		battery,mst_pwr_en = <SEC_GPIO_REF(${cps_pwr_en_gpio}) 0>; /* MST_PWR_EN */
#endif
#if 1
		battery,wpc_ping_nen = <SEC_GPIO_REF(AP,gpm13,gpm13,0) 1>; /* PING_NEN */
#endif
#if 1
		battery,wpc_pdet_b = <SEC_GPIO_REF(AP,gpm13,gpm13,1) 1>; /* PDET_B */
#endif
		battery,wpc_en = <SEC_GPIO_REF(PM,s2mps28_2_gpio,gpio_s,5) 0>; /* WPC_EN */
#if 1
		battery,wpc_pdrc = <SEC_GPIO_REF(AP,gpa3,gpa3,2) 1>; /* VRECT_INT */
#endif
#if 1
		battery,wpc_mag_det = <SEC_GPIO_REF(AP,gpa2,gpa2,7) 0>; /* MAG_DET */
#endif

		battery,charger_name = "max77775-charger";
		battery,fuelgauge_name = "max77775-fuelgauge";
		battery,wireless_charger_name = "cps4038-charger";
		battery,wc_cover_rpp = <0x44>;
		battery,phone_fod_threshold = <0x3b>;
		battery,wireless20_vout_list = <WIRELESS_VOUT_9V /* 0xA0 */
						WIRELESS_VOUT_12V /* 0xA1 */
						WIRELESS_VOUT_12V /* 0xA2 */
						WIRELESS_VOUT_12V /* 0xA3 */
						WIRELESS_VOUT_12V /* 0xA4 */
						WIRELESS_VOUT_12V>; /* 0xA5 */
		battery,wireless20_vrect_list = <MFC_AFC_CONF_12V_TX
						MFC_AFC_CONF_12_5V_TX
						MFC_AFC_CONF_12_5V_TX
						MFC_AFC_CONF_12_5V_TX
						MFC_AFC_CONF_12_5V_TX
						MFC_AFC_CONF_12_5V_TX>;
		battery,wireless20_max_power_list = <SEC_WIRELESS_RX_POWER_12W
						SEC_WIRELESS_RX_POWER_15W
						SEC_WIRELESS_RX_POWER_15W
						SEC_WIRELESS_RX_POWER_15W
						SEC_WIRELESS_RX_POWER_15W
						SEC_WIRELESS_RX_POWER_15W>;

		battery,buds_fod_ta_thresh = <0x0898>; /* 2200mW */
		battery,wpc_vout_ctrl_full = <WIRELESS_VOUT_5V_STEP>;
		battery,mis_align_guide;
		battery,mis_align_target_vout = <5000>;
		battery,mpp_epp_vout = <WIRELESS_VOUT_12V>;

		fod_list {
			count = <1>;

			pad_0x00 { /* DEFAULT PAD */
				bpp { /* DEFAULT OP MODE */
					flag = <(SET_FOD_CC(ADD) | SET_FOD_CV(USE_CC) | SET_FOD_FULL(ADD))>;
					cc = <0x4E 0x0F 0x4E 0x10 0x4E 0x0C 0x4E 0x0C 0x4E 0x0C 0x4E 0x0C 0x4E 0x0D 0x4E 0x0D 0x4E 0x0D 0x4E 0x0D>;
					full = <0xFF 0x7F 0xFF 0x7F 0xFF 0x7F 0xFF 0x7F 0xFF 0x7F
						0xFF 0x7F 0xFF 0x7F 0xFF 0x7F 0xFF 0x7F 0xFF 0x7F>;
				};

				ppde {
					flag = <(SET_FOD_CC(USE_DEF_OP) | SET_FOD_CV(USE_DEF_OP) | SET_FOD_FULL(USE_DEF_OP))>;
				};

				epp {
					flag = <(SET_FOD_CC(USE_DEF_OP) | SET_FOD_CV(USE_DEF_OP) | SET_FOD_FULL(USE_DEF_OP))>;
				};

				mpp {
					flag = <(SET_FOD_CC(USE_DEF_OP) | SET_FOD_CV(USE_DEF_OP) | SET_FOD_FULL(USE_DEF_OP))>;
				};
			};
		};
	};
};

/* /home/dpi/qb5_8814/workspace/P4_1716/android/kernel/kmodule/battery/stable/eureka/wireless/cps4038/cps4038_charger.e1s.dtsi */
#include <dt-bindings/battery/sec-battery.h>

&cps4038_charger {
	battery,unknown_cmb_ctrl;
	battery,default_clamp_volt;
	battery,tx_max_op_freq = <1450>;
	battery,tx_min_op_freq = <1120>;
	battery,wireless20_iec_ploss_fod_enable = <0x1>;
	battery,tx_fod_gain = <0x74>;
	battery,buds_fod_thresh1 = <0x0DAC>;
	battery,buds_fod_ta_thresh = <0x0DAC>;

	fod_list {
		epp_ref_qf = <0x24>;
		epp_ref_rf = <0x69>;

		count = <3>;

		pad_0x00 { /* DEFAULT */
			bpp { /* DEFAULT OP MODE */
				flag = <(SET_FOD_CC(ADD) | SET_FOD_CV(ADD) | SET_FOD_FULL(ADD))>;
				cc = <0x52 0x0E 0x52 0x0E 0x52 0x0A 0x52 0x0A 0x52 0x0A 0x52 0x0A 0x52 0x0B 0x52 0x0B 0x52 0x0B 0x52 0x0B>;
				cv = <0x52 0x16 0x52 0x16 0x52 0x12 0x52 0x12 0x52 0x12 0x52 0x12 0x52 0x13 0x52 0x13 0x52 0x13 0x52 0x13>;
				full = <0xFF 0x7F 0xFF 0x7F 0xFF 0x7F 0xFF 0x7F 0xFF 0x7F 0xFF 0x7F 0xFF 0x7F 0xFF 0x7F 0xFF 0x7F 0xFF 0x7F>;
			};

			epp {
				flag = <(SET_FOD_CC(ADD) | SET_FOD_CV(ADD) | SET_FOD_FULL(ADD))>;
				cc = <0x65 0x1B 0x65 0x1B 0x65 0x16 0x65 0x16 0x65 0x19 0x65 0x19 0x62 0x1D 0x62 0x1D 0x62 0x1D 0x0E 0x03>;
				cv = <0x65 0x23 0x65 0x23 0x65 0x1E 0x65 0x1E 0x65 0x21 0x65 0x21 0x62 0x25 0x62 0x25 0x62 0x25 0x0E 0x03>;
				full = <0xFF 0x7F 0xFF 0x7F 0xFF 0x7F 0xFF 0x7F 0xFF 0x7F 0xFF 0x7F 0xFF 0x7F 0xFF 0x7F 0xFF 0x7F 0x0E 0x03>;
			};

			ppde {
				flag = <(SET_FOD_CC(ADD) | SET_FOD_CV(ADD) | SET_FOD_FULL(USE_DEF_OP))>;
				cc = <0xA0 0x4F 0xA0 0x4F 0xA0 0x3B 0xA0 0x3D 0xA0 0x3E 0xA0 0x3E 0xA0 0x3E 0xA0 0x3B 0xA0 0x39 0xA0 0x39>;
				cv = <0xA0 0x57 0xA0 0x57 0xA0 0x43 0xA0 0x45 0xA0 0x46 0xA0 0x46 0xA0 0x46 0xA0 0x43 0xA0 0x41 0xA0 0x41>;
			};
		};

		pad_0xA3 { /* p2400 */
			epp {
				flag = <(SET_FOD_CC(ADD) | SET_FOD_CV(ADD) | SET_FOD_FULL(ADD))>;
				cc = <0x65 0x41 0x65 0x41 0x65 0x3C 0x65 0x3C 0x65 0x3E 0x65 0x3E 0x62 0x43 0x62 0x43 0x62 0x43 0x0E 0x0A>;
				cv = <0x65 0x49 0x65 0x49 0x65 0x44 0x65 0x44 0x65 0x46 0x65 0x46 0x62 0x4B 0x62 0x4B 0x62 0x4B 0x62 0x4B>;
				full = <0xFF 0x7F 0xFF 0x7F 0xFF 0x7F 0xFF 0x7F 0xFF 0x7F 0xFF 0x7F 0xFF 0x7F 0xFF 0x7F 0xFF 0x7F 0xFF 0x7F>;
			};
		};

		pad_0x18 { /* p2400 */
			epp {
				flag = <(SET_FOD_CC(ADD) | SET_FOD_CV(ADD) | SET_FOD_FULL(ADD))>;
				cc = <0x65 0x41 0x65 0x41 0x65 0x3C 0x65 0x3C 0x65 0x3E 0x65 0x3E 0x62 0x43 0x62 0x43 0x62 0x43 0x0E 0x0A>;
				cv = <0x65 0x49 0x65 0x49 0x65 0x44 0x65 0x44 0x65 0x46 0x65 0x46 0x62 0x4B 0x62 0x4B 0x62 0x4B 0x62 0x4B>;
				full = <0xFF 0x7F 0xFF 0x7F 0xFF 0x7F 0xFF 0x7F 0xFF 0x7F 0xFF 0x7F 0xFF 0x7F 0xFF 0x7F 0xFF 0x7F 0xFF 0x7F>;
			};
		};
	};
};

/* #include "../battery_common.dtsi" */              /* From battery_common.py */
#include <dt-bindings/battery/sec-battery.h>

&smd {
	sec_battery: battery {
		status = "okay";
		compatible = "samsung,sec-battery";
		battery,vendor = "Battery";
		battery,charger_name = "sec-direct-charger";
		battery,fuelgauge_name = "max77775-fuelgauge";
		battery,technology = <2>; /* POWER_SUPPLY_TECHNOLOGY_LION */
		battery,chip_vendor = "NONE";

		battery,batt_data_version = <1>;

		battery,adc_check_count = <5>;
		battery,temp_check_type = <SEC_BATTERY_TEMP_CHECK_NONE>;
		battery,usb_temp_check_type = <SEC_BATTERY_TEMP_CHECK_NONE>;
		battery,chg_temp_check_type = <SEC_BATTERY_TEMP_CHECK_NONE>;
		battery,wpc_temp_check_type = <SEC_BATTERY_TEMP_CHECK_NONE>;
		battery,lrp_temp_check_type = <SEC_BATTERY_TEMP_CHECK_NONE>;

		battery,thermal_source = <SEC_BATTERY_THERMAL_SOURCE_NONE>; /* SEC_BATTERY_THERMAL_SOURCE_NONE */
		battery,usb_thermal_source = <SEC_BATTERY_THERMAL_SOURCE_NONE>; /* SEC_BATTERY_THERMAL_SOURCE_NONE */
		battery,chg_thermal_source = <SEC_BATTERY_THERMAL_SOURCE_NONE>; /* SEC_BATTERY_THERMAL_SOURCE_NONE */
		battery,wpc_thermal_source = <SEC_BATTERY_THERMAL_SOURCE_NONE>; /* SEC_BATTERY_THERMAL_SOURCE_NONE */

		battery,inbat_ocv_type =  <SEC_BATTERY_OCV_NONE>;

		battery,polling_time = <10 30 30 30 3600>;

		battery,cable_check_type = <SEC_BATTERY_CABLE_CHECK_PSY>;
		battery,cable_source_type = <SEC_BATTERY_CABLE_SOURCE_EXTERNAL>;
		battery,polling_type = <SEC_BATTERY_MONITOR_ALARM>; /* SEC_BATTERY_MONITOR_ALARM */
		battery,monitor_initial_count = <0>;

		battery,battery_check_type = <0>; /* SEC_BATTERY_CHECK_NONE */

		battery,ovp_uvlo_check_type = <SEC_BATTERY_OVP_UVLO_CHGPOLLING>; /* SEC_BATTERY_OVP_UVLO_CHGPOLLING */

		battery,temp_check_count = <1>;

		battery,usb_protection_temp = <610>;
		battery,temp_gap_bat_usb = <200>;
		battery,overheatlimit_threshold = <700>;
		battery,overheatlimit_recovery = <680>;
		battery,wire_warm_overheat_thresh = <500>;
		battery,wire_normal_warm_thresh = <420>;
		battery,wire_cool1_normal_thresh = <180>;
		battery,wire_cool2_cool1_thresh = <150>;
		battery,wire_cool3_cool2_thresh = <50>;
		battery,wire_cold_cool3_thresh = <0>;
		battery,wireless_warm_overheat_thresh = <500>;
		battery,wireless_normal_warm_thresh = <420>;
		battery,wireless_cool1_normal_thresh = <180>;
		battery,wireless_cool2_cool1_thresh = <150>;
		battery,wireless_cool3_cool2_thresh = <50>;
		battery,wireless_cold_cool3_thresh = <0>;
		battery,tx_high_threshold = <500>;
		battery,tx_high_recovery = <450>;
		battery,tx_low_threshold = <0>;
		battery,tx_low_recovery = <50>;

		battery,wire_warm_current = <1573>;	/* 0.36C */
		battery,wire_cool1_current = <3146>;	/* 0.72C */
		battery,wire_cool2_current = <1048>;	/* 0.24C */
		battery,wire_cool3_current = <437>;	/* 0.1C */
		battery,wireless_warm_current = <1048>;		/* 0.24C */
		battery,wireless_cool1_current = <3146>;	/* 0.72C */
		battery,wireless_cool2_current = <1048>;	/* 0.24C */
		battery,wireless_cool3_current = <437>;		/* 0.1C */

		battery,full_check_type = <SEC_BATTERY_FULLCHARGED_CHGPSY>;
		battery,full_check_type_2nd = <SEC_BATTERY_FULLCHARGED_CHGPSY>;
		battery,full_check_count = <1>;
		battery,chg_gpio_full_check = <0>;
		battery,chg_polarity_full_check = <1>;

		battery,chg_high_temp = <470>;
		battery,chg_high_temp_recovery = <450>;
		battery,chg_input_limit_current = <1000>;
		battery,chg_charging_limit_current = <1900>;

		battery,dchg_high_temp = <520>;
		battery,dchg_high_temp_recovery = <460>;
		battery,dchg_high_batt_temp = <400>;
		battery,dchg_high_batt_temp_recovery = <380>;
		battery,dchg_input_limit_current = <1000>;
		battery,dchg_charging_limit_current = <2000>;

		battery,wpc_temp_control_source = <TEMP_CONTROL_SOURCE_BAT_THM>;
		battery,wpc_high_temp = <400>;
		battery,wpc_high_temp_recovery = <380>;
		battery,wpc_input_limit_current = <800>;
		battery,wpc_charging_limit_current = <1000>;
		battery,wpc_temp_lcd_on_control_source = <TEMP_CONTROL_SOURCE_BAT_THM>;
		battery,wpc_lcd_on_input_limit_current = <800>;

		battery,wpc_store_high_temp = <360>;
		battery,wpc_store_high_temp_recovery = <340>;
		battery,wpc_store_charging_limit_current = <400>;
		battery,wpc_store_lcd_on_high_temp = <360>;
		battery,wpc_store_lcd_on_high_temp_rec = <300>;
		battery,wpc_store_lcd_on_charging_limit_current = <400>;

		battery,fcc_by_tx = <1200>;

		battery,sleep_mode_limit_current = <800>;
		battery,wc_full_input_limit_current = <100>;

		battery,ta_alert_wa;

		battery,mix_high_temp = <420>;
		battery,mix_high_chg_temp = <500>;
		battery,mix_high_temp_recovery = <390>;

		/* battery,usb_conn_slope_avg = <9>; */

		/* battery,enable_mix_v2; */
		/* if you want to use mix_v2 concept, add "battery,enable_mix_v2;" */
		battery,mix_v2_lrp_recov = <460>;
		battery,mix_v2_lrp_cond = <480>;
		battery,mix_v2_bat_cond = <480>;
		battery,mix_v2_chg_cond = <0>;	/* 0 means no use chg thm condition */
		battery,mix_v2_dchg_cond = <0>; /* 0 means no use dchg thm condition */

		battery,full_condition_type = <(SEC_BATTERY_FULL_CONDITION_NOTIMEFULL | SEC_BATTERY_FULL_CONDITION_VCELL)>;
		battery,full_condition_soc = <93>;
		battery,full_condition_vcell = <4250>;

		battery,recharge_check_count = <1>;
		battery,recharge_condition_type = <SEC_BATTERY_RECHARGE_CONDITION_VCELL>;
		battery,recharge_condition_soc = <98>;
		battery,recharge_condition_vcell = <4280>;

		battery,charging_reset_time = <0>;

		battery,chg_float_voltage = <4350>;

		battery,pre_afc_work_delay = <2000>;
		battery,pre_wc_afc_work_delay = <4000>;
		battery,pre_afc_input_current = <500>;
		battery,pre_wc_afc_input_current = <500>;

		battery,swelling_high_rechg_voltage = <4000>;
		battery,swelling_low_rechg_voltage = <4000>;

		battery,siop_icl = <1200>;
		battery,siop_fcc = <1800>;
		battery,siop_hv_icl = <700>;
		battery,siop_hv_icl_2nd = <550>;
		battery,siop_hv_fcc = <1800>;
		battery,siop_apdo_icl = <1000>;
		battery,siop_apdo_fcc = <2000>;

		battery,siop_wpc_icl = <600>;
		battery,siop_wpc_fcc = <1000 500 100>; /* siop_level 70 10 0 */
		battery,siop_hv_wpc_icl = <700>;
		battery,siop_hv_wpc_fcc = <1000 500 100>; /* siop_level 70 10 0 */
		battery,siop_store_hv_wpc_icl = <450>;
		battery,store_mode_buckoff;

		/* trig, recov */
		battery,temp_table_LRP_45W = <385 365>;

		battery,rp_current_rp1 = <500>;
		battery,rp_current_rp2 = <1500>;
		battery,rp_current_rp3 = <3000>;
		battery,rp_current_rdu_rp3 = <2100>;
		battery,rp_current_abnormal_rp3 = <1800>;

		battery,pd_charging_charge_power = <15000>;
		battery,max_charging_current = <2350>;

		battery,store_mode_charging_max = <70>;
		battery,store_mode_charging_min = <60>;

		battery,wireless_cc_cv = <85>;
		battery,wireless_otg_input_current = <900>;

		/* Calculate Based on Offsets from float voltage, full_condition_vcell and recharge_condition_vcell */
		/* if you want to use age_data_by_offset concept add battery,age_data_by_offset; */

		battery,age_data_cycle = <0 300 400 700 1000>;
		battery,age_data_full_condition_soc = <93 92 91 90 89>;
		battery,age_data_chg_float_voltage_offset = <0 20 40 60 110>;
		battery,age_data_full_condition_vcell_offset = <0 20 40 60 110>;
		battery,age_data_recharge_condition_vcell_offset = <0 20 40 60 110>;
		/* battery,age_data_max_charging_current_offset = <0 100 200 300 400>; */

		/* cycle, chg_float_voltage, recharge_condition_vcell, full_condition_vcell, full_condition_soc, step charging condition */
		battery,age_data = <0 4350 4280 4250 93
			300 4330 4260 4230 92
			400 4310 4240 4210 91
			700 4290 4220 4190 90
			1000 4240 4170 4140 89>;


		battery,health_condition_cycle = <900 1200 1500>;
		battery,health_condition_asoc = <0 0 0>; /* Default ASOC Disabled */

		battery,max_input_voltage = <9000>; /* mV */
		battery,max_input_current = <3000>;  /* mA */

		battery,cisd_alg_index = <8>;
		battery,cisd_max_voltage_thr = <4400>; /* batttery ovp dettection voltage */
		battery,ignore_cisd_index = <0 0>;
		battery,ignore_cisd_index_d = <0 80>; /* Do not use BUCK_OFF_PER_DAY, DROP_SENSOR_PER_DAY */

		battery,expired_time = <10800>;
		battery,recharging_expired_time = <5400>;

		battery,battery_full_capacity = <3300>;

		battery,ttf_capacity = <3500>;
		battery,cv_data = <
				3228	864	1534
				3133	866	1524
				3067	872	1493
				3019	874	1483
				2929	879	1452
				2896	881	1442
				2843	883	1431
				2792	885	1421
				2754	887	1411
				2695	892	1380
				2660	893	1370
				2625	895	1360
				2580	897	1349
				2531	898	1339
				2492	902	1319
				2450	903	1309
				2410	905	1298
				2348	908	1278
				2296	909	1268
				2263	910	1257
				2214	915	1227
				2182	916	1216
				2147	919	1196
				2103	920	1186
				2051	922	1175
				2019	924	1155
				1981	927	1134
				1948	928	1124
				1911	930	1104
				1879	932	1093
				1834	933	1083
				1795	935	1063
				1761	938	1032
				1722	942	1001
				1689	944	981
				1649	946	960
				1592	948	940
				1532	950	919
				1493	954	878
				1462	955	868
				1410	958	827
				1362	959	817
				1338	960	807
				1291	964	756
				1264	968	715
				1237	968	704
				1213	969	694
				1169	974	633
				1127	975	622
				1105	975	612
				1073	980	541
				1049	982	510
				1010	983	489
				993	984	479
				972	986	448
				955	988	407
				932	990	387
				881	990	377
				864	996	356
				761	1000	307
				710	1000	297
				688	1000	287
				668	1000	235
				658	1000	215
				647	1000	184
				635	1000	153
				622	1000	123
				610	1000	92
				596	1000	61
				583	1000	31
				571	1000	0
				>;

#if 1
		io-channels = <&s2mps27_gpadc 14>, <&s2mps27_gpadc 4>, <&s2mps27_gpadc 3>, <&s2mps27_gpadc 14>, <&s2mps27_gpadc 13>;
		io-channel-names = "adc-temp", "adc-chg-temp", "adc-in-bat", "adc-wpc-temp", "adc-usb-temp", "n/a", "n/a", "n/a";
#endif
	};

	/* sec_battery_cable
	 *   0	UNKNOWN,
	 *   1	NONE,
	 *   2	PREPARE_TA,
	 *   3	TA,
	 *   4	USB,
	 *   5	USB_CDP,
	 *   6	9V_TA,
	 *   7	9V_ERR,
	 *   8	9V_UNKNOWN,
	 *   9	12V_TA,
	 *  10	WIRELESS,
	 *  11	HV_WIRELESS,
	 *  12	PMA_WIRELESS,
	 *  13	WIRELESS_PACK,
	 *  14	CABLE_WIRELESS_HV_PACK,
	 *  15	WIRELESS_STAND,
	 *  16	WIRELESS_HV_STAND,
	 *  17	QC20,
	 *  18	QC30,
	 *  19	PDIC,
	 *  20	UARTOFF,
	 *  21	OTG,
	 *  22	LAN_HUB,
	 *  23	POWER_SHARING,
	 *  24	HMT_CONNECTED,
	 *  25	HMT_CHARGE,
	 *  26	HV_TA_CHG_LIMIT,
	 *  27	WIRELESS_VEHICLE,
	 *  28	WIRELESS_HV_VEHICLE,
	 *  29	PREPARE_WIRELESS_HV,
	 *  30  TIMEOUT,
	 *  31  SMART_OTG,
	 *  32  SMART_NOTG,
	 *  33  WIRELESS_TX,
	 *  34	HV_WIRELESS_20,
	 *  35	HV_WIRELESS_20_LIMIT,
	 *  36	WIRELESS_FAKE,
	 *  37  PREPARE_WIRELESS_20,
	 *  38	CABLE_PDIC_APDO,
	 *  39  CABLE_POGO,
	 *  40  CABLE_POGO_9V,
	 *  41  FPDO_DC,
	 *  42	CABLE_MAX,
	 */
	sec_battery_cable: cable-info {
		default_input_current = <1800>;
		default_charging_current = <2100>;
		full_check_current_1st = <350>;
		full_check_current_2nd = <200>;

		current_group_1 {
			cable_number = <
				SEC_BATTERY_CABLE_PREPARE_TA
				SEC_BATTERY_CABLE_PDIC
				SEC_BATTERY_CABLE_OTG
				SEC_BATTERY_CABLE_LAN_HUB
				SEC_BATTERY_CABLE_POWER_SHARING>;
			input_current = <500>;
			charging_current = <500>;
		};
		current_group_2 {
			cable_number = <
				SEC_BATTERY_CABLE_HMT_CHARGE
				SEC_BATTERY_CABLE_SMART_OTG>;
			input_current = <1000>;
			charging_current = <1000>;
		};
		current_group_3 {
			cable_number = <
				SEC_BATTERY_CABLE_USB_CDP
				SEC_BATTERY_CABLE_SMART_NOTG>;
			input_current = <1500>;
			charging_current = <1500>;
		};
		current_group_4 {
			cable_number = <SEC_BATTERY_CABLE_9V_TA SEC_BATTERY_CABLE_9V_ERR
				SEC_BATTERY_CABLE_9V_UNKNOWN SEC_BATTERY_CABLE_QC20 SEC_BATTERY_CABLE_QC30>;
			input_current = <1650>;
			charging_current = <2350>;
		};
		current_group_5 {
			cable_number = <SEC_BATTERY_CABLE_12V_TA>;
			input_current = <1650>;
			charging_current = <2350>;
		};
		current_group_6 {
			cable_number = <
				SEC_BATTERY_CABLE_WIRELESS
				SEC_BATTERY_CABLE_PMA_WIRELESS
				SEC_BATTERY_CABLE_WIRELESS_STAND
				SEC_BATTERY_CABLE_WIRELESS_VEHICLE
				SEC_BATTERY_CABLE_WIRELESS_FAKE>;
			input_current = <800>;
			charging_current = <2350>;
		};
		current_group_7 {
			cable_number = <SEC_BATTERY_CABLE_WIRELESS_PACK>;
			input_current = <700>;
			charging_current = <2350>;
		};
		current_group_8 {
			cable_number = <SEC_BATTERY_CABLE_HMT_CONNECTED>;
			input_current = <1000>;
			charging_current = <450>;
		};
		current_group_9 {
			cable_number = <SEC_BATTERY_CABLE_HV_TA_CHG_LIMIT>;
			input_current = <1800>;
			charging_current = <1800>;
		};
		current_group_10 {
			cable_number = <
				SEC_BATTERY_CABLE_HV_WIRELESS
				SEC_BATTERY_CABLE_WIRELESS_HV_PACK
				SEC_BATTERY_CABLE_WIRELESS_HV_STAND
				SEC_BATTERY_CABLE_WIRELESS_HV_VEHICLE
				SEC_BATTERY_CABLE_HV_WIRELESS_20_LIMIT>;
			input_current = <650>;
			charging_current = <2350>;
		};
		current_group_11 {
			cable_number = <
				SEC_BATTERY_CABLE_PREPARE_WIRELESS_HV
				SEC_BATTERY_CABLE_PREPARE_WIRELESS_20>;
			input_current = <500>;
			charging_current = <1200>;
		};
		current_group_12 {
			cable_number = <
				SEC_BATTERY_CABLE_NONE
				SEC_BATTERY_CABLE_USB
				SEC_BATTERY_CABLE_TIMEOUT>;
			input_current = <475>;
			charging_current = <550>;
		};
		current_group_13 {
			cable_number = <SEC_BATTERY_CABLE_HV_WIRELESS_20>;
			input_current = <1200>;
			charging_current = <2350>;
		};
		current_group_14 {
			cable_number = <SEC_BATTERY_CABLE_WIRELESS_TX>;
			input_current = <800>;
			charging_current = <2350>;
		};
	};
	sec_battery_wireless_power_info: wireless-power-info {
		count = <9>;
		current_group_0 {
			wireless_power_class = <2>;
			vout = <9000>;
			input_current_limit = <830>;
			fast_charging_current = <3150>;
			ttf_charge_current = <1500>;
			rx_power = <7500>;
		};
		current_group_1 {
			wireless_power_class = <2>;
			vout = <10000>;
			input_current_limit = <750>;
			fast_charging_current = <3150>;
			ttf_charge_current = <1500>;
			rx_power = <7500>;
		};
		current_group_2 {
			wireless_power_class = <2>;
			vout = <11000>;
			input_current_limit = <680>;
			fast_charging_current = <3150>;
			ttf_charge_current = <1500>;
			rx_power = <7500>;
		};
		current_group_3 {
			wireless_power_class = <2>;
			vout = <12000>;
			input_current_limit = <625>;
			fast_charging_current = <3150>;
			ttf_charge_current = <1500>;
			rx_power = <7500>;
		};
		current_group_4 {
			wireless_power_class = <2>;
			vout = <9000>;
			input_current_limit = <1330>;
			fast_charging_current = <3150>;
			ttf_charge_current = <2175>;
			rx_power = <12000>;
		};
		current_group_5 {
			wireless_power_class = <2>;
			vout = <11000>;
			input_current_limit = <1090>;
			fast_charging_current = <3150>;
			ttf_charge_current = <2100>;
			rx_power = <12000>;
		};
		current_group_6 {
			wireless_power_class = <2>;
			vout = <12000>;
			input_current_limit = <1000>;
			fast_charging_current = <3150>;
			ttf_charge_current = <2100>;
			rx_power = <12000>;
		};
		current_group_7 {
			wireless_power_class = <2>;
			vout = <11000>;
			input_current_limit = <1360>;
			fast_charging_current = <3150>;
			ttf_charge_current = <2300>;
			rx_power = <15000>;
		};
		current_group_8 {
			wireless_power_class = <2>;
			vout = <12000>;
			input_current_limit = <1250>;
			fast_charging_current = <3150>;
			ttf_charge_current = <2300>;
			rx_power = <15000>;
		};
	};
};

/* /home/dpi/qb5_8814/workspace/P4_1716/android/kernel/kmodule/battery/stable/eureka/common/dts/e1s/battery_common.dtsi */
#include <dt-bindings/battery/sec-battery.h>

#define MAX_FV 4450
#define WC_5V_ICL 700
#define MAX_FCC 4189
#define WC_MAX_FCC 3400
#define DCHG_ICL 1000
#define DCHG_FCC 2000

#if 1
&s2mps28_3_gpio {
	ovp_pwr_flagb_default: ovp_pwr_flagb_default {
			 GPIO_CONFIG_PUD_DRV(PM,s2mps28_3_gpio,gpio_s,2, FUNC_INPUT, PULL_UP, DRV_LV1);
		 };
};
#endif
#if 0
&${ovp_sig_flagb_parent} {
	ovp_sig_flagb_default: ovp_sig_flagb_default {
			 GPIO_CONFIG_PUD_DRV(${ovp_signal_gpio}, FUNC_INPUT, PULL_UP, DRV_LV1);
		 };
};
&ovp_sig_flagb_default {
	samsung,pin-con-pdn = <3>;
	samsung,pin-pud-pdn = <0>;
};
#endif
&smd {
	sec-cisd {
#if 1
		ovp_power = <SEC_GPIO_REF(PM,s2mps28_3_gpio,gpio_s,2) 0>; /* OVP_PWR_FLAGB */
#endif
#if 0
		ovp_signal = <SEC_GPIO_REF(${ovp_signal_gpio}) 0>; /* OVP_SIG_FLAGB */
#endif
	};

	sb_tx: sb-tx { aov {}; };
};

&sec_battery {

	pinctrl-names = "default";
	pinctrl-0 = <
#if 0
			&ovp_sig_flagb_default
#endif
#if 1
			&ovp_pwr_flagb_default
#endif
			>;

	battery,wireless_charger_name = "mfc-charger";

	battery,batt_data_version = <1>;

	battery,chip_vendor = "LSI";

	battery,temp_adc_type = <SEC_BATTERY_ADC_TYPE_AP>;
	battery,temp_check_type = <SEC_BATTERY_TEMP_CHECK_TEMP>;
	battery,usb_temp_check_type = <SEC_BATTERY_TEMP_CHECK_TEMP>;
	battery,chg_temp_check_type = <SEC_BATTERY_TEMP_CHECK_TEMP>;
	battery,wpc_temp_check_type = <SEC_BATTERY_TEMP_CHECK_TEMP>;
	battery,dchg_temp_check_type = <SEC_BATTERY_TEMP_CHECK_TEMP>;
	battery,lrp_temp_check_type = <SEC_BATTERY_TEMP_CHECK_TEMP>;

	battery,thermal_source = <SEC_BATTERY_THERMAL_SOURCE_ADC>;
	battery,usb_thermal_source = <SEC_BATTERY_THERMAL_SOURCE_ADC>;
	battery,chg_thermal_source = <SEC_BATTERY_THERMAL_SOURCE_ADC>;
	battery,wpc_thermal_source = <SEC_BATTERY_THERMAL_SOURCE_ADC>;
	battery,dchg_thermal_source = <SEC_BATTERY_THERMAL_SOURCE_CHG_ADC>;

	battery,temp_table_adc = <
		307 342 396 459 542
		640 739 866 1006 1170
		1340 1535 1752 1990 2220
		2443 2679 2911 3119 3290
		3456 3602 3711
		>;
	battery,temp_table_data = <
		900 850 800 750 700
		650 600 550 500 450
		400 350 300 250 200
		150 100 50 0 (-50)
		(-100) (-150) (-200)
		>;

	battery,usb_temp_table_adc = <
		288 332 389 455 540
		641 745 874 1024 1188
		1370 1576 1794 2026 2253
		2492 2729 2951 3154 3337
		3482 3608 3716
		>;
	battery,usb_temp_table_data = <
		900 850 800 750 700
		650 600 550 500 450
		400 350 300 250 200
		150 100 50 0 (-50)
		(-100) (-150) (-200)
		>;

	battery,chg_temp_table_adc = <
		267 317 377 442 521
		613 720 845 982 1145
		1329 1533 1753 1967 2203
		2452 2691 2904 3112 3285
		3443 3573 3689
		>;
	battery,chg_temp_table_data = <
		900 850 800 750 700
		650 600 550 500 450
		400 350 300 250 200
		150 100 50 0 (-50)
		(-100) (-150) (-200)
		>;

	battery,wpc_temp_table_adc = <
		307 342 396	459 542
		640 739 866 1006 1170
		1340 1535 1752 1990 2220
		2443 2679 2911 3119 3290
		3456 3602 3711
		>;
	battery,wpc_temp_table_data = <
		900 850 800 750 700
		650 600 550 500 450
		400 350 300 250 200
		150 100 50 0 (-50)
		(-100) (-150) (-200)
		>;

	battery,dchg_temp_table_adc = <
		1437000 1418000 1395000 1371000 1341000 1306000 1266000 1219000 1166000 1105000
		1035000 957000 873000 790000 699000 604000 513000 430000 356000 288000
		229000 179000 136000
		>;
	battery,dchg_temp_table_data = <
		900 850 800 750 700 650 600 550 500 450
		400 350 300 250 200 150 100 50 0 (-50)
		(-100) (-150) (-200)
		>;

	battery,dchg_temp_offset = <5000000>;

	battery,support_usb_conn_check;
	battery,usb_protection_temp = <500>;
	battery,temp_gap_bat_usb = <150>;

	battery,loosened_unknown_temp;
	battery,abnormal_wpc_check;
	battery,wire_warm_current = <2700>;
	battery,wire_cool1_current = <2700>;	/* 0.72C */
	battery,wire_cool2_current = <900>;	/* 0.24C */
	battery,wire_cool3_current = <370>;	/* 0.1C */
	battery,wireless_warm_current = <2790>;		/* 0.72C */
	battery,wireless_cool1_current = <2733>;	/* 0.72C */
	battery,wireless_cool2_current = <866>;	/* 0.24C */
	battery,wireless_cool3_current = <333>;		/* 0.1C */

	battery,full_check_type = <SEC_BATTERY_FULLCHARGED_FG_CURRENT>;
	battery,full_check_type_2nd = <SEC_BATTERY_FULLCHARGED_FG_CURRENT>;

	battery,chg_high_temp = <590>;
	battery,chg_high_temp_recovery = <530>;

	/* 45w pwr on, 45w pwr off, 25w pwr on, 25w pwr off */
	battery,dchg_high_temp = <1000 1000 590 590>;
	battery,dchg_high_temp_recovery = <1000 1000 530 530>;
	battery,dchg_high_batt_temp = <1000 1000 1000 400>; /* DISABLED */
	battery,dchg_high_batt_temp_recovery = <1000 1000 1000 390>; /* DISABLED */
	battery,dctp_bootmode_en;
	battery,dchg_dc_in_swelling;
	battery,support_fpdo_dc;
	battery,fpdo_dc_charge_power = <19125>; /* 9V * 2.125A = 19.125W */

	battery,icl_by_tx_gear = <1100>;
	battery,fcc_by_tx_gear = <1400>;
	battery,fcc_by_tx = <800>;

	battery,standard_curr = <2800>;
	battery,expired_time = <9300>; /* 155 minutes */
	battery,recharging_expired_time = <5400>;

	battery,charging_reset_time = <0>;

	battery,max_charging_current = <MAX_FCC>;
	battery,max_charging_charge_power = <25000>; /* 25W */

	battery,chg_float_voltage = <MAX_FV>;
	battery,high_temp_float = <4200>;
	battery,low_temp_float = <MAX_FV>;
	battery,swelling_high_rechg_voltage = <4050>;
	battery,swelling_low_rechg_voltage = <4300>;
	battery,chgen_over_swell_rechg_vol;

	battery,chg_ocp_current = <0>;
	battery,chg_ocp_dtc = <100>;

	battery,enable_check_wpc_temp_v2;
	battery,wpc_high_temp = <405>;
	battery,wpc_high_temp_recovery = <395>;
	battery,wpc_temp_v2_cond = <385>;
	battery,wpc_input_limit_current = <800>;
	battery,wpc_charging_limit_current = <WC_MAX_FCC>;

	battery,enable_mix_v2;
	battery,mix_v2_lrp_recov = <440>;
	battery,mix_v2_lrp_cond = <460>;
	battery,mix_v2_bat_cond = <480>;
	battery,mix_v2_chg_cond = <0>;
	battery,mix_v2_dchg_cond = <0>;

	battery,siop_hv_icl = <675>;
	battery,siop_hv_wpc_icl = <500>;
	battery,rechg_hv_wpc_icl = <300>;

	battery,siop_scenarios = <20 0>;
	battery,siop_curr_type_num = <3>;
	/* nv, hv, fpdo */
	battery,siop_icl_20 = <1000 1000 1000>;
	battery,siop_fcc_20 = <SIOP_DEFAULT SIOP_DEFAULT SIOP_DEFAULT>;
	battery,siop_icl_0 = <SIOP_DEFAULT SIOP_DEFAULT SIOP_DEFAULT>;
	battery,siop_fcc_0 = <100 100 100>;

	battery,full_condition_vcell = <4400>;
	battery,recharge_condition_vcell = <4380>;
	battery,battery_full_capacity = <3900>;

	battery,age_data_by_offset; /* Calculate Based on Offset */
	battery,age_data_cycle = <0 200 250 300 1000>;
	battery,age_data_full_condition_soc = <93 92 91 90 89>;
	battery,age_data_chg_float_voltage_offset = <0 20 40 60 110>;
	battery,age_data_full_condition_vcell_offset = <0 20 40 60 110>;
	battery,age_data_recharge_condition_vcell_offset = <0 20 40 60 110>;

	battery,health_condition_asoc = <75 65 55>;

	/* trig_step2_LCD_OFF, recov_step2_LCD_OFF, trig_step1_LCD_OFF , recov_step1_LCD_OFF,
	   trig_step2_LCD_ON, recov_step2_LCD_ON, trig_step1_LCD_ON , recov_step1_LCD_ON,
	   st1_icl, st1_fcc, st2_icl, st2_fcc */
	battery,temp_table_LRP_NORMAL = <
						390 380 380 370
						390 380 380 370
						1000 2000 1200 1800>;
	battery,temp_table_LRP_25W = <
						410 400 390 380
						400 390 380 370
						1700 3400 1100 2200>;

	/* step charging option */
	battery,step_chg_type = <0x8D>;
	battery,step_chg_en_in_factory;
	battery,step_chg_step = <3>;
	battery,step_chg_charge_power = <12000>;
	battery,step_chg_cond = <
				4140 4260 MAX_FV
				4140 4260 MAX_FV
				4140 4260 MAX_FV
				4140 4260 MAX_FV
				>;
	battery,step_chg_curr = <MAX_FCC 3657 2926>;
	battery,step_chg_vfloat = <4140 4260 MAX_FV>;
	battery,step_chg_cond_soc = <40 65 80
					40 65 80
					40 65 80
					40 65 80>;

	/* wpc step charging option */
	battery,wpc_step_chg_type = <0x21>;
	battery,wpc_step_chg_step = <2>;
	battery,wpc_step_chg_charge_power = <5000>;
	battery,wpc_step_chg_cond = <
				4210 MAX_FV
				4210 MAX_FV
				4210 MAX_FV
				4210 MAX_FV
				>;
	battery,wpc_step_chg_cond_curr = <WC_MAX_FCC WC_MAX_FCC>;
	battery,wpc_step_chg_curr = <WC_MAX_FCC 2926>;
	battery,wpc_step_chg_vfloat = <4260 MAX_FV>;

	/* direct step charging option */
	battery,dc_step_chg_cond_v_margin = <10>;
	battery,dc_step_chg_type = <0x2A9>;
	battery,dc_step_chg_charge_power = <22000>;
	battery,dc_step_chg_step = <3>;
	battery,dc_step_chg_cond_vol = <4140 4260 MAX_FV>;
	battery,dc_step_chg_val_vfloat = <4140 4260 MAX_FV>;
	battery,dc_step_chg_val_iout = <4720 3610 2870>;
	battery,dc_step_chg_vol_offset = <0 0 0>;
	battery,dc_step_chg_cond_iin = <1805 1435 0>;
	battery,dc_step_chg_iin_check_cnt = <3>;
	battery,dc_step_chg_cond_soc = <46 66 80
					46 66 80
					46 66 80
					46 66 80>;	/* <25w 3step> STEP_CHARGING_CONDITION_SOC */

	battery,dis_auto_shipmode_temp_ctrl;
	battery,boosting_voltage_aicl;

	battery,cisd_max_voltage_thr = <4520>; /* battery ovp detection voltage */
	battery,cisd_alg_index = <8>;
	battery,ignore_cisd_index = <0 0>;
	battery,ignore_cisd_index_d = <0 80>; /* Do not use BUCK_OFF_PER_DAY, DROP_SENSOR_PER_DAY */

	battery,tx_stop_capacity = <30>;
	battery,tx_minduty_default = <20>;
	battery,tx_minduty_5V = <50>;

	battery,tx_uno_iout = <1500>;
	battery,tx_uno_iout_gear = <2000>;
	battery,tx_uno_iout_aov_gear = <1500>;
	battery,tx_mfc_iout_gear = <1500>;
	battery,tx_mfc_iout_aov_gear = <900>;
	battery,tx_mfc_iout_phone = <1100>;
	battery,tx_mfc_iout_phone_5v = <300>;
	battery,tx_mfc_iout_lcd_on = <900>;

	battery,tx_5v_disable;
	battery,phm_vout_ctrl_dev = <SEC_WIRELESS_PHM_VOUT_CTRL_BUDS>;

	battery,nv_wc_headroom = <WIRELESS_VRECT_ADJ_OFF>;

	battery,wpc_vout_ctrl_lcd_on;
	battery,wpc_flicker_wa_input_limit_current = <500>;
	battery,wpc_warm_fod;
	battery,wc21_icl = <1200>;

	battery,support_spsn_ctrl;

	battery,ttf_capacity = <4000>;
	battery,ttf_hv_charge_current = <3050>;
	battery,ttf_fpdo_dc_charge_current = <3260>;
	battery,ttf_dc25_charge_current = <3850>;
	battery,ttf_wireless_charge_current = <863>;
	battery,ttf_hv_wireless_charge_current = <1670>;
	battery,ttf_wc20_wireless_charge_current = <2340>;
	battery,ttf_wc21_wireless_charge_current = <2740>;

	battery,cv_data = <
		2754	850	1584
		2639	860	1532
		2214	880	1418
		1812	900	1284
		1457	920	1108
		1122	940	890
		800	960	600
		550	980	175
		510	990	30
		435	1000	0
		>;
};

&sec_battery_cable {
	default_input_current = <1800>;
	default_charging_current = <2100>;
	full_check_current_1st = <388>;
	full_check_current_2nd = <194>;

	current_group_1 {
		cable_number = <
			SEC_BATTERY_CABLE_PREPARE_TA
			SEC_BATTERY_CABLE_PDIC
			SEC_BATTERY_CABLE_OTG
			SEC_BATTERY_CABLE_LAN_HUB
			SEC_BATTERY_CABLE_POWER_SHARING
			SEC_BATTERY_CABLE_TIMEOUT>;
		input_current = <500>;
		charging_current = <500>;
	};
	current_group_2 {
		cable_number = <
			SEC_BATTERY_CABLE_HMT_CHARGE
			SEC_BATTERY_CABLE_SMART_OTG>;
		input_current = <1000>;
		charging_current = <1000>;
	};
	current_group_3 {
		cable_number = <
			SEC_BATTERY_CABLE_USB_CDP
			SEC_BATTERY_CABLE_SMART_NOTG>;
		input_current = <1500>;
		charging_current = <1500>;
	};
	current_group_4 {
		cable_number = <
			SEC_BATTERY_CABLE_9V_TA
			SEC_BATTERY_CABLE_9V_ERR
			SEC_BATTERY_CABLE_9V_UNKNOWN>;
		input_current = <1650>;
		charging_current = <MAX_FCC>;
	};
	current_group_5 {
		cable_number = <SEC_BATTERY_CABLE_12V_TA>;
		input_current = <1650>;
		charging_current = <MAX_FCC>;
	};
	current_group_6 {
		cable_number = <
			SEC_BATTERY_CABLE_WIRELESS
			SEC_BATTERY_CABLE_PMA_WIRELESS
			SEC_BATTERY_CABLE_WIRELESS_STAND
			SEC_BATTERY_CABLE_WIRELESS_VEHICLE
			SEC_BATTERY_CABLE_HV_WIRELESS_20_LIMIT
			SEC_BATTERY_CABLE_WIRELESS_EPP_NV>;
		input_current = <800>;
		charging_current = <WC_MAX_FCC>;
	};
	current_group_7 {
		cable_number = <SEC_BATTERY_CABLE_WIRELESS_PACK>;
		input_current = <WC_5V_ICL>;
		charging_current = <WC_MAX_FCC>;
	};
	current_group_8 {
		cable_number = <SEC_BATTERY_CABLE_HMT_CONNECTED>;
		input_current = <1000>;
		charging_current = <450>;
	};
	current_group_9 {
		cable_number = <SEC_BATTERY_CABLE_HV_TA_CHG_LIMIT>;
		input_current = <2000>;
		charging_current = <1800>;
	};
	current_group_10 {
		cable_number = <
			SEC_BATTERY_CABLE_HV_WIRELESS
			SEC_BATTERY_CABLE_WIRELESS_HV_PACK
			SEC_BATTERY_CABLE_WIRELESS_HV_STAND
			SEC_BATTERY_CABLE_WIRELESS_HV_VEHICLE>;
		input_current = <750>;
		charging_current = <WC_MAX_FCC>;
	};
	current_group_11 {
		cable_number = <
			SEC_BATTERY_CABLE_PREPARE_WIRELESS_HV
			SEC_BATTERY_CABLE_WIRELESS_FAKE
			SEC_BATTERY_CABLE_PREPARE_WIRELESS_20>;
		input_current = <500>;
		charging_current = <1400>;
	};
	current_group_12 {
		cable_number = <
			SEC_BATTERY_CABLE_NONE
			SEC_BATTERY_CABLE_USB>;
		input_current = <475>;
		charging_current = <550>;
	};
	current_group_13 {
		cable_number = <
			SEC_BATTERY_CABLE_HV_WIRELESS_20
			SEC_BATTERY_CABLE_WIRELESS_EPP_FAKE
			SEC_BATTERY_CABLE_WIRELESS_EPP>;
		input_current = <400>;
		charging_current = <WC_MAX_FCC>;
	};
	current_group_14 {
		cable_number = <SEC_BATTERY_CABLE_WIRELESS_TX>;
		input_current = <WC_5V_ICL>;
		charging_current = <WC_MAX_FCC>;
	};
};

/* /home/dpi/qb5_8814/workspace/P4_1716/android/kernel/kmodule/battery/stable/eureka/common/dts/e1s/battery_common.06.dtsi */
/* HWID06 */
/* revision devicetree for general */
#include "s5e9945.e1s_kor_singlex.08.dtsi"

/ {
	compatible = "SAMSUNG,E1S_KOR_SINGLEX","SAMSUNG,S5E9945";
	dtbo-hw_rev = <8>;
	dtbo-hw_rev_end = <9>;
};
