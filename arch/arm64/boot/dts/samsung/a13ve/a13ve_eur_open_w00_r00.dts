
/*
 * Copyright (c) 2018 Samsung Electronics Co., Ltd.
 *              http://www.samsung.com
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 as
 * published by the Free Software Foundation.
*/

/dts-v1/;
/plugin/;
/ {
	fragment@smd {
		target-path = "/";
		__overlay__ {
			smd: samsung_mobile_device {
				compatible = "simple-bus";
			};
		};
	};
};

/* #include "../sm5714_fuelgauge.dtsi" */            /* From sm5714_fuelgauge.py */
/*
 * sm5714 battery device tree common
 *
 * Copyright (c) 2021 Samsung Electronics Co., Ltd.
 *		http://www.samsung.com
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 as
 * published by the Free Software Foundation.
 */

&smd {
	sm5714_fuelgauge: sm5714-fuelgauge {
		status = "okay";
		fuelgauge,fuel_alert_soc = <1>;
		fuelgauge,capacity_max = <1000>;
		fuelgauge,capacity_max_margin = <300>;
		fuelgauge,capacity_min = <0>;
		fuelgauge,capacity_calculation_type = <0x1F>;
		fuelgauge,using_temp_compensation;
		fuelgauge,low_temp_limit = <100>;
		fuelgauge,using_hw_vempty;
		fuelgauge,sw_v_empty_voltage = <3200>;
		fuelgauge,sw_v_empty_voltage_cisd = <3100>;
		fuelgauge,sw_v_empty_recover_voltage = <3480>;
		fuelgauge,capacity = <4000>;
#if 0
		fuelgauge,bat_id_gpio = <
				SEC_GPIO_REF(${bat_id_gpio_02}) 0  /* BAT_ID_2 */
				SEC_GPIO_REF(${bat_id_gpio_01}) 0  /* BAT_ID_1 */
				>;
#endif

		battery_params {
			battery,id = <0>;
			battery0,battery_type = <4400 0x1D44>; /* batt_v_max, cap */
			battery0,battery_table0 = <
				0x1400 0x1B33 0x1BAF 0x1CDD 0x1D5D 0x1D82 0x1D8A 0x1D9D
				0x1DDF 0x1E2C 0x1E50 0x1E7D 0x1EDE 0x1F30 0x1F74 0x1FC0
				0x1FE0 0x1FF4 0x201E 0x20B8 0x20D7 0x210B 0x2260 0x2400
				>;
			battery0,battery_table1 = <
				0x0000 0x0098 0x00F5 0x034C 0x04E6 0x0799 0x0A4C 0x0D00
				0x124C 0x1D19 0x2519 0x2D33 0x354C 0x3A99 0x3D4C 0x42B3
				0x4566 0x4819 0x4AB3 0x5019 0x52CC 0x5580 0x6400 0x6419
				>;
			battery0,battery_table2 = <
				0x4B 0x44 0x40 0x3E 0x3C 0x3B 0x38 0x37
				0x35 0x34 0x34 0x33 0x33 0x33 0x33 0x32
				>;
			/*spare factor chg_factor dischg_factor manvalue*/
			battery0,rs_value = <0x00 0x266 0x599 0x599 0x29>;
			battery0,v_alarm = <3100 0>;
			battery0,topoff = <400>;
			battery0,i_cal = <1 0 0 0 1 0 0 0 >;
			battery0,v_cal = <1 0 0 1 0 0 0>;
			battery0,temp_std = <25>;
			battery0,tem_poff = <3400 50 3250 50>;
			battery0,aux_ctrl = <0x303>;
			battery0,data_ver = <4>;
			battery0,v_max_table = <0x2260 0x2220 0x21FD 0x21DB 0x2185>;
			battery0,q_max_table = <0x1D44 0x1CC4 0x1C44 0x1BC4 0x1A85>;
		};
	};
};


&smd {
	battery {
		battery,fgsrc_switch_name = "sm5714-fuelgauge";
	};
};

/* /home/dpi/qb5_8815/workspace/P4_1716/android/kernel/kmodule/battery/suwon/fuelgauge/sm5714/sm5714_fuelgauge.a13ve.dtsi */
/*
 * A13ve battery device tree common
 *
 * Copyright (c) 2022 Samsung Electronics Co., Ltd.
 *		http://www.samsung.com
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 as
 * published by the Free Software Foundation.
 */

&sm5714_fuelgauge {
	status = "okay";
	fuelgauge,fuel_alert_soc = <1>;
	fuelgauge,capacity_max = <1000>;
	fuelgauge,capacity_max_margin = <300>;
	fuelgauge,capacity_min = <0>;
	fuelgauge,capacity_calculation_type = <0x1F>;
	fuelgauge,using_temp_compensation;
	fuelgauge,low_temp_limit = <100>;
	fuelgauge,using_hw_vempty;
	fuelgauge,sw_v_empty_voltage = <3200>;
	fuelgauge,sw_v_empty_voltage_cisd = <3100>;
	fuelgauge,sw_v_empty_recover_voltage = <3480>;
	fuelgauge,capacity = <5000>;
	battery_params {
		battery,id = <0>;
		battery0,battery_type = <4350 0x2462>; /* batt_v_max, cap */
		battery0,battery_table0 = <
			0x1400 0x1B63 0x1C6C 0x1D31 0x1D69 0x1D79 0x1D8D 0x1DB3
			0x1DEA 0x1E0F 0x1E3B 0x1E57 0x1E74 0x1E99 0x1EC8 0x1F04
			0x1F32 0x1F7C 0x1FCF 0x2023 0x20B8 0x215C 0x2263 0x2400
			>;
		battery0,battery_table1 = <
			0x0000 0x00B3 0x024C 0x0466 0x0580 0x0680 0x0C4C 0x0EE6
			0x1433 0x1966 0x1EB3 0x23E6 0x2933 0x2E66 0x33B3 0x38E6
			0x3B99 0x3E33 0x4366 0x48B3 0x5099 0x5866 0x6400 0x6480>;
		battery0,battery_table2 = <
			0x444B 0x3E40 0x3B3C 0x3738 0x3435 0x3334 0x3333 0x3233
			0x444B 0x3E40 0x3B3C 0x3738 0x3435 0x3334 0x3333 0x3233
			>;
		/*spare min max factor chg_factor dischg_factor manvalue*/
		battery0,rs_value = <0x48 0x48 0x3800 0x10A 0x599 0x599 0x50>;
		battery0,v_alarm = <3100 200>;
		battery0,topoff = <500>;
		battery0,i_cal = <1 0x0 0x0800 0x0800 0 0x0 0x07E5 0x07E0>;
		battery0,v_cal = <1 0x0 0x0 1 0x0 0x0 0x0>;
		battery0,temp_std = <25>;
		battery0,tem_poff = <3400 50 3250 50>;
		battery0,aux_ctrl = <0x322 0x5800>;
		battery0,data_ver = <5>;
		battery0,v_max_table = <0x2263 0x223C 0x2215 0x21EE 0x218C>;
		battery0,q_max_table = <0x2462 0x23BB 0x2313 0x226C 0x20CA>;
	};
};

/* #include "../sensorhub_shub.dtsi" */              /* From sensorhub_shub.py */
#if 0
&${sensor_vdd_1p8} {
	regulator-name = "VDD_SENSOR_1P8";
};
#endif

/ {
	fragment@model {
		target-path = "/";
		__overlay__ {
			shub {
#if 0
				sensor-vdd-regulator = "VDD_SENSOR_1P8";
#endif

#if 0
				mag-check-nfc = <SEC_GPIO_REF(${gpio_nfc_check}) 0>;
#endif
			};
		};
	};
};

/* #include "../sec_pinctrl_wrapper.dtsi" */         /* From sec_pinctrl_wrapper.py */
#define PIN_FUNC_INPUT		input-enable
#define PIN_FUNC_INPUT_WAKEUP	input-enable
#define PIN_FUNC_OUTPUT		output-enable
#define PIN_FUNC_OUTPUT_HIGH		output-high
#define PIN_FUNC_OUTPUT_LOW		output-low

#define PIN_PULL_NONE	bias-disable
#define PIN_PULL_DOWN	bias-pull-down
#define PIN_PULL_UP	bias-pull-up
#define PIN_PULL_OPEN	bias-high-impedance

/*
 * MTK_DRIVE_2mA  2
 * MTK_DRIVE_4mA  4
 * MTK_DRIVE_6mA  6
 * MTK_DRIVE_8mA  8
 * MTK_DRIVE_10mA 10
 * MTK_DRIVE_12mA 12
 * MTK_DRIVE_14mA 14
 * MTK_DRIVE_16mA 16
 */

#define PIN_DRV_LV1	2
#define PIN_DRV_LV2	4
#define PIN_DRV_LV3	6
#define PIN_DRV_LV4	8
#define PIN_DRV_LV5	10
#define PIN_DRV_LV6	12
#define PIN_DRV_LV7	14
#define PIN_DRV_LV8	16

#define PIN_EXPAND(pin) #pin

#define SEC_GPIO(src, type, num)	PIN_EXPAND(gpio##num)
#define SEC_GPIO_REF(src, type, num)	&type num
#define SEC_GPIO_NUM(src, type, num)	num
#define SEC_GPIO_TYPE(src, type, num)	&type
#define SEC_GPIO_PHANDLE_ACTIVE(src, type, num)	SEC_GPIO_PHANDLE(type, num, active)
#define SEC_GPIO_PHANDLE_SLEEP(src, type, num)	SEC_GPIO_PHANDLE(type, num, sleep)
#define SEC_GPIO_PHANDLE(type, num, mode)	type##_##num##_##mode

#define MTK_PINMUX(gpio, func) (MTK_PIN_NO(gpio) | func)

#define GPIO_CONFIG(_src, _type, _num, _func)		\
	pins_cmd_dat{					\
		pinmux = <MTK_PINMUX(SEC_GPIO_NUM(_src, _type, _num), 0)>;	\
		PIN_ ##_func;		\
	}

#define GPIO_CONFIG_PUD(_src, _type, _num, _func, _pull)	\
	pins_cmd_dat{					\
		pinmux = <MTK_PINMUX(SEC_GPIO_NUM(_src, _type, _num), 0)>;	\
		PIN_ ##_pull;				\
		PIN_ ##_func;		\
	}

#define GPIO_CONFIG_PUD_DRV(_src, _type, _num, _func, _pull, _drv)	\
	pins_cmd_dat{					\
		pinmux = <MTK_PINMUX(SEC_GPIO_NUM(_src, _type, _num), 0)>;	\
		PIN_ ##_pull;				\
		PIN_ ##_func;		\
		drive-strength = <PIN_ ##_drv>;	\
	}

#define SEC_ADC(type, num) <&type num>
#define SEC_ADC_OPT(type, num) ,<&type num>
#define SEC_ADC_NUM(type, num) <num>

/* #include "../input_booster.dtsi" */               /* From input_booster.py */
/* Copyright (c) 2019, The Linux Foundation. All rights reserved.
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 and
 * only version 2 as published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 */

&smd {
	input_booster {
		status = "okay";
		compatible = "input_booster";
		resValcount = "2";
		max_resource_count = "3";
		max_cluster_count = "3";
		#address-cells = <1>;
		#size-cells = <0>;

		/* Each Cpu Cluster Start Cpu */
		cpu_cluster_policy = "6,0";

		/* < CPU, DDR > */
		ib_release_values = "-1,16,0";

		/* Select Allowed Resource Index Group */
		allowed_resources = "0,1";

		booster_key@1 {
			input_booster,label = "key";
			input_booster,type = <0>;	/* BOOSTER_DEVICE_KEY */

			/* Time table */
			input_booster,head_time = <200>;
			input_booster,tail_time = <0>;

			/* Resource Table Sequentially identified with index
			 * CPU's ID & Index : 0
			 * DDR's ID & Index : 1
			*/

			/* Input Booster Resource Frequency */
			inputbooster,resource {
				compatible = "resource";
				resource@1 {
					resource,label = "CPU";
					resource,value = <1354000 0>;
				};

				resource@2 {
					resource,label = "DDR";
					resource,value = <0 0>;
				};
			};
		};

		booster_key@2 {
			input_booster,label = "touchkey";
			input_booster,type = <1>;	/* BOOSTER_DEVICE_TOUCHKEY */

			/* Time table */
			input_booster,head_time = <1>;
			input_booster,tail_time = <300>;

			/* Input Booster Resource Frequency */
			inputbooster,resource {
				compatible = "resource";
				resource@1 {
					resource,label = "CPU";
					resource,value = <0 1176000>;
				};

				resource@2 {
					resource,label = "DDR";
					resource,value = <0 0>;
				};
			};
		};

		booster_key@3 {
			input_booster,label = "touch";
			input_booster,type = <2>;	/* BOOSTER_DEVICE_TOUCH */

			/* Time table */
			input_booster,head_time = <130>;
			input_booster,tail_time = <500>;

			/* Input Booster Resource Frequency */
			inputbooster,resource {
				compatible = "resource";
				resource@1 {
					resource,label = "CPU";
					resource,value = <1354000 1176000>;
				};

				resource@2 {
					resource,label = "DDR";
					resource,value = <3600 3600>;
				};
			};
		};

		booster_key@4 {
			input_booster,label = "multitouch";
			input_booster,type = <3>;	/* BOOSTER_DEVICE_MULTITOUCH */

			/* Time table */
			input_booster,head_time = <1000>;
			input_booster,tail_time = <500>;

			/* Input Booster Resource Frequency */
			inputbooster,resource {
				compatible = "resource";
				resource@1 {
					resource,label = "CPU";
					resource,value = <1354000 1176000>;
				};

				resource@2 {
					resource,label = "DDR";
					resource,value = <0 0>;
				};
			};
		};

		booster_key@5 {
			input_booster,label = "keyboard";
			input_booster,type = <4>;	/* BOOSTER_DEVICE_KEYBOARD */

			/* Time table */
			input_booster,head_time = <200>;
			input_booster,tail_time = <200>;

			/* Input Booster Resource Frequency */
			inputbooster,resource {
				compatible = "resource";
				resource@1 {
					resource,label = "CPU";
					resource,value = <1176000 1176000>;
				};

				resource@2 {
					resource,label = "DDR";
					resource,value = <0 0>;
				};
			};
		};

		booster_key@6 {
			input_booster,label = "MOUSE";
			input_booster,type = <5>;	/* BOOSTER_DEVICE_MOUSE */

			/* Time table */
			input_booster,head_time = <200>;
			input_booster,tail_time = <300>;

			/* Input Booster Resource Frequency */
			inputbooster,resource {
				compatible = "resource";
				resource@1 {
					resource,label = "CPU";
					resource,value = <1354000 1176000>;
				};

				resource@2 {
					resource,label = "DDR";
					resource,value = <0 0>;
				};
			};
		};

		booster_key@7 {
			input_booster,label = "mouse_wheel";
			input_booster,type = <6>;	/* BOOSTER_DEVICE_MOUSE */

			/* Time table */
			input_booster,head_time = <200>;
			input_booster,tail_time = <0>;

			/* Input Booster Resource Frequency */
			inputbooster,resource {
				compatible = "resource";
				resource@1 {
					resource,label = "CPU";
					resource,value = <1354000 0>;
				};

				resource@2 {
					resource,label = "DDR";
					resource,value = <0 0>;
				};
			};
		};

		booster_key@8 {
			input_booster,label = "pen_hover";
			input_booster,type = <7>;	/* BOOSTER_DEVICE_MOUSE */

			/* Time table */
			input_booster,head_time = <200>;
			input_booster,tail_time = <300>;

			/* Input Booster Resource Frequency */
			inputbooster,resource {
				compatible = "resource";
				resource@1 {
					resource,label = "CPU";
					resource,value = <1354000 1176000>;
				};

				resource@2 {
					resource,label = "DDR";
					resource,value = <0 0>;
				};
			};
		};

		booster_key@9 {
			input_booster,label = "pen";
			input_booster,type = <8>;	/* BOOSTER_DEVICE_MOUSE */

			/* Time table */
			input_booster,head_time = <200>;
			input_booster,tail_time = <600>;

			/* Input Booster Resource Frequency */
			inputbooster,resource {
				compatible = "resource";
				resource@1 {
					resource,label = "CPU";
					resource,value = <1354000 1176000>;
				};

				resource@2 {
					resource,label = "DDR";
					resource,value = <0 0>;
				};
			};
		};
		/* If you need to add new key type, add it this position */
	};
};

/* #include "../vibrator_vib_info.dtsi" */           /* From vibrator_vib_info.py */

&smd {
	vib_info: vibrator_info {
		status = "okay";
		compatible = "samsung,vib-info";
		functions = "";
#if 0
		samsung,intensities = <>;
#else
		samsung,intensities = <>;
#endif

#if 0
		samsung,haptic_intensities = <>;
#else
		samsung,haptic_intensities = <>;
#endif
	};
};

/* #include "../sm5714_charger.dtsi" */              /* From sm5714_charger.py */
#if 0
&${pogo_int_gpio_parent} {
	pogo_int_default: pogo_int_default {
		GPIO_CONFIG_PUD(${pogo_int_gpio}, FUNC_INPUT_WAKEUP, PULL_NONE);
	};
};
#endif

&smd {
    sm5714_charger: sm5714-charger {
		status = "disable";
		compatible = "samsung,sm5714-charger";

#if 0
		pinctrl-names = "default";
		pinctrl-0 = <&pogo_int_default>;
		charger,pogo_int = <SEC_GPIO_REF(${pogo_int_gpio}) 0>; /* POGO_INT */
#endif
	};

	battery {
		battery,otg_name = "sm5714-otg";
	};
};

/* #include "../ap_mtk_mt6769t.dtsi" */              /* From ap_mtk_mt6769t.py */
#include <dt-bindings/clock/mt6768-clk.h>

#define topckgen_clk topckgen
#define infracfg_ao_clk infracfg_ao
/* /home/dpi/qb5_8815/workspace/P4_1716/android/kernel/kmodule/ap/mtk/mt6769t/ap_mtk_mt6769t.a13ve_eur.00.dtsi */
#include <dt-bindings/clock/mt6768-clk.h>
#include "../../mediatek/k69v1_64_titan_bengal_tiger/Board_00.dts"
#include "../../mediatek/k69v1_64_titan_bengal_tiger/gpio00.dtsi"

/* #include "../sensorhub_mt6769t_shub.dtsi" */      /* From sensorhub_mt6769t_shub.py */
/ {
	fragment@model {
		target-path = "/";
		__overlay__ {
			shub {
				compatible = "shub";
			};
		};
	};
};

/* /home/dpi/qb5_8815/workspace/P4_1716/android/kernel/kmodule/sensorhub/mtk/mt6769t_shub/dts/sensorhub_mt6769t_shub.a13ve.dtsi */
/ {
	fragment@model {
		target-path = "/";
		__overlay__ {
			shub {
				acc-motor-coef = <20>;
				acc-lis2dlc12-position = <8>;
				mag-ak09918c-position = <1>;
				mag-check-nfc = <&pio 52 0>;
				mag-ak09918c-nfc-array = /bits/ 8 <90 92 55 13 83 68 0 130 208
								54 239 119 155 28 252 232 4 175
								184 99 192 8 110 110 11 77 60>;
				mag-ak09918c-array = /bits/ 8 <158 83 203 57 214 3 0 216 214
								54 97 65 52 40 254 87 0 238
								255 182 192 255 92 150 10 30 240>;
			};
		};
	};
};
/* #include "../pmic_MT6358.dtsi" */                 /* From pmic_MT6358.py */
#if 0 && 0
&mt_pmic_vdram2_ldo_reg {
    regulator-min-microvolt = <0>;
    regulator-max-microvolt = <0>;
    
     
};
#endif

#if 0 && 0
&mt_pmic_vsim1_ldo_reg {
    regulator-min-microvolt = <0>;
    regulator-max-microvolt = <0>;
    
     
};
#endif

#if 3000000 && 3000000
&mt_pmic_vibr_ldo_reg {
    regulator-min-microvolt = <3000000>;
    regulator-max-microvolt = <3000000>;
    
     
};
#endif

#if 0 && 0
&mt_pmic_vrf12_ldo_reg {
    regulator-min-microvolt = <0>;
    regulator-max-microvolt = <0>;
    
     
};
#endif

#if 0 && 0
&mt_pmic_vio18_ldo_reg {
    regulator-min-microvolt = <0>;
    regulator-max-microvolt = <0>;
    
     
};
#endif

#if 0 && 0
&mt_pmic_vusb_ldo_reg {
    regulator-min-microvolt = <0>;
    regulator-max-microvolt = <0>;
    
     
};
#endif

#if 1800000 && 1800000
&mt_pmic_vcamio_ldo_reg {
    regulator-min-microvolt = <1800000>;
    regulator-max-microvolt = <1800000>;
    
     
};
#endif

#if 0 && 0
&mt_pmic_vcamd_ldo_reg {
    regulator-min-microvolt = <0>;
    regulator-max-microvolt = <0>;
    
     
};
#endif

#if 0 && 0
&mt_pmic_vcn18_ldo_reg {
    regulator-min-microvolt = <0>;
    regulator-max-microvolt = <0>;
    
     
};
#endif

#if 0 && 0
&mt_pmic_vfe28_ldo_reg {
    regulator-min-microvolt = <0>;
    regulator-max-microvolt = <0>;
    
     
};
#endif

#if 0 && 0
&mt_pmic_vsram_proc11_ldo_reg {
    regulator-min-microvolt = <0>;
    regulator-max-microvolt = <0>;
    
     
};
#endif

#if 0 && 0
&mt_pmic_vcn28_ldo_reg {
    regulator-min-microvolt = <0>;
    regulator-max-microvolt = <0>;
    
     
};
#endif

#if 0 && 0
&mt_pmic_vsram_others_ldo_reg {
    regulator-min-microvolt = <0>;
    regulator-max-microvolt = <0>;
    
     
};
#endif

#if 0 && 0
&mt_pmic_vsram_gpu_ldo_reg {
    regulator-min-microvolt = <0>;
    regulator-max-microvolt = <0>;
    
     
};
#endif

#if 0 && 0
&mt_pmic_vxo22_ldo_reg {
    regulator-min-microvolt = <0>;
    regulator-max-microvolt = <0>;
    
     
};
#endif

#if 0 && 0
&mt_pmic_vefuse_ldo_reg {
    regulator-min-microvolt = <0>;
    regulator-max-microvolt = <0>;
    
     
};
#endif

#if 0 && 0
&mt_pmic_vaux18_ldo_reg {
    regulator-min-microvolt = <0>;
    regulator-max-microvolt = <0>;
    
     
};
#endif

#if 0 && 0
&mt_pmic_vmch_ldo_reg {
    regulator-min-microvolt = <0>;
    regulator-max-microvolt = <0>;
    
     
};
#endif

#if 0 && 0
&mt_pmic_vbif28_ldo_reg {
    regulator-min-microvolt = <0>;
    regulator-max-microvolt = <0>;
    
     
};
#endif

#if 0 && 0
&mt_pmic_vsram_proc12_ldo_reg {
    regulator-min-microvolt = <0>;
    regulator-max-microvolt = <0>;
    
     
};
#endif

#if 0 && 0
&mt_pmic_vcama1_ldo_reg {
    regulator-min-microvolt = <0>;
    regulator-max-microvolt = <0>;
    
     
};
#endif

#if 0 && 0
&mt_pmic_vemc_ldo_reg {
    regulator-min-microvolt = <0>;
    regulator-max-microvolt = <0>;
    
     
};
#endif

#if 0 && 0
&mt_pmic_vio28_ldo_reg {
    regulator-min-microvolt = <0>;
    regulator-max-microvolt = <0>;
    
     
};
#endif

#if 0 && 0
&mt_pmic_va12_ldo_reg {
    regulator-min-microvolt = <0>;
    regulator-max-microvolt = <0>;
    
     
};
#endif

#if 0 && 0
&mt_pmic_vrf18_ldo_reg {
    regulator-min-microvolt = <0>;
    regulator-max-microvolt = <0>;
    
     
};
#endif

#if 0 && 0
&mt_pmic_vcn33_bt_ldo_reg {
    regulator-min-microvolt = <0>;
    regulator-max-microvolt = <0>;
    
     
};
#endif

#if 0 && 0
&mt_pmic_vcn33_wifi_ldo_reg {
    regulator-min-microvolt = <0>;
    regulator-max-microvolt = <0>;
    
     
};
#endif

#if 0 && 0
&mt_pmic_vcama2_ldo_reg {
    regulator-min-microvolt = <0>;
    regulator-max-microvolt = <0>;
    
     
};
#endif

#if 0 && 0
&mt_pmic_vmc_ldo_reg {
    regulator-min-microvolt = <0>;
    regulator-max-microvolt = <0>;
    
     
};
#endif

#if 0 && 0
&mt_pmic_vldo28_ldo_reg {
    regulator-min-microvolt = <0>;
    regulator-max-microvolt = <0>;
    
     
};
#endif

#if 0 && 0
&mt_pmic_vaud28_ldo_reg {
    regulator-min-microvolt = <0>;
    regulator-max-microvolt = <0>;
    
     
};
#endif

#if 0 && 0
&mt_pmic_vsim2_ldo_reg {
    regulator-min-microvolt = <0>;
    regulator-max-microvolt = <0>;
    
     
};
#endif

#if 0 && 0
&mt_pmic_va09_ldo_reg {
    regulator-min-microvolt = <0>;
    regulator-max-microvolt = <0>;
    
     
};
#endif

/* #include "../battery_common.dtsi" */              /* From battery_common.py */
#include <dt-bindings/battery/sec-battery.h>

&smd {
	sec_battery: battery {
		status = "okay";
		compatible = "samsung,sec-battery";
		battery,vendor = "Battery";
		battery,charger_name = "sm5714-charger";
		battery,fuelgauge_name = "sm5714-fuelgauge";
		battery,technology = <2>; /* POWER_SUPPLY_TECHNOLOGY_LION */
		battery,chip_vendor = "NONE";

		battery,batt_data_version = <1>;

		battery,adc_check_count = <5>;
		battery,temp_check_type = <SEC_BATTERY_TEMP_CHECK_NONE>;
		battery,usb_temp_check_type = <SEC_BATTERY_TEMP_CHECK_NONE>;
		battery,chg_temp_check_type = <SEC_BATTERY_TEMP_CHECK_NONE>;
		battery,wpc_temp_check_type = <SEC_BATTERY_TEMP_CHECK_NONE>;
		battery,lrp_temp_check_type = <SEC_BATTERY_TEMP_CHECK_NONE>;

		battery,thermal_source = <SEC_BATTERY_THERMAL_SOURCE_NONE>; /* SEC_BATTERY_THERMAL_SOURCE_NONE */
		battery,usb_thermal_source = <SEC_BATTERY_THERMAL_SOURCE_NONE>; /* SEC_BATTERY_THERMAL_SOURCE_NONE */
		battery,chg_thermal_source = <SEC_BATTERY_THERMAL_SOURCE_NONE>; /* SEC_BATTERY_THERMAL_SOURCE_NONE */
		battery,wpc_thermal_source = <SEC_BATTERY_THERMAL_SOURCE_NONE>; /* SEC_BATTERY_THERMAL_SOURCE_NONE */

		battery,inbat_ocv_type =  <SEC_BATTERY_OCV_NONE>;

		battery,polling_time = <10 30 30 30 3600>;

		battery,cable_check_type = <SEC_BATTERY_CABLE_CHECK_PSY>;
		battery,cable_source_type = <SEC_BATTERY_CABLE_SOURCE_EXTERNAL>;
		battery,polling_type = <SEC_BATTERY_MONITOR_ALARM>; /* SEC_BATTERY_MONITOR_ALARM */
		battery,monitor_initial_count = <0>;

		battery,battery_check_type = <0>; /* SEC_BATTERY_CHECK_NONE */

		battery,ovp_uvlo_check_type = <SEC_BATTERY_OVP_UVLO_CHGPOLLING>; /* SEC_BATTERY_OVP_UVLO_CHGPOLLING */

		battery,temp_check_count = <1>;

		battery,overheatlimit_threshold = <700>;
		battery,overheatlimit_recovery = <680>;
		battery,wire_warm_overheat_thresh = <500>;
		battery,wire_normal_warm_thresh = <420>;
		battery,wire_cool1_normal_thresh = <180>;
		battery,wire_cool2_cool1_thresh = <150>;
		battery,wire_cool3_cool2_thresh = <50>;
		battery,wire_cold_cool3_thresh = <0>;
		battery,wireless_warm_overheat_thresh = <500>;
		battery,wireless_normal_warm_thresh = <420>;
		battery,wireless_cool1_normal_thresh = <180>;
		battery,wireless_cool2_cool1_thresh = <150>;
		battery,wireless_cool3_cool2_thresh = <50>;
		battery,wireless_cold_cool3_thresh = <0>;
		battery,tx_high_threshold = <450>;
		battery,tx_high_recovery = <400>;
		battery,tx_low_threshold = <0>;
		battery,tx_low_recovery = <50>;

		battery,wire_warm_current = <1573>;	/* 0.36C */
		battery,wire_cool1_current = <3146>;	/* 0.72C */
		battery,wire_cool2_current = <1048>;	/* 0.24C */
		battery,wire_cool3_current = <437>;	/* 0.1C */
		battery,wireless_warm_current = <1048>;		/* 0.24C */
		battery,wireless_cool1_current = <3146>;	/* 0.72C */
		battery,wireless_cool2_current = <1048>;	/* 0.24C */
		battery,wireless_cool3_current = <437>;		/* 0.1C */

		battery,full_check_type = <SEC_BATTERY_FULLCHARGED_CHGPSY>;
		battery,full_check_type_2nd = <SEC_BATTERY_FULLCHARGED_CHGPSY>;
		battery,full_check_count = <1>;
		battery,chg_gpio_full_check = <0>;
		battery,chg_polarity_full_check = <1>;

		battery,chg_high_temp = <470>;
		battery,chg_high_temp_recovery = <450>;
		battery,chg_input_limit_current = <1000>;
		battery,chg_charging_limit_current = <1900>;

		battery,dchg_high_temp = <520>;
		battery,dchg_high_temp_recovery = <460>;
		battery,dchg_high_batt_temp = <400>;
		battery,dchg_high_batt_temp_recovery = <380>;
		battery,dchg_input_limit_current = <1000>;
		battery,dchg_charging_limit_current = <2000>;

		battery,wpc_temp_control_source = <TEMP_CONTROL_SOURCE_BAT_THM>;
		battery,wpc_high_temp = <400>;
		battery,wpc_high_temp_recovery = <380>;
		battery,wpc_input_limit_current = <600>;
		battery,wpc_charging_limit_current = <1000>;
		battery,wpc_temp_lcd_on_control_source = <TEMP_CONTROL_SOURCE_BAT_THM>;
		battery,wpc_lcd_on_high_temp = <400>;
		battery,wpc_lcd_on_high_temp_rec = <380>;
		battery,wpc_lcd_on_input_limit_current = <600>;

		battery,wpc_store_high_temp = <360>;
		battery,wpc_store_high_temp_recovery = <340>;
		battery,wpc_store_charging_limit_current = <400>;
		battery,wpc_store_lcd_on_high_temp = <360>;
		battery,wpc_store_lcd_on_high_temp_rec = <300>;
		battery,wpc_store_lcd_on_charging_limit_current = <400>;

		battery,fcc_by_tx = <1200>;

		battery,sleep_mode_limit_current = <800>;
		battery,wc_full_input_limit_current = <100>;

		battery,ta_alert_wa;

		battery,mix_high_temp = <420>;
		battery,mix_high_chg_temp = <500>;
		battery,mix_high_temp_recovery = <390>;

		battery,full_condition_type = <(SEC_BATTERY_FULL_CONDITION_NOTIMEFULL | SEC_BATTERY_FULL_CONDITION_VCELL)>;
		battery,full_condition_soc = <93>;
		battery,full_condition_vcell = <4250>;

		battery,recharge_check_count = <1>;
		battery,recharge_condition_type = <SEC_BATTERY_RECHARGE_CONDITION_VCELL>;
		battery,recharge_condition_soc = <98>;
		battery,recharge_condition_vcell = <4280>;

		battery,charging_reset_time = <0>;

		battery,chg_float_voltage = <4350>;

		battery,pre_afc_work_delay = <2000>;
		battery,pre_wc_afc_work_delay = <4000>;
		battery,pre_afc_input_current = <500>;
		battery,pre_wc_afc_input_current = <500>;
		battery,prepare_ta_delay = <0>; /* msec */

		battery,swelling_high_rechg_voltage = <4000>;
		battery,swelling_low_rechg_voltage = <4000>;

		battery,siop_icl = <1200>;
		battery,siop_fcc = <1800>;
		battery,siop_hv_icl = <700>;
		battery,siop_hv_icl_2nd = <550>;
		battery,siop_hv_fcc = <1800>;
		battery,siop_apdo_icl = <1000>;
		battery,siop_apdo_fcc = <2000>;

		battery,siop_wpc_icl = <600>;
		battery,siop_wpc_fcc = <1000 500 100>; /* siop_level 70 10 0 */
		battery,siop_hv_wpc_icl = <700>;
		battery,siop_hv_wpc_fcc = <1000 500 100>; /* siop_level 70 10 0 */
		battery,siop_store_hv_wpc_icl = <450>;
		battery,store_mode_buckoff;

		/* trig, recov */
		battery,temp_table_LRP_45W = <385 365>;

		battery,rp_current_rp1 = <500>;
		battery,rp_current_rp2 = <1500>;
		battery,rp_current_rp3 = <3000>;
		battery,rp_current_rdu_rp3 = <2100>;
		battery,rp_current_abnormal_rp3 = <1800>;

		battery,pd_charging_charge_power = <15000>;
		battery,max_charging_current = <2350>;

		battery,store_mode_charging_max = <70>;
		battery,store_mode_charging_min = <60>;

		battery,wireless_cc_cv = <85>;
		battery,wireless_otg_input_current = <900>;

		/* cycle, chg_float_voltage, recharge_condition_vcell, full_condition_vcell, full_condition_soc, step charging condition */
		battery,age_data = <0 4350 4280 4250 93
			300 4330 4260 4230 92
			400 4310 4240 4210 91
			700 4290 4220 4190 90
			1000 4240 4170 4140 89>;

		battery,max_input_voltage = <9000>; /* mV */
		battery,max_input_current = <3000>;  /* mA */

		battery,cisd_alg_index = <8>;
		battery,cisd_max_voltage_thr = <4400>; /* batttery ovp dettection voltage */
		battery,ignore_cisd_index = <0 0>;
		battery,ignore_cisd_index_d = <0 80>; /* Do not use BUCK_OFF_PER_DAY, DROP_SENSOR_PER_DAY */

		battery,expired_time = <10800>;
		battery,recharging_expired_time = <5400>;

		battery,battery_full_capacity = <3300>;

		battery,ttf_capacity = <3500>;
		battery,cv_data = <
				3228	864	1534
				3133	866	1524
				3067	872	1493
				3019	874	1483
				2929	879	1452
				2896	881	1442
				2843	883	1431
				2792	885	1421
				2754	887	1411
				2695	892	1380
				2660	893	1370
				2625	895	1360
				2580	897	1349
				2531	898	1339
				2492	902	1319
				2450	903	1309
				2410	905	1298
				2348	908	1278
				2296	909	1268
				2263	910	1257
				2214	915	1227
				2182	916	1216
				2147	919	1196
				2103	920	1186
				2051	922	1175
				2019	924	1155
				1981	927	1134
				1948	928	1124
				1911	930	1104
				1879	932	1093
				1834	933	1083
				1795	935	1063
				1761	938	1032
				1722	942	1001
				1689	944	981
				1649	946	960
				1592	948	940
				1532	950	919
				1493	954	878
				1462	955	868
				1410	958	827
				1362	959	817
				1338	960	807
				1291	964	756
				1264	968	715
				1237	968	704
				1213	969	694
				1169	974	633
				1127	975	622
				1105	975	612
				1073	980	541
				1049	982	510
				1010	983	489
				993	984	479
				972	986	448
				955	988	407
				932	990	387
				881	990	377
				864	996	356
				761	1000	307
				710	1000	297
				688	1000	287
				668	1000	235
				658	1000	215
				647	1000	184
				635	1000	153
				622	1000	123
				610	1000	92
				596	1000	61
				583	1000	31
				571	1000	0
				>;

#if 1
		io-channels = <&auxadc 3>, <&auxadc 1>;
		io-channel-names = "adc-temp", "adc-chg-temp", "n/a", "n/a", "n/a";
#endif
	};

	/* sec_battery_cable
	 *   0	UNKNOWN,
	 *   1	NONE,
	 *   2	PREPARE_TA,
	 *   3	TA,
	 *   4	USB,
	 *   5	USB_CDP,
	 *   6	9V_TA,
	 *   7	9V_ERR,
	 *   8	9V_UNKNOWN,
	 *   9	12V_TA,
	 *  10	WIRELESS,
	 *  11	HV_WIRELESS,
	 *  12	PMA_WIRELESS,
	 *  13	WIRELESS_PACK,
	 *  14	CABLE_WIRELESS_HV_PACK,
	 *  15	WIRELESS_STAND,
	 *  16	WIRELESS_HV_STAND,
	 *  17	QC20,
	 *  18	QC30,
	 *  19	PDIC,
	 *  20	UARTOFF,
	 *  21	OTG,
	 *  22	LAN_HUB,
	 *  23	POWER_SHARING,
	 *  24	HMT_CONNECTED,
	 *  25	HMT_CHARGE,
	 *  26	HV_TA_CHG_LIMIT,
	 *  27	WIRELESS_VEHICLE,
	 *  28	WIRELESS_HV_VEHICLE,
	 *  29	PREPARE_WIRELESS_HV,
	 *  30  TIMEOUT,
	 *  31  SMART_OTG,
	 *  32  SMART_NOTG,
	 *  33  WIRELESS_TX,
	 *  34	HV_WIRELESS_20,
	 *  35	HV_WIRELESS_20_LIMIT,
	 *  36	WIRELESS_FAKE,
	 *  37  PREPARE_WIRELESS_20,
	 *  38	CABLE_PDIC_APDO,
	 *  39  CABLE_POGO,
	 *  40  CABLE_POGO_9V,
	 *  41	CABLE_MAX,
	 */
	sec_battery_cable: cable-info {
		default_input_current = <1800>;
		default_charging_current = <2100>;
		full_check_current_1st = <350>;
		full_check_current_2nd = <200>;

		current_group_1 {
			cable_number = <
				SEC_BATTERY_CABLE_PREPARE_TA
				SEC_BATTERY_CABLE_PDIC
				SEC_BATTERY_CABLE_OTG
				SEC_BATTERY_CABLE_LAN_HUB
				SEC_BATTERY_CABLE_POWER_SHARING>;
			input_current = <500>;
			charging_current = <500>;
		};
		current_group_2 {
			cable_number = <
				SEC_BATTERY_CABLE_HMT_CHARGE
				SEC_BATTERY_CABLE_SMART_OTG>;
			input_current = <1000>;
			charging_current = <1000>;
		};
		current_group_3 {
			cable_number = <
				SEC_BATTERY_CABLE_USB_CDP
				SEC_BATTERY_CABLE_SMART_NOTG>;
			input_current = <1500>;
			charging_current = <1500>;
		};
		current_group_4 {
			cable_number = <SEC_BATTERY_CABLE_9V_TA SEC_BATTERY_CABLE_9V_ERR
				SEC_BATTERY_CABLE_9V_UNKNOWN SEC_BATTERY_CABLE_QC20 SEC_BATTERY_CABLE_QC30>;
			input_current = <1650>;
			charging_current = <2350>;
		};
		current_group_5 {
			cable_number = <SEC_BATTERY_CABLE_12V_TA>;
			input_current = <1650>;
			charging_current = <2350>;
		};
		current_group_6 {
			cable_number = <
				SEC_BATTERY_CABLE_WIRELESS
				SEC_BATTERY_CABLE_PMA_WIRELESS
				SEC_BATTERY_CABLE_WIRELESS_STAND
				SEC_BATTERY_CABLE_WIRELESS_VEHICLE
				SEC_BATTERY_CABLE_WIRELESS_FAKE>;
			input_current = <800>;
			charging_current = <2350>;
		};
		current_group_7 {
			cable_number = <SEC_BATTERY_CABLE_WIRELESS_PACK>;
			input_current = <700>;
			charging_current = <2350>;
		};
		current_group_8 {
			cable_number = <SEC_BATTERY_CABLE_HMT_CONNECTED>;
			input_current = <1000>;
			charging_current = <450>;
		};
		current_group_9 {
			cable_number = <SEC_BATTERY_CABLE_HV_TA_CHG_LIMIT>;
			input_current = <1800>;
			charging_current = <1800>;
		};
		current_group_10 {
			cable_number = <
				SEC_BATTERY_CABLE_HV_WIRELESS
				SEC_BATTERY_CABLE_WIRELESS_HV_PACK
				SEC_BATTERY_CABLE_WIRELESS_HV_STAND
				SEC_BATTERY_CABLE_WIRELESS_HV_VEHICLE
				SEC_BATTERY_CABLE_HV_WIRELESS_20_LIMIT>;
			input_current = <650>;
			charging_current = <2350>;
		};
		current_group_11 {
			cable_number = <
				SEC_BATTERY_CABLE_PREPARE_WIRELESS_HV
				SEC_BATTERY_CABLE_PREPARE_WIRELESS_20>;
			input_current = <500>;
			charging_current = <1200>;
		};
		current_group_12 {
			cable_number = <
				SEC_BATTERY_CABLE_NONE
				SEC_BATTERY_CABLE_USB
				SEC_BATTERY_CABLE_TIMEOUT>;
			input_current = <475>;
			charging_current = <550>;
		};
		current_group_13 {
			cable_number = <SEC_BATTERY_CABLE_HV_WIRELESS_20>;
			input_current = <1200>;
			charging_current = <2350>;
		};
		current_group_14 {
			cable_number = <SEC_BATTERY_CABLE_WIRELESS_TX>;
			input_current = <800>;
			charging_current = <2350>;
		};
	};
	sec_battery_wireless_power_info: wireless-power-info {
		count = <5>;
		current_group_0 {
			wireless_power_class = <2>;
			vout = <9000>;
			input_current_limit = <825>;
			fast_charging_current = <3150>;
			ttf_charge_current = <1500>;
			rx_power = <7500>;
		};
		current_group_1 {
			wireless_power_class = <2>;
			vout = <10000>;
			input_current_limit = <750>;
			fast_charging_current = <3150>;
			ttf_charge_current = <1500>;
			rx_power = <7500>;
		};
		current_group_2 {
			wireless_power_class = <2>;
			vout = <9000>;
			input_current_limit = <1200>;
			fast_charging_current = <3150>;
			ttf_charge_current = <2175>;
			rx_power = <12000>;
		};
		current_group_3 {
			wireless_power_class = <2>;
			vout = <11000>;
			input_current_limit = <1100>;
			fast_charging_current = <3150>;
			ttf_charge_current = <2100>;
			rx_power = <12000>;
		};
		current_group_4 {
			wireless_power_class = <2>;
			vout = <11000>;
			input_current_limit = <1300>;
			fast_charging_current = <3150>;
			ttf_charge_current = <2300>;
			rx_power = <15000>;
		};
	};
};

/* /home/dpi/qb5_8815/workspace/P4_1716/android/kernel/kmodule/battery/suwon/common/dts/a13ve/battery_common.dtsi */
#include <dt-bindings/battery/sec-battery.h>

#define MAX_FV 4350
#define MAX_FCC 2300

&sec_battery {
		pinctrl-names = "default";

		battery,batt_data_version = <1>;
		battery,chip_vendor = "MTK";

		battery,temp_check_type = <SEC_BATTERY_TEMP_CHECK_TEMP>;
		battery,chg_temp_check_type = <SEC_BATTERY_TEMP_CHECK_TEMP>;

		battery,thermal_source = <SEC_BATTERY_THERMAL_SOURCE_ADC>;
		battery,chg_thermal_source = <SEC_BATTERY_THERMAL_SOURCE_ADC>;

		battery,temp_table_adc = <
					113 133 160 180 205 230 268 324 391 470
					565 685 828 1000 1201 1434 1691 1977 2296 2623
					2950 3268 3583
					>;
		battery,temp_table_data = <
					900 850 800 750 700 650 600 550 500 450
					400 350 300 250 200 150 100 50 0 (-50)
					(-100) (-150) (-200)
					>;

		battery,chg_temp_table_adc = <
					81 95 116 142 171 200 244 299 359 434
					526 634 770 934 1125 1346 1590 1865 2179 2465
					2827 3148 3481
					>;
		battery,chg_temp_table_data = <
					900 850 800 750 700 650 600 550 500 450
					400 350 300 250 200 150 100 50 0 (-50)
					(-100) (-150) (-200)
					>;

		battery,temp_check_count = <1>;

		battery,wire_cool1_normal_thresh = <150>;

		battery,wire_warm_current = <1313>;
		battery,wire_cool1_current = <MAX_FCC>;
		battery,wire_cool2_current = <875>;
		battery,wire_cool3_current = <454>;

		battery,chg_high_temp = <540>;
		battery,chg_high_temp_recovery = <520>;
		battery,chg_charging_limit_current = <1700>;

		battery,mix_high_temp = <420>;
		battery,mix_high_chg_temp = <500>;
		battery,mix_high_temp_recovery = <390>;

		battery,full_check_type = <SEC_BATTERY_FULLCHARGED_FG_CURRENT>;
		battery,full_check_type_2nd = <SEC_BATTERY_FULLCHARGED_FG_CURRENT>;

		battery,full_condition_vcell = <4250>;
		battery,recharge_condition_vcell = <4280>;

		battery,chg_ocp_current = <9000>;
		battery,chg_float_voltage = <MAX_FV>;
		battery,high_temp_float = <4150>;
		battery,low_temp_float = <MAX_FV>;

		battery,swelling_high_rechg_voltage = <4000>;
		battery,swelling_low_rechg_voltage = <4200>;

		battery,max_charging_current = <MAX_FCC>;
		battery,max_charging_charge_power = <15000>; /* 15W */

		/* cycle, chg_float_voltage, recharge_condition_vcell, full_condition_vcell, full_condition_soc */
		battery,age_data = <0 MAX_FV 4280 4300 93
			300 4330 4260 4280 92
			400 4310 4240 4260 91
			700 4290 4220 4240 90
			1000 4240 4170 4190 89>;

		battery,health_condition = <
			/* CYCLE ASOC */
			900 0  /* GOOD */
			1200 0 /* NORMAL */
			1500 0 /* AGED */
			>;

		battery,siop_scenarios = <20 0>;
		battery,siop_curr_type_num = <3>;
		/* nv, hv, fpdo */
		battery,siop_icl_20 = <1000 SIOP_DEFAULT 1000>; /* 5W SIOP_DEFAULT 5W */
		battery,siop_fcc_20 = <SIOP_DEFAULT SIOP_DEFAULT SIOP_DEFAULT>;
		battery,siop_icl_0 = <1000 SIOP_DEFAULT 1000>; /* 5W SIOP_DEFAULT 5W */
		battery,siop_fcc_0 = <SIOP_DEFAULT SIOP_DEFAULT SIOP_DEFAULT>;

		battery,standard_curr = <MAX_FCC>;
		battery,expired_time = <13800>; /* 160 + 70 minutes */
		battery,recharging_expired_time = <5400>;
		battery,battery_full_capacity = <5000>;
		battery,cisd_max_voltage_thr = <5000>; /* batttery ovp dettection voltage */

		battery,ttf_hv_charge_current = <2040>;
		battery,ttf_capacity = <4420>;
		battery,cv_data = <
			3390 809 1815
			3367 821 1755
			3293 833 1695
			3004 845 1634
			2868 855 1574
			2754 865 1514
			2534 875 1453
			2442 884 1393
			2284 892 1333
			2144 900 1272
			2023 907 1212
			1877 914 1152
			1790 920 1091
			1698 927 1031
			1574 932 970
			1560 938 910
			1483 942 850
			1477 948 790
			1391 953 729
			1384 958 669
			1327 963 609
			1261 967 549
			1195 971 489
			1141 976 428
			1082 979 368
			1040 983 301
			972 987 241
			931 990 180
			887 993 120
			859 997 60
			816 1000 0
		>;
};

&sec_battery_cable {
		default_charging_current = <2125>;
		full_check_current_1st = <500>;
		full_check_current_2nd = <250>;

		current_group_4 {
			charging_current = <MAX_FCC>;
		};
		current_group_5 {
			charging_current = <MAX_FCC>;
		};
};

/* #include "../i2c-gpio-1.dtsi" */                  /* From i2c-gpio.py */
&pio {
       gpio_i2c_1_sda {
               gpio_i2c_1_sda_default: gpio_i2c_1_sda_default {
                       GPIO_CONFIG_PUD_DRV(AP,pio,98, FUNC_INPUT, PULL_NONE, DRV_LV1);
               };
       };
};

&pio {
       gpio_i2c_1_scl {
               gpio_i2c_1_scl_default: gpio_i2c_1_scl_default {
                       GPIO_CONFIG_PUD_DRV(AP,pio,6, FUNC_INPUT, PULL_NONE, DRV_LV1);
               };
       };
};

/ {
	fragment@model {
		target-path = "/";
	        __overlay__ {
			aliases {
				  i2c31 = "/i2c@31";
			};
			/* Software I2C */
			sw_i2c1: i2c@31 {
				cell-index = <31>;
				compatible = "i2c-gpio";
				gpios = <
					SEC_GPIO_REF(AP,pio,98) 0 /* SDA */
					SEC_GPIO_REF(AP,pio,6) 0 /* SCL */
					>;
				#i2c-gpio,delay-us = <2>;
				#address-cells = <1>;
				#size-cells = <0>;

				pinctrl-names = "default";
				pinctrl-0 = <
					&gpio_i2c_1_sda_default
					&gpio_i2c_1_scl_default
					>;

				status = "disabled";
			};
		};
	};
};


/* #include "../i2c-gpio.dtsi" */                    /* From i2c-gpio.py */
&pio {
       gpio_i2c_0_sda {
               gpio_i2c_0_sda_default: gpio_i2c_0_sda_default {
                       GPIO_CONFIG_PUD_DRV(AP,pio,80, FUNC_INPUT, PULL_NONE, DRV_LV1);
               };
       };
};

&pio {
       gpio_i2c_0_scl {
               gpio_i2c_0_scl_default: gpio_i2c_0_scl_default {
                       GPIO_CONFIG_PUD_DRV(AP,pio,79, FUNC_INPUT, PULL_NONE, DRV_LV1);
               };
       };
};

/ {
	fragment@model {
		target-path = "/";
	        __overlay__ {
			aliases {
				  i2c30 = "/i2c@30";
			};
			/* Software I2C */
			sw_i2c0: i2c@30 {
				cell-index = <30>;
				compatible = "i2c-gpio";
				gpios = <
					SEC_GPIO_REF(AP,pio,80) 0 /* SDA */
					SEC_GPIO_REF(AP,pio,79) 0 /* SCL */
					>;
				#i2c-gpio,delay-us = <2>;
				#address-cells = <1>;
				#size-cells = <0>;

				pinctrl-names = "default";
				pinctrl-0 = <
					&gpio_i2c_0_sda_default
					&gpio_i2c_0_scl_default
					>;

				status = "disabled";
			};
		};
	};
};


/* #include "../sm5714.dtsi" */                      /* From sm5714.py */
&pio {
	if_pmic_irq: if_pmic_irq {
		pins_cmd_dat {
			pinmux = <MTK_PINMUX(SEC_GPIO_NUM(AP,pio,7), 0)>;
			slew-rate = <1>;
			bias-disable;
		};
	};
	usbpd_irq: usbpd_irq {
		pins_cmd_dat {
			pinmux = <MTK_PINMUX(SEC_GPIO_NUM(AP,pio,0), 0)>;
			slew-rate = <1>;
			bias-disable;
		};
	};
#if 0
	usbpd_vbus_discharging: usbpd_vbus_discharging {
		pins_cmd_dat {
			pinmux = <MTK_PINMUX(SEC_GPIO_NUM(${usbpd_vbus_discharging_gpio}), 0)>;
			slew-rate = <1>;
			bias-disable;
		};
	};
#endif
};

&i2c3 {
	#address-cells = <1>;
	#size-cells = <0>;
	status = "okay";
	samsung,i2c-max-bus-freq = <400000>;
	sm5714@49{
		status = "okay";
		compatible = "siliconmitus,sm5714mfd";
		reg = <0x49>;
		pinctrl-names = "default";
		pinctrl-0 = <&if_pmic_irq>;
		sm5714,irq-gpio = <SEC_GPIO_REF(AP,pio,7) 0>;
		sm5714,wakeup;
	};
};

&i2c0 {
	i2c-gpio,delay-us = <5>;
	#address-cells = <1>;
	#size-cells = <0>;
	status = "okay";
	samsung,i2c-max-bus-freq = <400000>;

	usbpd-sm5714@33 {
		status = "okay";
		compatible = "sm5714-usbpd";
		reg = <0x33>;
		pinctrl-names = "default";
		pinctrl-0 = <&usbpd_irq
#if 0
				&usbpd_vbus_discharging
#endif
		>;
		usbpd,usbpd_int = <SEC_GPIO_REF(AP,pio,0) 0>;
#if 0
		usbpd,vbus_discharging = <SEC_GPIO_REF(${usbpd_vbus_discharging_gpio}) 0>;
#endif
		support_pd_role_swap;
		pdic-manager {
			/* sink */
			pdic,max_power = <5000>;
			pdic_op_power = <2500>;
			pdic_max_voltage = <6000>;
			pdic_max_current = <2000>;
			pdic,min_current = <500>;

			pdic,giveback = <0>;
			pdic,usb_com_capable = <1>;
			pdic,no_usb_suspend = <1>;

			/* source */
			source,max_voltage = <5000>;
			source,min_voltage = <4000>;
			source,max_power = <2500>;
		};
	};
};


/* /home/dpi/qb5_8815/workspace/P4_1716/android/kernel/kmodule/mfd/sm/sm5714/sm5714_mtk.a13ve.dtsi */
&pio {
	if_pmic_scl: if_pmic_scl {
		pins_cmd_dat {
			pins = <PINMUX_GPIO50__FUNC_GPIO50>;
			bias-pull-up;
		};
	};
	if_pmic_sda: if_pmic_sda {
		pins_cmd_dat {
			pins = <PINMUX_GPIO51__FUNC_GPIO51>;
			bias-pull-up;
		};
	};
	cc_sda: cc_sda {
		pins_cmd_dat {
			pins = <PINMUX_GPIO82__FUNC_GPIO82>;
			bias-pull-up;
		};
	};
	cc_scl: cc_scl {
		pins_cmd_dat {
			pins = <PINMUX_GPIO83__FUNC_GPIO83>;
			bias-pull-up;
		};
	};
};

&i2c3 {
	ch_offset_default = <0x100>;
	ch_offset_ccu = <0x200>;
};


/* #include "../fingerprint_et5xx.dtsi" */           /* From fingerprint_et5xx.py */
/*
 * Copyright (c) 2012-2013, The Linux Foundation. All rights reserved.
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 and
 * only version 2 as published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 */

/* drive-strength */
&pio {
	btp_irq: btp-irq {
		pins_cmd_dat{
			pinmux = <MTK_PINMUX(SEC_GPIO_NUM(AP,pio,58), 0)>;
			bias-disable;
			drive-strength = <1>;
		};
	};
	btp_irq_sleep: btp-irq-sleep {
		pins_cmd_dat{
			pinmux = <MTK_PINMUX(SEC_GPIO_NUM(AP,pio,58), 0)>;
			bias-pull-down;
			input-enable;
			drive-strength = <1>;
		};
	};
};
#if 1
&pio {
	btp_ldo_en: btp_ldo_enable {
		pins_cmd_dat{
			pinmux = <MTK_PINMUX(SEC_GPIO_NUM(AP,pio,77), 0)>;
			bias-pull-down;
			drive-strength = <1>;
		};
	};
};
#endif

&pio {
	btp_sleep: btp_sleep_enable {
		pins_cmd_dat{
			pinmux = <MTK_PINMUX(SEC_GPIO_NUM(AP,pio,53), 0)>;
			bias-pull-down;
			drive-strength = <1>;
		};
	};
};

&pio {
	spi1_set_miso: set_miso {
		pins_cmd_dat{
			pinmux = <MTK_PINMUX(SEC_GPIO_NUM(AP,pio,85), 1)>;
			drive-strength = <4>;
		};
	};
	spi1_set_cs: set_cs {
		pins_cmd_dat{
			pinmux = <MTK_PINMUX(SEC_GPIO_NUM(AP,pio,86), 1)>;
			drive-strength = <4>;
		};
	};
	spi1_set_mosi: set_mosi {
		pins_cmd_dat{
			pinmux = <MTK_PINMUX(SEC_GPIO_NUM(AP,pio,87), 1)>;
			drive-strength = <4>;
		};
	};
	spi1_set_clk: set_clk {
		pins_cmd_dat{
			pinmux = <MTK_PINMUX(SEC_GPIO_NUM(AP,pio,88), 1)>;
			drive-strength = <4>;
		};
	};
	spi1_clr_miso: clr_miso {
		pins_cmd_dat{
			pinmux = <MTK_PINMUX(SEC_GPIO_NUM(AP,pio,85), 0)>;
			slew-rate = <0>;
			bias-pull-down;
			input-enable;
			drive-strength = <1>;
		};
	};
	spi1_clr_cs: clr_cs {
		pins_cmd_dat{
			pinmux = <MTK_PINMUX(SEC_GPIO_NUM(AP,pio,86), 0)>;
			slew-rate = <0>;
			bias-pull-down;
			output-low;
			drive-strength = <1>;
		};
	};
	spi1_clr_mosi: clr_mosi {
		pins_cmd_dat{
			pinmux = <MTK_PINMUX(SEC_GPIO_NUM(AP,pio,87), 0)>;
			slew-rate = <0>;
			bias-pull-down;
			output-low;
			drive-strength = <1>;
		};
	};
	spi1_clr_clk: clr_clk {
		pins_cmd_dat{
			pinmux = <MTK_PINMUX(SEC_GPIO_NUM(AP,pio,88), 0)>;
			slew-rate = <0>;
			bias-pull-down;
			output-low;
			drive-strength = <1>;
		};
	};
};
#if 0
&${fps_regul_vdd_3p3} {
    regulator-name = "VDD_BTP_3P3";
    regulator-min-microvolt = <3300000>;
    regulator-max-microvolt = <3300000>;
};
#endif
#if defined(CONFIG_SEC_FACTORY) || !1
&spi1 {
	status = "okay";
#else
&smd {
#endif
	#address-cells = <1>;
	#size-cells = <0>;

	etspi-spi@0 {
		compatible = "etspi,et5xx";
		reg = <0x00>;
		spi-max-frequency = <25000000>;
#if !defined(CONFIG_SEC_FACTORY) && 1
		clocks = <&topckgen_clk CLK_TOP_SYSPLL3_D2>,
			<&topckgen_clk CLK_TOP_SPI_SEL>,
			<&infracfg_ao_clk CLK_IFR_SPI1>;
		clock-names = "parent-clk", "sel-clk", "spi-clk";
#endif
		pinctrl-names = "default", "pins_poweron", "pins_poweroff", "pins_poweron_tz", "pins_poweroff_tz";
#if 1
		pinctrl-0 = <&btp_sleep &btp_irq &btp_ldo_en>;
#else
		pinctrl-0 = <&btp_sleep &btp_irq>;
#endif
		pinctrl-1 = <&spi1_set_miso &spi1_set_cs &spi1_set_mosi &spi1_set_clk>;
		pinctrl-2 = <&btp_sleep &spi1_clr_miso &spi1_clr_cs &spi1_clr_mosi &spi1_clr_clk>;
		pinctrl-3 = <&btp_irq>;
		pinctrl-4 = <&btp_irq_sleep>;
		gpio-controller;
		#gpio-cells = <2>;
#if 1
		etspi-ldoPin = <SEC_GPIO_REF(AP,pio,77) 0>;
#endif
#if 0
		etspi-regulator = "VDD_BTP_3P3";
#endif
		etspi-sleepPin = <SEC_GPIO_REF(AP,pio,53) 0>;
		etspi-drdyPin = <SEC_GPIO_REF(AP,pio,58) 0>;
		etspi-chipid = "ET528";
		etspi-orient = <3>;
		controller-data {
			mediatek,tckdly = <1>;	/* It'll be used after tckdly patch */
		};
	};
};

/* #include "../input_nt36523_spi.dtsi" */           /* From input_nt36523_spi.py */
/* NEED TO FIX IF YOU WANT USE THIS */

&pio {
	nt36523_tsp_intr_on: nt36523_tsp_intr_on {
		pins_cmd_dat {
			pinmux = <MTK_PINMUX(SEC_GPIO_NUM(AP,pio,10), 0)>;
			slew-rate = <0>;
			bias-disable;
		};
	};

	nt36523_tsp_intr_off: nt36523_tsp_intr_off {
		pins_cmd_dat {
			pinmux = <MTK_PINMUX(SEC_GPIO_NUM(AP,pio,10), 0)>;
			slew-rate = <0>;
			input-enable;
			bias-pull-down;
		};
	};
};
&pio {
	nt36523_tsp_reset_on: nt36523_tsp_reset_on {
		pins_cmd_dat{
			pinmux = <MTK_PINMUX(SEC_GPIO_NUM(AP,pio,4), 0)>;
			slew-rate = <1>;
			bias-disable;
			output-high;
		};
	};

	nt36523_tsp_reset_off: nt36523_tsp_reset_off {
		pins_cmd_dat{
			pinmux = <MTK_PINMUX(SEC_GPIO_NUM(AP,pio,4), 0)>;
			slew-rate = <1>;
			bias-disable;
			output-low;
		};
	};
};
&pio {
	nt36523_tsp_on_cs: nt36523_tsp_on_cs {
		pins_cmd_dat{
			pinmux = <MTK_PINMUX(SEC_GPIO_NUM(AP,pio,18), 1)>;
			bias-disable;
		};
	};
	nt36523_tsp_off_cs: nt36523_tsp_off_cs {
		pins_cmd_dat{
			pinmux = <MTK_PINMUX(SEC_GPIO_NUM(AP,pio,18), 0)>;
			slew-rate = <1>;
			bias-disable;
			output-low;
		};
	};
};
&pio {
	nt36523_tsp_on_clk: nt36523_tsp_on_clk {
		pins_cmd_dat{
			pinmux = <MTK_PINMUX(SEC_GPIO_NUM(AP,pio,20), 1)>;
			bias-disable;
		};
	};
	nt36523_tsp_off_clk: nt36523_tsp_off_clk {
		pins_cmd_dat{
			pinmux = <MTK_PINMUX(SEC_GPIO_NUM(AP,pio,20), 0)>;
			slew-rate = <1>;
			bias-disable;
			output-low;
		};
	};

	nt36523_tsp_on_mosi: nt36523_tsp_on_mosi {
		pins_cmd_dat{
			pinmux = <MTK_PINMUX(SEC_GPIO_NUM(AP,pio,19), 1)>;
			bias-disable;
		};
	};
	nt36523_tsp_off_mosi: nt36523_tsp_off_mosi {
		pins_cmd_dat{
			pinmux = <MTK_PINMUX(SEC_GPIO_NUM(AP,pio,19), 0)>;
			slew-rate = <1>;
			bias-disable;
			output-low;
		};
	};

	nt36523_tsp_on_miso: nt36523_tsp_on_miso {
		pins_cmd_dat{
			pinmux = <MTK_PINMUX(SEC_GPIO_NUM(AP,pio,17), 1)>;
			bias-disable;
		};
	};

	nt36523_tsp_off_miso: nt36523_tsp_off_miso {
		pins_cmd_dat{
			pinmux = <MTK_PINMUX(SEC_GPIO_NUM(AP,pio,17), 0)>;
			slew-rate = <0>;
			bias-pull-down;
			input-enable;
		};
	};

	nt36523_default_miso: nt36523_default_miso {
		pins_cmd_dat{
			pinmux = <MTK_PINMUX(SEC_GPIO_NUM(AP,pio,17), 0)>;
			slew-rate = <0>;
			bias-disable;
			output-low;
		};
	};
};

&spi4 {
	status = "okay";
	#address-cells = <1>;
	#size-cells = <0>;
	num-cs = <1>;
	tsp_novatek: novatek@0 {
		status = "okay";
		compatible = "novatek,NVT-ts-spi";
		reg = <0>; //Same as CS ID
		spi-max-frequency = <9600000>;

		pinctrl-names = "default", "on_state", "off_state";
		pinctrl-0 = <&nt36523_tsp_intr_on &nt36523_tsp_reset_on &nt36523_tsp_on_cs &nt36523_tsp_on_clk &nt36523_tsp_on_mosi &nt36523_tsp_on_miso>;
		pinctrl-1 = <&nt36523_tsp_intr_on &nt36523_tsp_reset_on &nt36523_tsp_on_cs &nt36523_tsp_on_clk &nt36523_tsp_on_mosi &nt36523_tsp_on_miso>;
		pinctrl-2 = <&nt36523_tsp_intr_off &nt36523_tsp_reset_off &nt36523_tsp_off_cs &nt36523_tsp_off_clk &nt36523_tsp_off_mosi &nt36523_tsp_off_miso>;

		novatek,reset-gpio = <SEC_GPIO_REF(AP,pio,4) 0x00>;
		novatek,irq-gpio = <SEC_GPIO_REF(AP,pio,10) 0x2002>;

		novatek,enable_sysinput_enabled;
	};
};
/* /home/dpi/qb5_8815/workspace/P4_1716/android/kernel/kmodule/input/touchscreen/novatek/nt36523_spi/dts/input-mtk-tsp-nt36523-spi.a13ve.dtsi */
&nt36523_tsp_on_cs {
	pins_cmd_dat{
		pinmux = <MTK_PINMUX(SEC_GPIO_NUM(AP,pio,18), 2)>;
		bias-disable;
	};
};

&nt36523_tsp_on_clk {
	pins_cmd_dat{
		pinmux = <MTK_PINMUX(SEC_GPIO_NUM(AP,pio,20), 2)>;
		bias-disable;
	};
};

&nt36523_tsp_on_mosi {
	pins_cmd_dat{
		pinmux = <MTK_PINMUX(SEC_GPIO_NUM(AP,pio,19), 2)>;
		bias-disable;
	};
};

&nt36523_tsp_on_miso {
	pins_cmd_dat{
		pinmux = <MTK_PINMUX(SEC_GPIO_NUM(AP,pio,17), 2)>;
		bias-disable;
	};
};

&pio {
	nt36523_tsp_id1_default: nt36523_tsp_id1_default {
		pins_cmd_dat {
			pinmux = <PINMUX_GPIO165__FUNC_GPIO165>;
			slew-rate = <0>;
			input-enable;
			bias-disable;
		};
	};

	nt36523_tsp_id2_default: nt36523_tsp_id2_default {
		pins_cmd_dat {
			pinmux = <PINMUX_GPIO153__FUNC_GPIO153>;
			slew-rate = <0>;
			input-enable;
			bias-disable;
		};
	};

	nt36523_tsp_id3_default: nt36523_tsp_id3_default {
		pins_cmd_dat {
			pinmux = <PINMUX_GPIO150__FUNC_GPIO150>;
			slew-rate = <0>;
			input-enable;
			bias-disable;
		};
	};
};

&spi4 {
	num-cs = <2>;
};

&tsp_novatek{
	pinctrl-names = "default", "on_state", "off_state";
	pinctrl-0 = <&nt36523_tsp_intr_on &nt36523_tsp_reset_on &nt36523_tsp_off_cs &nt36523_tsp_off_clk &nt36523_tsp_off_mosi &nt36523_default_miso &nt36523_tsp_id1_default &nt36523_tsp_id2_default &nt36523_tsp_id3_default>;
	pinctrl-1 = <&nt36523_tsp_intr_on &nt36523_tsp_reset_on &nt36523_tsp_on_cs &nt36523_tsp_on_clk &nt36523_tsp_on_mosi &nt36523_tsp_on_miso &nt36523_tsp_id1_default &nt36523_tsp_id2_default &nt36523_tsp_id3_default>;
	pinctrl-2 = <&nt36523_tsp_intr_off &nt36523_tsp_reset_off &nt36523_tsp_off_cs &nt36523_tsp_off_clk &nt36523_tsp_off_mosi &nt36523_tsp_off_miso &nt36523_tsp_id1_default &nt36523_tsp_id2_default &nt36523_tsp_id3_default>;

	novatek,resolution = <1080 2408>;
	novatek,enable_settings_aot;
	novatek,support_ear_detect_mode;
	novatek,prox_lp_scan_enabled;

	novatek,lcdid1-gpio = <&pio 165 0x0>;
	novatek,lcdid2-gpio = <&pio 153 0x0>;
	novatek,lcdid3-gpio = <&pio 150 0x0>;
	novatek,lcdid = <0>;	// CSOT
	novatek,lcdtype = <0x4bf240>;
	novatek,fw_name = "tsp_novatek/nt36672_a13ve_csot.bin";
	novatek,fw_name_mp = "tsp_novatek/nt36672_a13ve_csot_mp.bin";

	novatek,name_lcd_rst = "lcd_rst";
	novatek,name_lcd_vddi = "lcd_vddi";
	novatek,name_lcd_bl_en = "lcd_bl_en";
	novatek,name_lcd_vsp = "lcd_vsp";
	novatek,name_lcd_vsn = "lcd_vsn";

	/* 672A, 525B, 675, 526, 672C */
	novatek,swrst-n8-addr = <0x03F0FE>;
	novatek,spi-rd-fast-addr = <0x03F310>;

	/* MP */
	novatek,mp-support-dt;

	/* nt36672_a13ve_csot.bin */
	novatek-mp-criteria-723B@0 {
		#address-cells = <1>;
		#size-cells = <0>;
		compatible = "novatek-mp-criteria-723B";

		/* sec cmd test config */
		open_test_spec = <(-511) 5120>;
		short_test_spec = <10000 14008>;
		diff_test_frame = <50>;
		fdm_x_num = <2>;
	};

	/* nt36672_a13ve_tianma.bin */
	novatek-mp-criteria-7241@0 {
		#address-cells = <1>;
		#size-cells = <0>;
		compatible = "novatek-mp-criteria-7241";

		/* sec cmd test config */
		open_test_spec = <(-511) 5120>;
		short_test_spec = <10000 14008>;
		diff_test_frame = <50>;
		fdm_x_num = <2>;
	};
};

/* #include "../sec_thermistor.dtsi" */              /* From sec_thermistor.py */
/ {
	fragment@smd {
		target-path = "/";
		__overlay__ {
			samsung_mobile_device {
				sec_ap_thermistor: sec_thermistor@0 {
					compatible = "samsung,sec-thermistor";
					status = "okay";
					thermistor_name = "sec-ap-thermistor";
					id = <0>;

					io-channels = SEC_ADC(auxadc,4);
					io-channel-names = "ap_therm";
					io-channel-ranges;
				};
			};
		};
	};
};

/* #include "../sec_thermistor-1.dtsi" */            /* From sec_thermistor.py */
/ {
	fragment@smd {
		target-path = "/";
		__overlay__ {
			samsung_mobile_device {
				sec_pa_thermistor: sec_thermistor@1 {
					compatible = "samsung,sec-thermistor";
					status = "okay";
					thermistor_name = "sec-pa-thermistor";
					id = <1>;

					io-channels = SEC_ADC(auxadc,0);
					io-channel-names = "pa_therm";
					io-channel-ranges;
				};
			};
		};
	};
};

/* /home/dpi/qb5_8815/workspace/P4_1716/android/kernel/kmodule/hwmon/sec_thermistor/sec_thermistor_mtk.a13ve.dtsi */
&sec_ap_thermistor {
	use_iio_processed;
	adc_array = <76 91 111 136 163 192 234 288 345
				416 497 596 744 889 1074 1306 1529 1769 2107
				2359 2753 3060 3428>;
	temp_array = <900 850 800 750 700 650 600 550 500
				450 400 350 300 250 200 150 100 50 0
				(-50) (-100) (-150) (-200)>;
};

&sec_pa_thermistor {
	use_iio_processed;
	adc_array = <85 101 120 144 173 203 247 301 361
				433 520 629 765 928 1116 1335 1573 1845 2160
				2431 2807 3126 3464>;

	temp_array = <900 850 800 750 700 650 600 550 500
				450 400 350 300 250 200 150 100 50 0
				(-50) (-100) (-150) (-200)>;
};

/* #include "../input_hx83xxx_spi.dtsi" */           /* From input_hx83xxx_spi.py */
/* NEED TO FIX IF YOU WANT USE THIS */

&pio {
	himax_tsp_intr_on: himax_tsp_intr_on {
		pins_cmd_dat {
			pinmux = <MTK_PINMUX(SEC_GPIO_NUM(AP,pio,10), 0)>;
			slew-rate = <0>;
			bias-disable;
		};
	};

	himax_tsp_intr_off: himax_tsp_intr_off {
		pins_cmd_dat {
			pinmux = <MTK_PINMUX(SEC_GPIO_NUM(AP,pio,10), 0)>;
			slew-rate = <0>;
			input-enable;
			bias-pull-down;
		};
	};
};
&pio {
	himax_tsp_reset_on: himax_tsp_reset_on {
		pins_cmd_dat{
			pinmux = <MTK_PINMUX(SEC_GPIO_NUM(AP,pio,4), 0)>;
			slew-rate = <1>;
			bias-disable;
			output-high;
		};
	};

	himax_tsp_reset_off: himax_tsp_reset_off {
		pins_cmd_dat{
			pinmux = <MTK_PINMUX(SEC_GPIO_NUM(AP,pio,4), 0)>;
			slew-rate = <1>;
			bias-disable;
			output-low;
		};
	};
};
&pio {
	himax_tsp_on_cs: himax_tsp_on_cs {
		pins_cmd_dat{
			pinmux = <MTK_PINMUX(SEC_GPIO_NUM(AP,pio,18), 1)>;
			bias-disable;
		};
	};
	himax_tsp_off_cs: himax_tsp_off_cs {
		pins_cmd_dat{
			pinmux = <MTK_PINMUX(SEC_GPIO_NUM(AP,pio,18), 0)>;
			slew-rate = <1>;
			bias-disable;
			output-low;
		};
	};
};
&pio {
	himax_tsp_on_clk: himax_tsp_on_clk {
		pins_cmd_dat{
			pinmux = <MTK_PINMUX(SEC_GPIO_NUM(AP,pio,20), 1)>;
			bias-disable;
		};
	};
	himax_tsp_off_clk: himax_tsp_off_clk {
		pins_cmd_dat{
			pinmux = <MTK_PINMUX(SEC_GPIO_NUM(AP,pio,20), 0)>;
			slew-rate = <1>;
			bias-disable;
			output-low;
		};
	};

	himax_tsp_on_mosi: himax_tsp_on_mosi {
		pins_cmd_dat{
			pinmux = <MTK_PINMUX(SEC_GPIO_NUM(AP,pio,19), 1)>;
			bias-disable;
		};
	};
	himax_tsp_off_mosi: himax_tsp_off_mosi {
		pins_cmd_dat{
			pinmux = <MTK_PINMUX(SEC_GPIO_NUM(AP,pio,19), 0)>;
			slew-rate = <1>;
			bias-disable;
			output-low;
		};
	};

	himax_tsp_on_miso: himax_tsp_on_miso {
		pins_cmd_dat{
			pinmux = <MTK_PINMUX(SEC_GPIO_NUM(AP,pio,17), 1)>;
			bias-disable;
		};
	};

	himax_tsp_off_miso: himax_tsp_off_miso {
		pins_cmd_dat{
			pinmux = <MTK_PINMUX(SEC_GPIO_NUM(AP,pio,17), 0)>;
			slew-rate = <0>;
			bias-pull-down;
			input-enable;
		};
	};

	himax_default_miso: himax_default_miso {
		pins_cmd_dat{
			pinmux = <MTK_PINMUX(SEC_GPIO_NUM(AP,pio,17), 0)>;
			slew-rate = <0>;
			bias-disable;
			output-low;
		};
	};
};

&spi4 {
	status = "okay";
	#address-cells = <1>;
	#size-cells = <0>;
	num-cs = <1>;
	tsp_himax: himax_ts@1 {
		compatible = "himax,hxcommon";

		pinctrl-names = "default", "on_state", "off_state";
		pinctrl-0 = <&himax_tsp_intr_on &himax_tsp_reset_on &himax_tsp_on_miso &himax_tsp_on_cs &himax_tsp_on_mosi &himax_tsp_on_clk>;
		pinctrl-1 = <&himax_tsp_intr_on &himax_tsp_reset_on &himax_tsp_on_miso &himax_tsp_on_cs &himax_tsp_on_mosi &himax_tsp_on_clk>;
		pinctrl-2 = <&himax_tsp_intr_off &himax_tsp_off_miso &himax_tsp_off_cs &himax_tsp_off_mosi &himax_tsp_off_clk>;
		//&reset_off need to control at driver, spi low -> need 1frame delay -> tsp_reset low.

		reg = <1>; //Same as CS ID
		spi-max-frequency = <10000000>;
		himax,rst-gpio = <SEC_GPIO_REF(AP,pio,4) 0x00>;
		himax,irq-gpio = <SEC_GPIO_REF(AP,pio,10) 0x00>;

		himax,enable_sysinput_enabled;
	};
};

/* /home/dpi/qb5_8815/workspace/P4_1716/android/kernel/kmodule/input/touchscreen/himax/hx83xxx_spi/dts/input-mtk-tsp-hx83xxx_spi.a13ve.dtsi */
&himax_tsp_on_cs {
	pins_cmd_dat{
		pinmux = <MTK_PINMUX(SEC_GPIO_NUM(AP,pio,18), 2)>;
		bias-disable;
	};
};

&himax_tsp_on_clk {
	pins_cmd_dat{
		pinmux = <MTK_PINMUX(SEC_GPIO_NUM(AP,pio,20), 2)>;
		bias-disable;
	};
};

&himax_tsp_on_mosi {
	pins_cmd_dat{
		pinmux = <MTK_PINMUX(SEC_GPIO_NUM(AP,pio,19), 2)>;
		bias-disable;
	};
};

&himax_tsp_on_miso {
	pins_cmd_dat{
		pinmux = <MTK_PINMUX(SEC_GPIO_NUM(AP,pio,17), 2)>;
		bias-disable;
	};
};

&pio {
	himax_tsp_id1_default: himax_tsp_id1_default {
		pins_cmd_dat {
			pinmux = <PINMUX_GPIO165__FUNC_GPIO165>;
			slew-rate = <0>;
			input-enable;
			bias-disable;
		};
	};

	himax_tsp_id2_default: himax_tsp_id2_default {
		pins_cmd_dat {
			pinmux = <PINMUX_GPIO153__FUNC_GPIO153>;
			slew-rate = <0>;
			input-enable;
			bias-disable;
		};
	};

	himax_tsp_id3_default: himax_tsp_id3_default {
		pins_cmd_dat {
			pinmux = <PINMUX_GPIO150__FUNC_GPIO150>;
			slew-rate = <0>;
			input-enable;
			bias-disable;
		};
	};
};

&spi4 {
	num-cs = <2>;
};
&tsp_himax{
	pinctrl-names = "default", "on_state", "off_state";
	pinctrl-0 = <&himax_tsp_intr_on &himax_tsp_reset_on &himax_default_miso &himax_tsp_off_cs &himax_tsp_off_mosi &himax_tsp_off_clk &himax_tsp_id1_default &himax_tsp_id2_default &himax_tsp_id3_default>;
	pinctrl-1 = <&himax_tsp_intr_on &himax_tsp_reset_on &himax_tsp_on_miso &himax_tsp_on_cs &himax_tsp_on_mosi &himax_tsp_on_clk &himax_tsp_id1_default &himax_tsp_id2_default &himax_tsp_id3_default>;
	pinctrl-2 = <&himax_tsp_intr_off &himax_tsp_off_miso &himax_tsp_off_cs &himax_tsp_off_mosi &himax_tsp_off_clk &himax_tsp_id1_default &himax_tsp_id2_default &himax_tsp_id3_default>;
	//&reset_off need to control at driver, spi low -> need 1frame delay -> tsp_reset low.

	himax,panel-coords = <1080 2408>;
	himax,display-coords = <1080 2408>;
	himax,fix_touch_info = <36 18 0 1080 2408 10 1 1>;
	//FIX_HX_RX_NUM,FIX_HX_TX_NUM,FIX_HX_BT_NUM,FIX_HX_X_RES,FIX_HX_Y_RES,FIX_HX_MAX_PT,FIX_HX_XY_REVERSE
	himax,project_name = "A13VE", "A137";

	support_aot;
	himax,support_ear_detect_mode;
	himax,prox_lp_scan_enabled;

	himax,lcdid1-gpio = <&pio 165 0x0>;
	himax,lcdid2-gpio = <&pio 153 0x0>;
	himax,lcdid3-gpio = <&pio 150 0x0>;

	himax,lcdid = <4>;	// 0,BOE_Himax
	himax,lcdtype = <0 0 0 0 0x4b6230>;
	himax,fw_name = "","","","","tsp_himax/hx83112f_boe_a13ve.bin";

	himax,name_lcd_rst = "lcd_rst";
	himax,name_lcd_vddi = "lcd_vddi";
	himax,name_lcd_bl_en = "lcd_bl_en";
	himax,name_lcd_vsp = "lcd_vsp";
	himax,name_lcd_vsn = "lcd_vsn";

	himax,one_frame_delay = <20>;
	himax,report_type = <1>;
};

/* #include "../dc_vibrator.dtsi" */                 /* From dc_vibrator.py */
/ {
	fragment@smd {
		target-path = "/";
			__overlay__ {
				samsung_mobile_device {
					dc_vibrator {
						compatible = "samsung,dc_vibrator";
						status = "okay";
						dc_vib,motor_type = "COINDC";
						dc_vib,regulator_name = "vibr";
					};
				};
			};
	};
};

/* #include "../s2mpb03.dtsi" */                     /* From s2mpb03.py */
&sw_i2c0 {
	#address-cells = <1>;
	#size-cells = <0>;
	status = "okay";
	s2mpb03_pmic@56 {
		compatible = "samsung,s2mpb03pmic";
		reg = <0x56>;
		s2mpb03,wakeup;

		regulators {
			s2mpb03_0_l1: s2mpb03-ldo1 {
				regulator-name = "CAM0_s2mpb03-l1";
				regulator-min-microvolt = <1050000>;
				regulator-max-microvolt = <1050000>;
				
				 
			};

			s2mpb03_0_l2: s2mpb03-ldo2 {
				regulator-name = "CAM0_s2mpb03-l2";
				regulator-min-microvolt = <1100000>;
				regulator-max-microvolt = <1100000>;
				
				 
			};

			s2mpb03_0_l3: s2mpb03-ldo3 {
				regulator-name = "CAM0_s2mpb03-l3";
				regulator-min-microvolt = <1800000>;
				regulator-max-microvolt = <1800000>;
				
				 
			};

			s2mpb03_0_l4: s2mpb03-ldo4 {
				regulator-name = "CAM0_s2mpb03-l4";
				regulator-min-microvolt = <1100000>;
				regulator-max-microvolt = <1100000>;
				
				 
			};

			s2mpb03_0_l5: s2mpb03-ldo5 {
				regulator-name = "CAM0_s2mpb03-l5";
				regulator-min-microvolt = <2150000>;
				regulator-max-microvolt = <2150000>;
				
				 
			};

			s2mpb03_0_l6: s2mpb03-ldo6 {
				regulator-name = "CAM0_s2mpb03-l6";
				regulator-min-microvolt = <2800000>;
				regulator-max-microvolt = <2800000>;
				
				 
			};

			s2mpb03_0_l7: s2mpb03-ldo7 {
				regulator-name = "CAM0_s2mpb03-l7";
				regulator-min-microvolt = <2800000>;
				regulator-max-microvolt = <2800000>;
				
				 
			};
		};
	};
};

/* #include "../sensors_isg6320.dtsi" */             /* From sensors_isg6320.py */
&pio {
	grip_i2c_sda: grip-i2c-sda {
		GPIO_CONFIG_PUD_DRV(AP,pio,98, FUNC_INPUT, PULL_NONE, DRV_LV2);
	};
	grip_i2c_scl: grip-i2c-scl {
		GPIO_CONFIG_PUD_DRV(AP,pio,6, FUNC_INPUT, PULL_NONE, DRV_LV2);
	};
};

&pio {
	grip_int: grip-int {
		GPIO_CONFIG_PUD_DRV(AP,pio,75, FUNC_INPUT_WAKEUP, PULL_NONE, DRV_LV2);
	};
};

#if 1
&pio {
	grip_ldo_en: grip-ldo-en {
		GPIO_CONFIG_PUD(AP,pio,151, FUNC_OUTPUT_HIGH, PULL_NONE);
	};
};
#endif

&sw_i2c1 {
	pinctrl-names = "default";
	pinctrl-0 = <&grip_i2c_sda
				 &grip_i2c_scl
#if 1
				 &grip_ldo_en
#endif
				 >;
	status = "okay";
	clock-frequency = <100000>;

	isg6320: isg6320@2E {
		compatible = "isg6320";
		reg = <0x2E>;
		status = "okay";
		pinctrl-names = "default";
		pinctrl-0 = <&grip_int>;

		interrupt-parent = <SEC_GPIO_TYPE(AP,pio,75)>;
		interrupts = <SEC_GPIO_NUM(AP,pio,75) 0>;

		isg6320,irq-gpio = <SEC_GPIO_REF(AP,pio,75) 0>;

		isg6320,reg_num = <150>;
		isg6320,multi_use = <1>;
		isg6320,hallic_detect = <0>;
		isg6320,hallic_cert_detect = <0>;
	};
};

#if 0

&${gpio_grip_sub_i2c_parent} {
	grip_sub_i2c_sda: grip-sub-i2c-sda {
		GPIO_CONFIG_PUD_DRV(${gpio_grip_sub_i2c_sda}, FUNC_INPUT, PULL_NONE, DRV_LV2);
	};
	grip_sub_i2c_scl: grip-sub-i2c-scl {
		GPIO_CONFIG_PUD_DRV(${gpio_grip_sub_i2c_scl}, FUNC_INPUT, PULL_NONE, DRV_LV2);
	};
};

&${gpio_grip_sub_irq_parent} {
	grip_sub_int: grip-sub-int {
		GPIO_CONFIG_PUD_DRV(${gpio_grip_sub_irq}, FUNC_INPUT_WAKEUP, PULL_NONE, DRV_LV2);
	};
};

#if 0
&${gpio_grip_sub_en_parent} {
	grip_sub_ldo_en: grip-sub-ldo-en {
		GPIO_CONFIG_PUD(${gpio_grip_sub_en}, FUNC_OUTPUT_HIGH, PULL_NONE);
	};
};
#endif

&${i2c_grip_sub} {
	pinctrl-names = "default";
	pinctrl-0 = <&grip_sub_i2c_sda
				 &grip_sub_i2c_scl
#if 0
				 &grip_sub_ldo_en
#endif
				 >;
	status = "okay";
	#clock-frequency = <100000>;
	isg6320_sub: isg6320-sub@28 {
		compatible = "isg6320_sub";
		reg = <0x28>;
		status = "okay";
		pinctrl-names = "default";
		pinctrl-0 = <&grip_sub_int>;

		interrupt-parent = <SEC_GPIO_TYPE(${gpio_grip_sub_irq})>;
		interrupts = <SEC_GPIO_NUM(${gpio_grip_sub_irq}) 0>;

		isg6320_sub,irq-gpio = <SEC_GPIO_REF(${gpio_grip_sub_irq}) 0>;

		isg6320_sub,reg_num = <150>;
		isg6320_sub,multi_use = <0>;
		isg6320_sub,hallic_detect = <0>;
		isg6320_sub,hallic_cert_detect = <0>;
	};
};

#endif/* isg6320_sub */

#if 0

&${gpio_grip_wifi_i2c_parent} {
	grip_wifi_i2c_sda: grip-wifi-i2c-sda {
		GPIO_CONFIG_PUD_DRV(${gpio_grip_wifi_i2c_sda}, FUNC_INPUT, PULL_NONE, DRV_LV2);
	};
	grip_wifi_i2c_scl: grip-wifi-i2c-scl {
		GPIO_CONFIG_PUD_DRV(${gpio_grip_wifi_i2c_scl}, FUNC_INPUT, PULL_NONE, DRV_LV2);
	};
};

&${gpio_grip_wifi_irq_parent} {
	grip_wifi_int: grip-wifi-int {
		GPIO_CONFIG_PUD_DRV(${gpio_grip_wifi_irq}, FUNC_INPUT_WAKEUP, PULL_NONE, DRV_LV2);
	};
};

#if 0
&${gpio_grip_wifi_en_parent} {
	grip_wifi_ldo_en: grip-wifi-ldo-en {
		GPIO_CONFIG_PUD(${gpio_grip_wifi_en}, FUNC_OUTPUT_HIGH, PULL_NONE);
	};
};
#endif

&${i2c_grip_wifi} {
	pinctrl-names = "default";
	pinctrl-0 = <&grip_wifi_i2c_sda
				 &grip_wifi_i2c_scl
#if 0
				 &grip_wifi_ldo_en
#endif
				 >;
	status = "okay";
	#clock-frequency = <100000>;

	isg6320_wifi: isg6320-wifi@28 {
		compatible = "isg6320_wifi";
		reg = <0x28>;
		status = "okay";
		pinctrl-names = "default";
		pinctrl-0 = <&grip_wifi_int>;

		interrupt-parent = <SEC_GPIO_TYPE(${gpio_grip_wifi_irq})>;
		interrupts = <SEC_GPIO_NUM(${gpio_grip_wifi_irq}) 0>;

		isg6320_wifi,irq-gpio = <SEC_GPIO_REF(${gpio_grip_wifi_irq}) 0>;

		isg6320_wifi,reg_num = <150>;
		isg6320_wifi,multi_use = <0>;
		isg6320_wifi,hallic_detect = <0>;
		isg6320_wifi,hallic_cert_detect = <0>;
	};
};

#endif/* isg6320_wifi */

/* /home/dpi/qb5_8815/workspace/P4_1716/android/kernel/kmodule/sensors/isg6320/dts/isg6320.a13ve.dtsi */
&isg6320 {
	isg6320,reg_num = <107>;
	isg6320,set_reg = /bits/ 8 <
				0x4B 0x45
				0x31 0x00
				0x17 0x3B
				0x18 0x38
				0x19 0x00
				0x1A 0x1E
				0x1B 0x16
				0x1C 0x1E
				0x1D 0x34
				0x1E 0x00
				0x1F 0x07
				0x20 0x16
				0x21 0x16
				0x22 0x25
				0x23 0x34
				0x24 0x07
				0x25 0x25
				0x26 0x34
				0x27 0x07
				0x28 0x16
				0x2B 0x29
				0x2F 0x77
				0x38 0x31
				0x60 0x05
				0x61 0x56
				0x62 0x49
				0x91 0x49
				0x65 0x32
				0x67 0x58
				0x68 0x34
				0x69 0x40
				0x6A 0x00
				0x6C 0x80
				0x6D 0x84
				0x6E 0x44
				0x6F 0x08
				0x70 0x60
				0x71 0xC0
				0x72 0x40
				0x73 0x00
				0x74 0xED
				0x75 0x40
				0x76 0xED
				0x77 0xFA
				0x78 0x90
				0x79 0xF0
				0x7C 0x60
				0x7D 0x1E
				0x89 0x01
				0x8A 0x69
				0x8B 0x7D
				0x8C 0x7D
				0x94 0x05
				0x95 0x48
				0x96 0x49
				0xC5 0x49
				0x99 0x32
				0x9B 0x58
				0x9C 0x34
				0x9D 0x40
				0x9E 0x00
				0xA0 0x80
				0xA1 0x82
				0xA2 0x44
				0xA3 0x08
				0xA4 0x60
				0xA5 0xC0
				0xA6 0x40
				0xA7 0x00
				0xA8 0xED
				0xA9 0x40
				0xAA 0xED
				0xAB 0xF9
				0xAC 0xA0
				0xAD 0xF0
				0xB0 0x60
				0xB1 0x1A
				0xBD 0x01
				0xBE 0x69
				0xBF 0x7D
				0xC0 0x7D
				0x51 0x06
				0x52 0x10
				0x55 0x20
				0x56 0x30
				0x59 0x20
				0x5A 0x1D
				0xD1 0x04
				0xD2 0x10
				0xD5 0x20
				0xD6 0x30
				0xD9 0x28
				0xDA 0x0A
				0x37 0x33
				0x90 0x13
				0xC4 0x13
				0x05 0xB8
				0x06 0x80
				0x07 0x0D
				0x08 0x01
				0x09 0x80
				0x11 0x09
				0x12 0x08
				0x14 0x33
				0x15 0x13
				0x16 0x13
				0x2C 0x03
				>;
};

/* #include "../nfc_nxp.dtsi" */                     /* From nfc_nxp.py */
/*
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 and
 * only version 2 as published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 */

&pio {
	nfc_ven: nfc_ven {
		pins_cmd_dat{
			pinmux = <MTK_PINMUX(SEC_GPIO_NUM(AP,pio,78), 0)>;
			output-low;
			bias-disable;
		};
	};
	ven_nc: ven_nc {
		pins_cmd_dat{
			pinmux = <MTK_PINMUX(SEC_GPIO_NUM(AP,pio,78), 0)>;
			input-enable;
			bias-pull-down;
		};
	};
};

&pio {
	nfc_firm: nfc_firm {
		pins_cmd_dat{
			pinmux = <MTK_PINMUX(SEC_GPIO_NUM(AP,pio,72), 0)>;
			output-low;
			bias-disable;
		};
	};
	firm_nc: firm_nc {
		pins_cmd_dat{
			pinmux = <MTK_PINMUX(SEC_GPIO_NUM(AP,pio,72), 0)>;
			input-enable;
			bias-pull-down;
		};
	};
};

&pio {
	nfc_clk_req: nfc_clk_req {
		pins_cmd_dat{
			pinmux =  <MTK_PINMUX(SEC_GPIO_NUM(AP,pio,11), 0)>;
			input-enable;
			bias-pull-down;
		};
	};
	clk_req_nc: clk_req_nc {
		pins_cmd_dat{
			pinmux =  <MTK_PINMUX(SEC_GPIO_NUM(AP,pio,11), 0)>;
			input-enable;
			bias-pull-down;
		};
	};
};

&pio {
	nfc_irq: nfc_irq {
		pins_cmd_dat {
			pinmux = <MTK_PINMUX(SEC_GPIO_NUM(AP,pio,3), 0)>;
			input-enable;
			bias-pull-down;
		};
	};

	irq_nc: irq_nc {
		pins_cmd_dat {
			pinmux = <MTK_PINMUX(SEC_GPIO_NUM(AP,pio,3), 0)>;
			input-enable;
			bias-pull-down;
		};
	};
};

&pio {
	nfc_i2c_off: nfc_i2c_off {
		pins_cmd_dat {
			pinmux = <MTK_PINMUX(SEC_GPIO_NUM(AP,pio,48), 0)>,
					<MTK_PINMUX(SEC_GPIO_NUM(AP,pio,49), 0)>;
			input-enable;
			bias-pull-down;
		};
	};
	nfc_i2c_on: nfc_i2c_on {
		pins_cmd_dat {
			pinmux = <MTK_PINMUX(SEC_GPIO_NUM(AP,pio,48), 1)>,
					<MTK_PINMUX(SEC_GPIO_NUM(AP,pio,49), 1)>;
			bias-pull-up;
		};
	};
};

#if 1
&pio {
	nfc_check: nfc_check {
		pins_cmd_dat {
			pinmux = <MTK_PINMUX(SEC_GPIO_NUM(AP,pio,52), 0)>;
			input-enable;
			bias-disable;
		};
	};
};
#endif

&i2c5 {
	status = "ok";
	clock-frequency = <400000>;
	mediatek,use-open-drain;

	pn547@2B {
		compatible = "pn547";
		reg = <0x2B>;

		interrupt-parent = <&pio>;
		interrupts = <SEC_GPIO_NUM(AP,pio,3) IRQ_TYPE_EDGE_RISING
			SEC_GPIO_NUM(AP,pio,3) 0>;

		pn547,irq-gpio = <SEC_GPIO_REF(AP,pio,3) 0>;
		pn547,ven-gpio = <SEC_GPIO_REF(AP,pio,78) 0>;
		pn547,firm-gpio = <SEC_GPIO_REF(AP,pio,72) 0>;
		pn547,clk_req-gpio = <SEC_GPIO_REF(AP,pio,11) 0>;
#if 1
		pn547,clk_req_wake;
#endif
#if 1
		nfc_pvdd-supply = <&mt_pmic_vcamio_ldo_reg>;
#endif
		pn547,ldo_control;
#if 1
		pn547,nfc-det-gpio = <SEC_GPIO_REF(AP,pio,52) 0>;
#endif
		pn547,ap_vendor = "mtk";
		pinctrl-names = "default", "nfc_nc", "i2c_off";
		pinctrl-0 = <&nfc_ven &nfc_firm &nfc_clk_req &nfc_irq &nfc_i2c_on
#if 1
					&nfc_check
#endif
					>;
		pinctrl-1 = <&ven_nc &firm_nc &clk_req_nc &irq_nc &nfc_i2c_off>;
		pinctrl-2 = <&nfc_i2c_off>;
	};
};

#if 0
#if 0 && !defined(CONFIG_SEC_FACTORY)
&tlmm {
/*	gpio-reserved-ranges = <SEC_GPIO_NUM(${ese_spi_miso}) 4>; */
};
#endif

&${ese_spi_parent} {
	ese_spi_bus_func: spi_bus_func {
		pins_cmd_dat {
			/* spi func is 2, but this can be different by AP */
			pinmux = <MTK_PINMUX(SEC_GPIO_NUM(${ese_spi_miso}), 2)>,
				<MTK_PINMUX(SEC_GPIO_NUM(${ese_spi_mosi}), 2)>,
				<MTK_PINMUX(SEC_GPIO_NUM(${ese_spi_cs}), 2)>,
				<MTK_PINMUX(SEC_GPIO_NUM(${ese_spi_clk}), 2)>;
			bias-disable;
		};
	};

	ese_spi_cs_sleep: spi_cs_sleep {
		pins_cmd_dat {
			pinmux = <MTK_PINMUX(SEC_GPIO_NUM(${ese_spi_cs}), 0)>;
			output-high;
			bias-pull-up;
		};
	};

	ese_spi_clk_sleep: spi_clk_sleep {
		pins_cmd_dat {
			pinmux = <MTK_PINMUX(SEC_GPIO_NUM(${ese_spi_clk}), 0)>;
			output-low;
			bias-pull-down;
		};
	};

	ese_spi_mosi_sleep: spi_mosi_sleep {
		pins_cmd_dat {
			pinmux = <MTK_PINMUX(SEC_GPIO_NUM(${ese_spi_mosi}), 0)>;
			output-low;
			bias-pull-down;
		};
	};

	ese_spi_miso_sleep: spi_miso_sleep {
		pins_cmd_dat {
			pinmux = <MTK_PINMUX(SEC_GPIO_NUM(${ese_spi_miso}), 0)>;
			input-enable;
			bias-disable;
		};
	};

	ese_spi_all_out_low: spi_all_out_low {
		pins_cmd_dat {
			pinmux = <MTK_PINMUX(SEC_GPIO_NUM(${ese_spi_miso}), 0)>,
				<MTK_PINMUX(SEC_GPIO_NUM(${ese_spi_mosi}), 0)>,
				<MTK_PINMUX(SEC_GPIO_NUM(${ese_spi_cs}), 0)>,
				<MTK_PINMUX(SEC_GPIO_NUM(${ese_spi_clk}), 0)>;
			output-low;
			bias-pull-down;
		};
	};
};

#if 0
&${ese_check_parent} {
	ese_check_default: check_default {
		pins_cmd_dat {
			pinmux = <MTK_PINMUX(SEC_GPIO_NUM(${ese_check}), 0)>;
			input-enable;
			bias-disable;
		};
	};
};
#endif

/* #active
 * - function/no-pull/X
 * #idle
 * - mosi,clk: out/pull-down/low
 * - cs: out/pull-up/high
 * - miso: input/pull-non/X
 */
&${ese_spi} {
	status = "ok";
	/delete-property/ pinctrl-names;
	/delete-property/ pinctrl-0;
	pinctrl-names = "ese_on", "ese_off", "lpm";
	pinctrl-0 = <&ese_spi_bus_func>;
	pinctrl-1 = <&ese_spi_cs_sleep &ese_spi_clk_sleep &ese_spi_mosi_sleep &ese_spi_miso_sleep>;
	pinctrl-2 = <&ese_spi_all_out_low>;

	ese_spi@0 {
		compatible = "p61";
		reg = <0>;
		spi-max-frequency = <8000000>;
		p61,ap_vendor = "mtk";
#if 0
		ese-det-gpio = <SEC_GPIO_REF(${ese_check}) 0>;
		pinctrl-names = "default";
		pinctrl-0 = <&ese_check_default>;
#endif
	};
};
#endif

/* revision devicetree for general */
#include "mt6769t.a13ve_eur_open.00.dtsi"

/ {
	compatible = "Samsung,A13ve EUR OPEN 00","Mediatek,MT6769T";
	dtbo-hw_rev = <0>;
	dtbo-hw_rev_end = <32>;
};
